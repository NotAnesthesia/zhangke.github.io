<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pat_1006]]></title>
    <url>%2Fpat-1006%2F</url>
    <content type="text"><![CDATA[1006. Sign In and Sign Out (25)At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: 1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input: 12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output: 1SC3021234 CS301133 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int num; cin&gt;&gt;num; vector&lt;string&gt; id; //编号 vector&lt;string&gt; in; //进去时间 vector&lt;string&gt; out; //出去时间 for (int i=0; i&lt;num; i++) &#123; string temp; cin&gt;&gt;temp; id.push_back(temp); cin&gt;&gt;temp; in.push_back(temp); cin&gt;&gt;temp; out.push_back(temp); &#125; int signin_id=0; int signout_id=0; int minhour=0,minmin=0,minsec=0; int maxhour=0,maxmin=0,maxsec=0;// int minsec=0;// int maxsec=0;// string maxtime=&quot;00:00:00&quot;; /* 先设定第一条数据为进门最早，否则初始化为零会出错 */ string temp=in[0]; minhour=(temp[0]-&apos;0&apos;)*10+temp[1]-&apos;0&apos;; minmin=(temp[3]-&apos;0&apos;)*10+temp[4]-&apos;0&apos;; minsec=(temp[6]-&apos;0&apos;)*10+temp[7]-&apos;0&apos;; for (int i=0; i&lt;id.size(); i++) &#123; string temp=in[i]; int hour=(temp[0]-&apos;0&apos;)*10+temp[1]-&apos;0&apos;; int min=(temp[3]-&apos;0&apos;)*10+temp[4]-&apos;0&apos;; int sec=(temp[6]-&apos;0&apos;)*10+temp[7]-&apos;0&apos;;// int sumsec=hour*3600+min*60+sec; if (hour==minhour) &#123; if (min==minmin) &#123; if (sec&lt;minsec) &#123; minsec=sec; signin_id=i; &#125; &#125; else if (min&lt;minmin) &#123; minmin=min; signin_id=i; &#125; &#125; else if (hour&lt;minhour) &#123; minhour=hour; signin_id=i; &#125; temp=out[i]; hour=(temp[0]-&apos;0&apos;)*10+temp[1]-&apos;0&apos;; min=(temp[3]-&apos;0&apos;)*10+temp[4]-&apos;0&apos;; sec=(temp[6]-&apos;0&apos;)*10+temp[7]-&apos;0&apos;; if (hour==maxhour) &#123; if (min==maxmin) &#123; if (sec&gt;maxsec) &#123; maxsec=sec; signout_id=i; &#125; &#125; else if (min&gt;maxmin) &#123; maxmin=min; signout_id=i; &#125; &#125; else if (hour&gt;maxhour) &#123; maxhour=hour; signout_id=i; &#125;// if (sumsec&lt;minsec) &#123;// minsec=sumsec;// signin_id=i;// &#125;// if (sumsec&gt;maxsec) &#123;// maxsec=sumsec;// signout_id=i;// &#125; &#125; cout&lt;&lt;id[signin_id]&lt;&lt;&quot; &quot;&lt;&lt;id[signout_id]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pat_1005]]></title>
    <url>%2Fpat-1005%2F</url>
    <content type="text"><![CDATA[1005. Spell It Right (20)Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification: Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100). Output Specification: For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input: 112345 Sample Output: 1one five 简单题：字符串处理 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int sum=0; string a; cin&gt;&gt;a; for (int i=0; i&lt;a.length(); i++) &#123; /* 一个数字字符的ASCII码减去字符0的ASCII码等于该数字的数值 */ sum+=a[i]-&apos;0&apos;; &#125; string s=to_string(sum); string chinese[10]=&#123;&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;,&quot;five&quot;,&quot;six&quot;,&quot;seven&quot;,&quot;eight&quot;,&quot;nine&quot;&#125;; for (int j=0; j&lt;s.length()-1; j++) &#123; int temp=s[j]-&apos;0&apos;; cout&lt;&lt;chinese[temp]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;chinese[s[s.length()-1]-&apos;0&apos;]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pat_1004]]></title>
    <url>%2Fpat-1004%2F</url>
    <content type="text"><![CDATA[1004. Counting Leaves (30)Input Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] Output For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line. Sample Input 122 101 1 02 Sample Output 10 1 BFS: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //二维数组存储所有节点int level[100]=&#123;0&#125;; //节点对应的层次int leafnum[100]=&#123;0&#125;; //存储对应深度的叶子节点个数int maxlevel=0; //最大层次void BFS() &#123; queue&lt;int&gt; q; q.push(1); level[1]=0; while (!q.empty()) &#123; int index=q.front(); q.pop(); if (node[index].size()==0) &#123; //没有叶子节点 leafnum[level[index]]++; maxlevel=max(level[index], maxlevel); &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; q.push(node[index][i]); level[node[index][i]]=level[index]+1; &#125; &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; BFS(); for (int i=0; i&lt;maxlevel; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;leafnum[maxlevel]; return 0;&#125; DFS: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //二维数组存储所有节点//int level[100]=&#123;0&#125;;int leafnum[100]=&#123;0&#125;; //存储对应深度的叶子节点个数//int maxlevel=0;int maxdepth=0; //最大深度//void BFS() &#123;// queue&lt;int&gt; q;// q.push(1);// level[1]=0;// while (!q.empty()) &#123;//// int index=q.front();// q.pop();//// if (node[index].size()==0) &#123;// //没有叶子节点// leafnum[level[index]]++;// maxlevel=max(level[index], maxlevel);// &#125;//// for (int i=0; i&lt;node[index].size(); i++) &#123;// q.push(node[index][i]);// level[node[index][i]]=level[index]+1;// &#125;// &#125;////&#125;void DFS(int index, int depth) &#123; maxdepth=max(depth, maxdepth); if (node[index].size()==0) &#123; leafnum[depth]++; return; &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; DFS(node[index][i], depth+1); &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; DFS(1,0); for (int i=0; i&lt;maxdepth; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;leafnum[maxdepth]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pat_1003]]></title>
    <url>%2Fpat-1003%2F</url>
    <content type="text"><![CDATA[1003. Emergency (25)As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output 12 4 此题用dijastra算法搞定，搞了两天，先搞定dijastra算法，再整这个变种，参考了网上的博客写的，自己之前写的好多bug。 此处记一个C++知识点，memset函数初始化一个集合。 memset 函数是内存赋值函数，用来给某一块内存空间进行赋值的。 其原型是：void memset(void _Dst, int _Val, size_t _Size) _Dst是目标起始地址，_Val是要赋的值，_Size是要赋值的字节数。 例如代码中的 memset(mux, MAX, sizeof(mux)); 不多说，贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; const int MAX=1000000; const int CITY=501; int cityNum,roadNum,in,to; int rescue[CITY]; int mux[CITY][CITY]; int dis[CITY]; int amount[CITY]; int acount[CITY]; int v[MAX]; cin&gt;&gt;cityNum&gt;&gt;roadNum&gt;&gt;in&gt;&gt;to; for (int i=0; i&lt;cityNum; i++) &#123; cin&gt;&gt;rescue[i]; &#125; memset(mux, MAX, sizeof(mux)); memset(dis, MAX, sizeof(dis)); memset(v, 0, sizeof(v)); memset(amount, 0, sizeof(amount)); memset(acount, 0, sizeof(acount));// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=MAX;// for (int j=0; j&lt;cityNum; j++) &#123;// mux[i][j]=&#123;MAX&#125;;// if (i==j) &#123;// mux[i][j]=0;// &#125;// &#125;// &#125; for (int j=0; j&lt;roadNum; j++) &#123; int linka,linkb,dis; cin&gt;&gt;linka&gt;&gt;linkb&gt;&gt;dis; mux[linka][linkb]=mux[linkb][linka]=dis; &#125;// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=mux[in][i];// v[i]=0;// &#125; dis[in]=0; acount[in]=1; amount[in]=rescue[in]; v[in]=1; for (int i=1; i&lt;cityNum; i++) &#123; int u=in,min=MAX; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0&amp;&amp;dis[i]&lt;min) &#123; min=dis[i]; u=i; &#125; &#125; // if (min==MAX||u==to) &#123;// break;// &#125; v[u]=1; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0) &#123; if (dis[i]&gt;dis[u]+mux[u][i]) &#123; dis[i]=dis[u]+mux[u][i]; amount[i]=amount[u]+rescue[i]; acount[i]=acount[u]; &#125; else if (dis[i]==dis[u]+mux[u][i]) &#123; acount[i]+=acount[u]; if (amount[i]&lt;amount[u]+rescue[i]) &#123; amount[i]=amount[u]+rescue[i]; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;acount[to]&lt;&lt;&quot; &quot;&lt;&lt;amount[to]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pat_1002]]></title>
    <url>%2Fpat-1002%2F</url>
    <content type="text"><![CDATA[1002. A+B for Polynomials (25)This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 13 2 1.5 1 2.9 0 3.2 第二题还算是个简单题，关于多项式，是昨天AC的，今天来贴上代码。 首先是用Java写的，代码有问题，后来改用C++了 不多说，贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.TreeMap;public class Sum1 &#123; /** * Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner=new Scanner(System.in); int num1=scanner.nextInt(); TreeMap&lt;Integer, Double&gt; map1 = new TreeMap&lt;Integer, Double&gt;(); TreeMap&lt;Integer, Double&gt; map2 = new TreeMap&lt;Integer, Double&gt;();// Map&lt;Integer, Double&gt; map1 = Collections.synchronizedMap(m1);// Map&lt;Integer, Double&gt; map2 = Collections.synchronizedMap(m2); for (int i = 0; i &lt; num1; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map1.put(key, value); &#125; int num2=scanner.nextInt(); for (int i = 0; i &lt; num2; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map2.put(key, value); &#125; scanner.close();// synchronized (map1) &#123;// synchronized (map2) &#123;// for (int key1 : map1.keySet()) &#123;// for (int key2 : map2.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// &#125;// &#125;// &#125;// &#125;// // &#125; // for (int k2 : map2.keySet()) &#123;// for (int k1 : map1.keySet()) &#123;// if (k1==k2) &#123;// break;// &#125;// double value=map2.get(k2);// map1.put(k2, value);// &#125;// &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it1 = map1.entrySet().iterator(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it2 = map2.entrySet().iterator(); int flag = 0; while (it2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry2 = it2.next(); while (it1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry1 = it1.next(); //System.out.println(entry2.getKey()+&quot; &quot;+entry1.getKey()); //System.out.println(entry1.getKey().toString().equals(entry2.getKey().toString())); if (entry1.getKey().equals(entry2.getKey())) &#123; map1.remove(entry1.getKey()); map1.put(entry1.getKey(), entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); System.out.println(entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); flag=1; &#125; &#125; if (flag==0) &#123; map1.put(entry2.getKey(), entry2.getValue()); &#125; if (flag==1) &#123; flag=0; &#125; &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries1 = map1.entrySet().iterator(); while (entries1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries1.next(); System.out.print(entry.getKey()+&quot; &quot;+entry.getValue()+&quot; &quot;); &#125; System.out.println(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries2 = map2.entrySet().iterator(); while (entries2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries2.next(); System.out.print(entry.getKey()+&quot; &quot;+entry.getValue()+&quot; &quot;); &#125; System.out.println();// for (int key1:map1.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// break;// &#125;// map1.put(key2, map2.get(key2));// &#125; Map&lt;Integer, Double&gt; map=new TreeMap&lt;Integer, Double&gt;(Collections.reverseOrder()); map.putAll(map1); System.out.print(map.size() + &quot; &quot;); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries.next(); System.out.print(entry.getKey()+&quot; &quot;+entry.getValue()+&quot; &quot;); &#125; &#125;&#125; 这个我是用treemap来存储，使得其自动排序，后面用到了Collections.reverseOrder() 。 以下是C++代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main() &#123; // insert code here... float line[1001]=&#123;0&#125;; int count1,count2,m; int count=0; float n; cin&gt;&gt;count1; for (int i =0; i&lt;count1; i++) &#123; scanf(&quot;%d%f&quot;,&amp;m,&amp;n); line[m]+=n; &#125; cin&gt;&gt;count2; for (int i =0; i&lt;count2; i++) &#123; scanf(&quot;%d%f&quot;,&amp;m,&amp;n); line[m]+=n; &#125; for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; count++; &#125; &#125; printf(&quot;%d&quot;,count); for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; printf(&quot; %d %.1f&quot;,i,line[i]); &#125; &#125; return 0;&#125; 感觉用C++的数组实现简单得多啊。]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pat_1001]]></title>
    <url>%2Fpat-1001%2F</url>
    <content type="text"><![CDATA[pat第一题终于编译通过了，必须要class Main才行啊 1001. A+B Format (20)Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input 1-1000000 9 Sample Output 1-999,991 1234567891011121314151617181920212223242526import java.util.Scanner;class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); String sum = String.valueOf(a+b); for (int i = 0; i &lt; sum.length(); i++) &#123; System.out.print(sum.charAt(i)); if (sum.charAt(i)==&apos;-&apos;) &#123; continue; &#125; if ((i+1)%3==sum.length()%3 &amp;&amp; i!=(sum.length()-1)) &#123; System.out.print(&apos;,&apos;); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java_dynamicProxy]]></title>
    <url>%2Fjava-dynamicProxy%2F</url>
    <content type="text"><![CDATA[Spring有两大思想，一个是Ioc,一个是AOP, AOP的原理就是java的动态代理机制，所以本篇文章就是对java的动态机制的解释。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法： 12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 我们来通过一个实例来看看我们的动态代理模式是什么样的： 首先我们定义了一个Subject类型的接口，为其声明了两个方法： 123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; 接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject类： 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println(&quot;I want to rent my house&quot;); &#125; @Override public void hello(String str) &#123; System.out.println(&quot;hello: &quot; + str); &#125;&#125; 下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外： 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println(&quot;before rent house&quot;); System.out.println(&quot;Method:&quot; + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println(&quot;after rent house&quot;); return null; &#125;&#125; 最后，来看看我们的Client类： 1234567891011121314151617181920212223public class Client&#123; public static void main(String[] args) &#123; // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello(&quot;world&quot;); &#125;&#125; 我们先来看看控制台的输出： 1234567891011$Proxy0before rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()I want to rent my houseafter rent housebefore rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)hello: worldafter rent house 我们首先来看看 $Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？ 1Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); 可能我以为返回的这个代理对象会是Subject类型的对象，或者是InvocationHandler的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为Subject类型的对象？原因就是在newProxyInstance这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。 同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行： 12345678910111213141516public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println(&quot;before rent house&quot;); System.out.println(&quot;Method:&quot; + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println(&quot;after rent house&quot;); return null; &#125; 我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的： 123public abstract void com.xiaoluo.dynamicproxy.Subject.rent()public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String) 正好就是我们的Subject接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo new之后立即打开Markdown文稿]]></title>
    <url>%2Fhexo-openPostQuick%2F</url>
    <content type="text"><![CDATA[由于每次使用hexo new新建之后都要到文件夹里自己去找出文件再打开，当文件多起来更是件麻烦事。基于此，在网上发现有直接能在新建完后自动打开markdown文档的js脚本，怀着试一试的心态按着步骤走，最后成功了。 首先安装 shelljs模块，实现自动部署加载JS脚本，键入以下命令： 1npm install --save shelljs 在 Hexo 根目录的 scripts文件夹下新建一个 js文件。此处js脚本根据hexo版本而定。我的是hexo-cli:1.0.3 稍微修改后用这个脚本成功： 12345var exec = require(&apos;child_process&apos;).exec; hexo.on(&apos;new&apos;, function(data)&#123; exec(&apos;open -a &quot;/Applications/Typora.app&quot; &apos; + [data.path]);&#125;); 最后一行里面执行的是系统命令open -a “/Applications/Typora.app” path,直接就可以在终端用命令打开，是 OS X 下的open。换到Windows中,可能需要改为start。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class类加载机制]]></title>
    <url>%2Fjvm-leijiazai%2F</url>
    <content type="text"><![CDATA[类加载过程Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 ​ 这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定： 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。 ​ 下面详细讲述类加载过程中每个阶段所做的工作。 加载​ 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： ​ 1、通过一个类的全限定名来获取其定义的二进制字节流。 ​ 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ​ 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 ​ 注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。 ​ 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 ​ 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 ​ 说到加载，不得不提到类加载器，下面就具体讲述下类加载器。 ​ 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 ​ 站在Java虚拟机的角度来讲，只存在两种不同的类加载器： 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的）,是虚拟机自身的一部分。 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 ​ 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）,开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 ​ 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1）在执行非置信代码之前，自动验证数字签名。 2）动态地创建符合用户特定需要的定制化构建类。 3）从特定的场所取得java class，例如数据库中和网络中。 事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。 ​ 这几种类加载器的层次关系如下图所示： ​ 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 ​ 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 ​ 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。 验证​ 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验）,保证不存在不符合Java语法规范的元数据信息。 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解）,主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 准备​ 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： ​ 1、这时候进行内存分配的仅包括类变量（static）,而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 ​ 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等）,而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value = 3； ​ 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 ​ 下表列出了Java中所有基本数据类型以及reference类型的默认零值： 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 ​ 3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value = 3； ​ 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。 解析 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前）,还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 ​ 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态）,从而避免解析动作重复进行。 ​ 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。 ​ 1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 ​ 2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示： 从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序： 1234567891011121314151617181920212223242526class Super&#123; public static int m = 11; static&#123; System.out.println(&quot;执行了super类静态语句块&quot;); &#125;&#125;class Father extends Super&#123; public static int m = 33; static&#123; System.out.println(&quot;执行了父类静态语句块&quot;); &#125;&#125;class Child extends Father&#123; static&#123; System.out.println(&quot;执行了子类静态语句块&quot;); &#125;&#125;public class StaticTest&#123; public static void main(String[] args)&#123; System.out.println(Child.m); &#125;&#125; ​ 执行了super类静态语句块​ 执行了父类静态语句块​ 33​ 如果注释掉Father类中对m定义的那一行，则输出结果如下： ​ 执行了super类静态语句块​ 11 分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。 ​ 最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误： StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m都匹配​ System.out.println(Child.m);​ ^1 错误 ​ 3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 4、接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。 初始化​ 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 这里简单说明下()方法的执行规则: ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 ​ 下面给出一个简单的例子，以便更清晰地说明如上规则： 12345678910111213141516class Father&#123; public static int a = 1; static&#123; a = 2; &#125;&#125;class Child extends Father&#123; public static int b = a;&#125;public class ClinitTest&#123; public static void main(String[] args)&#123; System.out.println(Child.b); &#125;&#125; 执行上面的代码，会打印出2，也就是说b的值被赋为了2。 ​ 我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用()方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的()方法，根据规则2，在此之前，要先执行完其父类Father的()方法，又根据规则1，在执行()方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的()方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的()方法，这样便会将b的赋值为2. ​ 如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的()方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。 ​ 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量）,在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。 总结​ 整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码）,但这里的执行代码只是个开端，它仅限于()方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class类文件结构]]></title>
    <url>%2Fjvm-classFileConstructor%2F</url>
    <content type="text"><![CDATA[Class类文件结构无关的基石Sun 公司发布了各种平台上不同的虚拟机版本,这些不同平台上的虚拟机只识别字节码文件,这种字节码文件就是构成平台无关性的基石.除了平台无关性,语言无关性也有很大的优势, Java 虚拟机不和包括 Java 在内的所有语言绑定,只与”Class 文件”这种特定的二进制文件格式所关联, Class 文件包含了 Java 虚拟机指令和符号表以及若干其他辅助信息.虚拟机不关心 Class 的来源是何种语言. Class 文件结构Class 文件采用类似 C 语言结构体的伪结构体来存储数据,这种伪结构只有两种数据类型,无符号数和表.无符号数可以描述数字,索引引用,数量值或者按照 UTF-8编码构成的字符串值.表是由无符号数或者其他表作为数据项构成的复合数据类型 魔数与 Class 文件版本每个 Class 文件的头4个字节是魔数,它的唯一作用是确定当前文件能否被虚拟机进行加载.很多文件存储格式否使用魔数来进行身份识别,使用魔数而不使用扩展名是因为扩展名随意更改.紧接着魔数后的4个字节是版本号,高版本的虚拟机能够向下兼容以前版本的 Class 文件,但不能运行以后版本的 Class 文件. 常量池常量池中有14种常量类型,每种类型都有自己的结构.由于这些常量的个数是不固定的,所以在常量池的入口放置一项 u2类型的数据,代表常量池容量计数值.虚拟机的常量池主要存放两大类常量:字面量和符号引用.字面量接近于 Java 语言层面的常量概念,如字符串,声明为 final 的常量值等.符号引用则数据编译原理方面的概念,包括:类和结构的全限定名,字段和名称的描述符,方法的名称和描述符. 访问标识在常量池结束后的两个字节代表访问标识,用于识别类或者接口的访问信息,包括:这个 Class 是类还是接口,是否定义为 public 类型,是否定义为 abstract 类型等. 类索引,父类索引与接口索引集合Class 文件由这三项来确定类的继承关系,类索引确定这个类的全限定名,父类索引确定这个类父类的全限定名,接口索引集合用来描述这个类实现了那些接口. 字段表集合字段表用来描述类或接口中声明的变量,包括类级变量以及实例级变量,但不包括方法内部声明的局部变量. 方法表集合方法表的结构如字段一样,包含了访问标识,名称索引,描述符索引几项. 属性表集合 Code 属性 当代码经过编译之后,最终字节码指令存储在 Code 属性内. Exceptions 属性 列举出方法可能抛出的受查异常 LineNumberTable 属性 描述 Java 源代码行号与字节码行号之间的关系. LocalVarableTable 属性 描述栈帧中局部变量表中的变量与 Java 源代码中定义的变量之间的关系. SourceFile 属性 记录生成这个 Class 文件的源码文件名称. ConstantValue 属性 通知虚拟机自动为静态变量赋值. InnerClasses 属性 记录内部类与宿主类之间的关联. Deprecated 及 Synthetic 属性 这两个属性都数据标志类型的布尔属性.Deprecated 用于表示某个类,字段或者方法被程序作者定位不再推荐使用.Synthetic 代表此字段或者方法并不是由 Java 源码产生的,而是由编辑器自行添加. StackMapTable 属性 一个复杂的变长属性,位于 Code 属性的属性表中.这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用,目的是代替以前比较消耗新能的基于数据流分析的类型推导验证器. Signature 属性 可以出现于类,属性表和方法表结构的属性表中,在 JDK1.5之后,任何类,接口,方法的泛型签名如果包含了类型变量或参数化类型,则 Signature 属性会记录泛型签名信息.因为 Java 语言的泛型采用擦除方法实现,在字节码中,泛型信息编译之后统统被擦除掉.使用擦除的原因是实现简单,运行期也能节省一些类型所占的内存空间,坏处是运行期无法像 C# 等有真泛型支持的语言那样,将泛型类型与用户定义的类型信息同等对待, Signature 就是为了弥补这个缺陷,如 Java 的反射 API 能够获取泛型类型,就是来源这个属性. 字节码指令简介由一个字节长度的,代表某种特定操作含义的数据以及后面的零到多个代表此操作所所需参数构成.由于Java 虚拟机面向操作数栈而不是寄存器及架构,所以大多数的指令都不包含操作数. 字节码与数据类型在 Java 虚拟机的指令集中,大多数的指令都包含了其操作所对应的数据类型信息.如: iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中. 加载与存储指令加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输.如:将一个局部变量加载到操作栈: iload将一个数值从操作数栈存储到局部变量表: istore 运算指令将两个操作数栈上的数据进行某种特定操作,并将结构重新存入操作栈顶. 类型转化指令对两个数值类型进行相互转换,一般用于实现用户代码中的显式类型转换操作. 操作数栈管理指令操作一个普通操作数据结构中的堆栈一样, Java 虚拟机提供了一些用于直接操作操作数栈的指令,包括: 将操作数栈的栈顶一个或者两个元素出栈: pop,pop2 将栈最顶端的两个数值互换: swap. 控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令而不是控制转移指令的下一条指令继续执行程序. 公有设计和私有设计Java 虚拟机的实现运行在满足虚拟机规范的约束下对具体实现做出修改和优化.只要优化后的 Class 文件依然可以被正确读取,实现者可以选择任何方式去实现这些语义. Class 文件结构的发展自 Class 文件发布十多年以来, Class 文件的主体结构,字节码指令的语义和数量几乎没有改动,所有的改动都集中在 访问标识,属性表这些在设计上可扩展的数据结构中添加内容.Class 文件格式锁具备的平台中立,紧凑,稳定和可扩展的特点,是 Java 技术体系实现平台无关,语言无关两项特性的重要支柱.]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java中的组合和继承]]></title>
    <url>%2Fjicheng-and-zuhe%2F</url>
    <content type="text"><![CDATA[深入理解Java中的组合和继承前言由于感觉自己对Java基础知识有点遗忘，就找了一篇文章来巩固一下。 面向对象的复用技术复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。 作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。本文将重点介绍继承复用和组合复用。 继承继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种is-a关系。（图片来自网络，侵删。） 组合组合(Composition)体现的是整体与部分、拥有的关系，即has-a的关系。 组合与继承的区别和联系 在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；） 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法） 继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。） 组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。 优缺点对比 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 如何选择相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。 所以， 建议在同样可行的情况下，优先使用组合而不是继承。 因为组合更安全，更简单，更灵活，更高效。 注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。 转载自http://www.hollischuang.com/archives/1319]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm垃圾收集器与内存分配策略]]></title>
    <url>%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略垃圾回收算法引用计数算法：给对象添加一个引用计数器，每当有一个地方引用时就加1，当引用失效就减1。当引用为0时会被回收。 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路作为引用链，当一个对象没有任何引用链相联，则该对象不可达，即为可回收的对象。 GC-Roots包括： 虚拟机栈（栈帧中本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（一般为Native方法）引用的对象 标记-清除算法：首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象 不足之处： 标记和清除两个过程效率都不高 结束后会产生大量碎片 复制算法：把内存划分为大小相等的两块，每次使用其中一块，使用的那块发生GC时将存活的对象复制到另一块，每次只对一个半区进行回收。 不足：将内存缩小为原来的一半，浪费空间 标记-整理算法：标记过程与“标记-清除算法”相同，然后将对象碎片都向一边移动，合成一个整体 再谈引用强引用：普遍存在，即Object obj = new Object(); 只要强引用还在对象就不会被回收 软引用：描述一些有用但却非必需的对象，在发生内存溢出异常之前会被回收。 弱引用：描述非必需对象，比软引用弱一些，在发生GC之前会被回收。 虚引用：最弱的引用，对于对象的生存周期无影响，也无法通过虚引用来获得对象实例。只是在对象被回收时会收到通知。 垃圾收集器Serial收集器单线程收集器，在GC时需要STW，即“Stop The World”暂停其他所有工作线程。缺点显而易见，停顿长体验差。唯一的优点是没有多余的线程开销，最高的单线程收集效率，对于分配内存较小的桌面应用（Client）停顿一般控制在几十毫秒，这是一个很好的选择。 ParNew收集器Serial的多线程版本，是许多运行在server模式下jvm首选的新生代收集器，而且除了Serial只有ParNew能与CMS收集器配合工作 并行：多个处理器上多个任务 并发：一个处理器上多个任务 Parallel Scavenge收集器多线程使用复制算法的新生代收集器，关注点与CMS等收集器尽可能缩短停顿时间不同，其目标是达到一个可控制的吞吐量（吞吐量=运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）），称为吞吐量优先收集器。 Serial Old收集器Serial老年代版本，单线程收集器，使用“标记-整理算法”。 Parallel Old收集器Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。Parallel Scavenge + Parallel Old真正的吞吐量优先收集器。 CMS收集器基于“标记-清除”算法，过程分为四步： 初始标记 并发标记 重新标记 并发清除 其中初始标记和重新标记需要STW 缺点有三： 对CPU资源敏感，并发标记时用户线程没有暂停，收集器占用部分CPU资源，可能会使用户程序反应变慢 无法处理浮动垃圾，由于GC时用户线程还在进行，不停地会有新的垃圾产生，只能在下一次GC时处理，这部分垃圾叫做浮动垃圾 基于“标记-清除”算法，会产生大量空间碎片，导致无法找到足够大的连续空间分配而提前GC G1收集器运作步骤： 初始标记 并发标记 最终标记 筛选回收 特点： 并行与并发 分代收集（仍然保留了分代的概念） 空间整合（整体上属于“标记-整理”算法，不会导致空间碎片） 可预测的停顿（比CMS更先进的地方在于能让使用者明确指定时间片段内，消耗在垃圾收集上的时间） 内存分配策略对象优先在Eden（年轻代）分配 新生代GC（Mirror GC）：Java对象大部分都具备朝生夕灭的特性，Mirror GC非常频繁 老年代GC（Full GC）：出现Full GC常伴随着Mirror GC，比Mirror GC慢十倍以上 大对象直接进入老年代超过参数的对象直接在老年代分配 长期存活的对象将进入老年代虚拟机给每个对象定义一个对象年龄计数器，当对象在Eden出生并且熬过第一次GC进入Survivor空间，那么它的年龄即设为1，每熬过一次GC年龄就加1，达到阈值就会晋升到老年代中 对象年龄判断然而也并不是一定要到达阈值才能晋升，如果在Survivor空间相同年龄的对象的总和大于Survivor空间的一半，大于等于该年龄的对象即可直接进入老年代 空间分配担保Mirror GC之前虚拟机会检查老年代可用空间是否大于新生代所有对象大小总和，如果是，那么可以确保Mirror GC安全。如果不是的话，看是否允许担保失败（允许冒险），如果允许那么将检查老年代可用空间是否大于历次晋升对象大小的平均值，如果是的话将进行一次Mirror GC，尽管有风险会失败；如果小于那么将进行Full GC]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm之内存区域]]></title>
    <url>%2Fjvm-neicun%2F</url>
    <content type="text"><![CDATA[Java内存区域划分： 程序计数器：线程私有。当前所执行线程的行号指示器 虚拟机栈：线程私有。方法执行的同时创建一个栈帧，用于存储局部变量表（包括基本数据类型、对象引用）、操作数栈、动态链接、方法出口等。每一个方法从调用执行直到结束的过程就对应一个栈帧入栈到出栈的过程。 本地方法栈：线程私有。与虚拟机栈（为Java方法即字节码服务）类似，而本地方法栈为Native方法服务，即非Java方法（如C方法）。有些虚拟机（如HotSpot）会将虚拟机栈和本地方法栈合二为一。 堆区：所有线程共享。对象实例分配内存的地方 方法区（非堆）：所有线程共享。存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据 运行时常量池：是方法区的一部分，用于存放编译期产生的各种字面量（类似于常量）和符号引用。 内存泄漏与内存溢出 内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即被分配的对象引用链可达但已无用。（可用内存减少） 内存溢出：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 内存泄露是内存溢出的一种诱因，不是唯一因素。 对象创建的堆内存分配方式 指针碰撞：内存规整无碎片时，直接划分堆尾部内存给对象。 空闲列表：有碎片时，维护一个列表记录哪些内存可用，并分配足够大的内存给对象。 对象的内存布局对象的内存布局包括： 对象头：储存对象自身运行时数据，如哈希码、GC分代年龄、线程持有锁等 实例数据：对象真正储存的有效信息 对齐填充：由于对象大小必须是8的整数倍，对象头正好是8的整数倍，如果实例数据部分没有对齐，则需要对齐成8的倍数 对象的访问定位 通过句柄访问：使用句柄访问方式，java堆将会划分出来一部分内存去来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中则包含对象实例数据的地址和对象类型数据（如对象的类型，实现的接口、方法、父类、field等）的具体地址信息。 通过直接指针访问： 如果使用指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型的相关信息（如对象的类型，实现的接口、方法、父类、field等），而reference中存储的就是对象的地址 这两种访问方式各有利弊，使用句柄访最大的好处是reference中存储着稳定的句柄地址，当对象移动之后（垃圾收集时移动对象是非常普遍的行为），只需要改变句柄中的对象实例地址即可，reference不用修改。 使用指针访问的好处是访问速度快，它减少了一次指针定位的时间开销，由于java是面向对象的语言，在开发中java对象的访问非常的频繁，因此这类开销积少成多也是非常可观的，反之则提升访问速度。对于HotSpot虚拟机来说，使用的就是直接指针访问的方式。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射的理解]]></title>
    <url>%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[首先，从动态语言讲起。像Python、Ruby这种语言，只要修改了代码，修改的效果立即生效，因为这种语言是无需编译，直接执行代码的，我们称这类语言是“动态语言”。而C++、Java这种，在运行之前需要先编译，如果中途修改了代码不重新编译去执行的话就没有变化。但是，Java有一个非常突出的动态相关机制，即反射：我们可以于运行时（区别于编译时）加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class（在这之前修改这个类即时不编译都有效），获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。 再通俗地说一下什么是反射？ 普通的Java对象是通过new关键字把对应类的字节码文件加载到内存，然后创建该对象的。 反射是通过一个名为Class的特殊类，用Class.forName(“类名”);得到类的字节码对象，然后用newInstance()方法在虚拟机内部构造这个对象（针对无参构造函数）。 也就是说反射机制让我们可以在程序运行时动态地拿到Java类对应的字节码对象（而不是在编译的时候），然后动态的进行任何可能的操作。反射的功能主要包括： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法（这样就可以修改这个对象的属性） 生成动态代理 使用反射的主要作用是方便程序的扩展，由于其运行时动态加载的特性。 Class类Java中只有2种东西不是面向对象的，一个基本类型，一个静态成员（方法、变量、常量）。我们提供的每一个类也是对象，一个类的类类型是java.lang.Class类的实例对象。 123456789101112131415161718192021// 创建类Foo的实例对象Foo foo1 = new Foo();// Foo这个类也是一个实例对象，Class类的实例对象// 任何一个类都是Class的实例对象，这个实例对象有三种表达方式// 第一种表达方式。实际上表明任何一个类都有一个隐含的静态成员变量ClassClass c1 = Foo.class;// 第二种表达方式Class c2 = foo1.getClass();// 根据官网说法，c1,c2表示了Foo类的类类型(class type)// 类也是对象，是Class类的实例对象，这个对象我们成为该类的类类型System.out.println(c1==c2) // true // 第三种表达方式Class c3 = Class.forName(&quot;Foo&quot;); System.out.println(c1==c3) // true Class类的构造器是私有的，只能JVM能创建Class类的实例对象。 可以通过类类型 (上面的c1 c2 c3)创建Foo类的实例对象： 1Foo foo = (Foo)c1.newInstance(); 动态加载类什么是动态加载？什么是静态加载？ 静态加载的类在编译的时候就要提供，而动态加载的类在源程序编译时可以缺席。区分编译时和运行时。 Class.forName(“类名”) 这种方式，不仅表示了类的类类型，还代表了动态加载类。 用new这种方式静态加载方式，编译的时候，如果new的对象的那个类不存在的话，编译不通过；但是用Class.forName这种动态加载方式，没有这个类编译的时候不会报任何错，但是运行的时候会因为找不到这个类而报错。动态加载有什么好处呢？配合接口编程，可以实现一个接口对多种实现，从而可以动态地去选择完成不同的功能。因此，类动态加载对扩展功能很有用。 其实，动态类加载主要就是通过反射机制将类对象注入进去。 静态加载： 12345678910111213public class Office_Static &#123; public static void main(String[] args) &#123; //new 创建对象，是静态加载类，在编译时刻就需要用到Word和Excel，并将其编译 if(&quot;Word&quot;.equals(args[0]))&#123; Word w = new Word(); w.start(); &#125; if(&quot;Excel&quot;.equals(args[0]))&#123; Excel e = new Excel(); e.start(); &#125; &#125; &#125; 动态加载： 123public interface OfficeAble &#123; public void start(); &#125; 12345public class Word implements OfficeAble &#123; public void start()&#123; System.out.println(&quot;word start&quot;); &#125; &#125; 12345public class Excel implements OfficeAble &#123; public void start()&#123; System.out.println(&quot;excel start&quot;); &#125; &#125; 1234567891011121314public class OfficeBetter &#123; public static void main(String[] args) &#123; try &#123; //动态加载类，在运行时刻才要用这个类 Class c = Class.forName(args[0]);//在运行配置里面输入com.imooc.加载类.Excel //通过类类型，创建该类对象(先转换为Word和Excel的共同接口OfficeAble) OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通过反射动态获取对象的方法属性构造器信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.lang.reflect.Method;import java.lang.reflect.Field;import java.lang.reflect.Constructor;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * * @param obj * 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj) &#123; // 要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();// 传递的是哪个子类的对象 c就是该子类的类类型 // 获取类的名称 System.out.println(&quot;类的名称是:&quot; + c.getName()); /* * Method类，方法对象 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();// c.getDeclaredMethods() for (int i = 0; i &lt; ms.length; i++) &#123; // 得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName() + &quot; &quot;); // 得到方法的名称 System.out.print(ms[i].getName() + &quot;(&quot;); // 获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125; /** * 获取成员变量的信息 * * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 java.lang.reflect.Field Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ // Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; // 得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); // 得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName + &quot; &quot; + fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * * @param obj */ public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* * 构造函数也是对象 java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 getDeclaredConstructors得到所有的构造函数 */ // Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName() + &quot;(&quot;); // 获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125;&#125; 通过反射运行时动态调用对象的方法用方法对象进行反射操作，运行时动态调用一个对象的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; // 要获取print(int ,int )方法 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型 A a1 = new A(); Class c = a1.getClass(); /* * 2.获取方法 名称和参数列表来决定 getMethod获取的是public的方法 getDelcaredMethod自己声明的方法 */ try &#123; // Method m = c.getMethod(&quot;print&quot;, new // Class[]&#123;int.class,int.class&#125;); Method m = c.getMethod(&quot;print&quot;, int.class, int.class); // 方法的反射操作 // a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同 // 方法如果没有返回值返回null,有返回值返回具体的返回值 // Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); Object o = m.invoke(a1, 10, 20); System.out.println(&quot;==================&quot;); // 获取方法print(String,String) Method m1 = c.getMethod(&quot;print&quot;, String.class, String.class); // 用方法进行反射操作 // a1.print(&quot;hello&quot;, &quot;WORLD&quot;); o = m1.invoke(a1, &quot;hello&quot;, &quot;WORLD&quot;); System.out.println(&quot;===================&quot;); // Method m2 = c.getMethod(&quot;print&quot;, new Class[]&#123;&#125;); Method m2 = c.getMethod(&quot;print&quot;); // m2.invoke(a1, new Object[]&#123;&#125;); m2.invoke(a1); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class A &#123; public void print() &#123; System.out.println(&quot;helloworld&quot;); &#125; public void print(int a, int b) &#123; System.out.println(a + b); &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + &quot;,&quot; + b.toLowerCase()); &#125;&#125; 通过反射了解Java泛型的本质反射的操作都是编译之后的操作，反射动态加载的类是在程序运行时编译并加载的。来看看下面这个例子。 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo2&#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(&quot;hello&quot;); //list1.add(20);错误的 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2);// 都是ArrayList的类类型，true //反射的操作都是编译之后的操作 /* * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效， * 绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try &#123; Method m = c2.getMethod(&quot;add&quot;, Object.class); m.invoke(list1, 20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) &#123; System.out.println(string); &#125;*///现在不能这样遍历 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 转载自：http://lioncruise.github.io/2016/11/29/java-reflection/]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的弱引用]]></title>
    <url>%2Fjava-reference-1%2F</url>
    <content type="text"><![CDATA[强引用(Strong Reference)强引用就是我们经常使用的引用，其写法如下 StringBuffer buffer = new StringBuffer(); 上面创建了一个StringBuffer对象，并将这个对象的（强）引用存到变量buffer中。是的，就是这个小儿科的操作（请原谅我这样的说法）。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达(Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的。 但是强引用如此之强在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然这个完全可以通过类标记成final实现。或者也可以更加复杂一些，就是通过内部包含了未知数量具体实现的工厂方法返回一个接口(Interface)。举个例子，我们想要使用一个叫做Widget的类，但是这个类不能被继承，所以无法增加新的功能。 但是我们如果想追踪Widget对象的额外信息，我们该怎么办？ 假设我们需要记录每个对象的序列号，但是由于Widget类并不包含这个属性，而且也不能扩展导致我们也不能增加这个属性。其实一点问题也没有，HashMap完全可以解决上述的问题。 serialNumberMap.put(widget, widgetSerialNumber); 这表面看上去没有问题，但是widget对象的强引用很有可能会引发问题。我们可以确信当一个widget序列号不需要时，我们应该将这个条目从map中移除。如果我们没有移除的话，可能会导致内存泄露，亦或者我们手动移除时删除了我们正在使用的widgets，会导致有效数据的丢失。其实这些问题很类似，这就是没有垃圾回收机制的语言管理内存时常遇到的问题。但是我们不用去担心这个问题，因为我们使用的时具有垃圾回收机制的Java语言。 另一个强引用可能带来的问题就是缓存,尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是做图片数据缓存，因为从磁盘加载图片代价很大，并且同时我们也想避免在内存中同时存在两份一样的图片数据。 缓存被设计的目的就是避免我们去再次加载哪些不需要的文件。你会很快发现在缓存中会一直包含一个到已经指向内存中图片数据的引用。使用强引用会强制图片数据留在内存，这就需要你来决定什么时候图片数据不需要并且手动从缓存中移除，进而可以让垃圾回收器回收。因此你再一次被强制做垃圾回收器该做的工作，并且人为决定是该清理到哪一个对象。 弱引用(Weak Reference)弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。创建弱引用如下 WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget); 使用weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现（当没有任何强引用到widget对象时）使用get时突然返回null。 解决上述的widget序列数记录的问题，最简单的办法就是使用Java内置的WeakHashMap类。WeakHashMap和HashMap几乎一样，唯一的区别就是它的键（不是值!!!）使用WeakReference引用。当WeakHashMap的键标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的Widget对象手动删除的问题。使用WeakHashMap可以很便捷地转为HashMap或者Map。 引用队列(Reference Queue)一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。 引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。 四种引用Java中实际上有四种强度不同的引用，从强到弱它们分别是，强引用，软引用，弱引用和虚引用。上面部分介绍了强引用和弱引用，下面介绍剩下的两个，软引用和虚引用。 软引用（Soft Reference）软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象。 由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。 虚引用 （Phantom Reference）与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。 当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。 虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。 第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。 使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。 显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式自我总结-1]]></title>
    <url>%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[看了一部分设计模式，自己都用一句话总结了下： 单例模式Singleton类内定义私有的构造方法，并实例化一个静态的Singleton对象（全局只有一个），于是外部只能调用你封装的getSingleton方法取得Singleton实例 工厂模式是设置一个过渡端（即工厂类）用以取得接口对应的子类类型并实例化，然后回传接口的引用到客户端（调用处，如主方法） 代理模式就是将真实类作为属性注入到代理类，然后先调用代理类的其他业务操作再调用真实类的业务 适配器模式主要用于子类只需要实现接口的一部分方法，此时设定一个适配器抽象类实现若干或者所有抽象方法（方法体为空即可）来过渡，然后子类有选择的实现一部分适配器类的方法即可]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring四种依赖注入方式]]></title>
    <url>%2Fspring-1%2F</url>
    <content type="text"><![CDATA[spring四种依赖注入方式​ ​ 平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。 ​ spring有多种依赖注入的形式，下面仅介绍spring通过xml进行IOC配置的方式： set方法注入​ 这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）： 12345678910111213package com.bless.springdemo.action;public class SpringAction &#123; //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125;&#125; ​ 随后编写spring的xml文件，中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在标签中创建一个标签指定SpringDao。标签中的name就是SpringAction类中的SpringDao属性名，ref指下面，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入： 1234567&lt;!--配置bean,配置后该类由spring管理--&gt;&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; 构造器注入​ 这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来： 12345678910111213141516public class SpringAction &#123; //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println(&quot;构造方法调用springDao和user&quot;); &#125; public void save()&#123; user.setName(&quot;卡卡&quot;); springDao.save(user); &#125;&#125; 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt; ​ 解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理： ​ 下面是设置index，就是参数位置： 1234&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 另一种是设置参数类型： 1&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt; 静态工厂构造​ 静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取： 123456789101112package com.bless.springdemo.factory;import com.bless.springdemo.dao.FactoryDao;import com.bless.springdemo.dao.impl.FactoryDaoImpl;import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125; ​ 同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别: 123456789101112 public class SpringAction &#123; //注入对象 private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //注入对象的set方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125; ​ Spring的IOC配置文件，注意看指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=”getStaticFactoryDaoImpl”指定调用哪个工厂方法： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt; &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 实例工厂构造​ 实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法： 123456public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125; ​ 那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象： 123456789101112public class SpringAction &#123; //注入对象 private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125; 最后看spring配置文件 123456789&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 总结​ Spring IOC注入方式用得最多的是(1)(2)种，多写多练就会非常熟练。 ​ 另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在标签后面添加一个属性： 1&lt;bean name=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运行时多态性：继承和接口的实现]]></title>
    <url>%2Fduotai-1%2F</url>
    <content type="text"><![CDATA[先插一句题外话： 继承与多态的区别 ​ 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 ​ 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 进入正题： Java运行时多态性：继承和接口的实现Java是面向对象的语言，而运行时多态性是面向对象程序设计代码重用的一个最强大机制，动态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制，下面就继承和接口实现两方面谈谈java运行时多态性的实现。 一、通过继承中超类对象引用变量引用子类对象来实现举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940//定义超类superA class superA &#123; int i = 100; void fun() &#123; System.out.println(“This is superA”); &#125;&#125;//定义superA的子类subB class subB extends superA &#123; int m = 1; void fun() &#123; System.out.println(“This is subB”); &#125;&#125;//定义superA的子类subC class subC extends superA &#123; int n = 1; void fun() &#123; System.out.println(“This is subC”); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; superA a; subB b = new subB(); subC c = new subC(); a = b; a.fun(); (1) a = c; a.fun(); (2) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940 运行结果为： 123This is subBThis is subC123 上述代码中subB和subC是超类superA的子类，我们在类Test中声明了3个引用变量a, b, c，通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。也许有人会问：“为什么(1)和(2)不输出：This is superA”。java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 所以，不要被上例中(1)和(2)所迷惑，虽然写成a.fun()，但是由于(1)中的a被b赋值，指向了子类subB的一个实例，因而(1)所调用的fun()实际上是子类subB的成员方法fun()，它覆盖了超类superA的成员方法fun()；同样(2)调用的是子类subC的成员方法fun()。 另外，如果子类继承的超类是一个抽象类，虽然抽象类不能通过new操作符实例化，但是可以创建抽象类的对象引用指向子类对象，以实现运行时多态性。具体的实现方法同上例。 不过，抽象类的子类必须覆盖实现超类中的所有的抽象方法，否则子类必须被abstract修饰符修饰，当然也就不能被实例化了。 二、通过接口类型变量引用实现接口的类的对象来实现接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的引用变量来引用实现接口的类的实例，当这个引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和上述的超类对象引用访问子类对象的机制相似。 举例说明： 1234567891011121314151617181920212223242526272829303132//定义接口InterA interface InterA&#123; void fun();&#125;//实现接口InterA的类B class B implements InterA&#123; public void fun() &#123; System.out.println(“This is B”); &#125;&#125;//实现接口InterA的类C class C implements InterA&#123; public void fun() &#123; System.out.println(“This is C”); &#125;&#125;class Test&#123; public static void main(String[] args) &#123; InterA a; a= new B(); a.fun(); a = new C(); a.fun(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132 输出结果为： 123This is BThis is C123 上例中类B和类C是实现接口InterA的两个类，分别实现了接口的方法fun()，通过将类B和类C的实例赋给接口引用a而实现了方法在运行时的动态绑定，充分利用了“一个接口，多个方法”展示了Java的动态多态性。 需要注意的一点是：Java在利用接口变量调用其实现类的对象的方法时，该方法必须已经在接口中被声明，而且在接口的实现类中该实现方法的类型和参数必须与接口中所定义的精确匹配。 结束语：以上就是java运行时多态性的实现方法，大家在编程过程中可以灵活运用，但是在性能要求较高的代码中不提倡运用运行时多态，毕竟Java的运行时动态方法调用较之普通的方法调用的系统开销是比较大的。 Java静态方法不具有多态性详解动态绑定机制使得基类的引用能够指向正确的子类对象，从而使得面向基类编程成为可能。然而动态绑定在以下两种情况会失效。 1、基类方法是private或final修饰的 这个很好理解，因为private说明该方法对子类是不可见的，子类再写一个同名的方法并不是对父类方法进行复写(Override)，而是重新生成一个新的方法，也就不存在多态的问题了。同理也可以解释final，因为方法同样是不可覆盖的。 2、方法是static修饰的 代码如下所示. 123456789101112131415161718192021222324252627class Base &#123; public static void staticMethod() &#123; System.out.println(&quot;Base staticMehtod&quot;); &#125; public void dynamicMehtod() &#123; System.out.println(&quot;Base dynamicMehtod&quot;); &#125;&#125;class Sub extends Base &#123; public static void staticMethod() &#123; System.out.println(&quot;Sub staticMehtod&quot;); &#125; public void dynamicMehtod() &#123; System.out.println(&quot;Sub dynamicMehtod&quot;); &#125;&#125;public class TJ4 &#123; public static void main(String args[]) &#123; Base c = new Sub(); c.staticMethod(); c.dynamicMehtod(); &#125;&#125;123456789101112131415161718192021222324252627 输出结果如下： 123 Base staticMehtod Sub dynamicMehtod123 输出结果并不像设想的那样，输出 “Sub staticMehtod”。因为静态方法是与类而不是与某个对象相关联，c.staticMethod();等同于Car.staticMethod(); 所以尽量不要使用实例变量去调用静态方法，避免混淆。 转载：http://blog.csdn.net/jdsjlzx/article/details/52518723]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程之使用目的]]></title>
    <url>%2Fthread-1%2F</url>
    <content type="text"><![CDATA[多线程使用的主要目的在于： 吞吐量：你做WEB，容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。如果是单线程，那同时只能处理一个用户的请求。 伸缩性：也就是说，你可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，肯定没办法通过增加CPU核数来提升性能。 鉴于做WEB的第1点可能几乎不涉及。那这里就讲第二点吧。 –举个简单的例子：假设有个请求，这个请求服务端的处理需要执行3个很缓慢的IO操作（比如数据库查询或文件查询），那么正常的顺序可能是（括号里面代表执行时间）：a、读取文件1 （10ms）b、处理1的数据（1ms）c、读取文件2 （10ms）d、处理2的数据（1ms）e、读取文件3 （10ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。那如果你在这个请求内，把ab、cd、ef分别分给3个线程去做，就只需要12ms了。 所以多线程不是没怎么用，而是，你平常要善于发现一些可优化的点。然后评估方案是否应该使用。假设还是上面那个相同的问题：但是每个步骤的执行时间不一样了。a、读取文件1 （1ms）b、处理1的数据（1ms）c、读取文件2 （1ms）d、处理2的数据（1ms）e、读取文件3 （28ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。如果还是按上面的划分方案（上面方案和木桶原理一样，耗时取决于最慢的那个线程的执行速度），在这个例子中是第三个线程，执行29ms。那么最后这个请求耗时是30ms。比起不用单线程，就节省了4ms。但是有可能线程调度切换也要花费个1、2ms。因此，这个方案显得优势就不明显了，还带来程序复杂度提升。不太值得。 那么现在优化的点，就不是第一个例子那样的任务分割多线程完成。而是优化文件3的读取速度。可能是采用缓存和减少一些重复读取。首先，假设有一种情况，所有用户都请求这个请求，那其实相当于所有用户都需要读取文件3。那你想想，100个人进行了这个请求，相当于你花在读取这个文件上的时间就是28×100=2800ms了。那么，如果你把文件缓存起来，那只要第一个用户的请求读取了，第二个用户不需要读取了，从内存取是很快速的，可能1ms都不到。 1234567891011public class MyServlet extends Servlet&#123; private static Map&lt;String, String&gt; fileName2Data = new HashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 看起来好像还不错，建立一个文件名和文件数据的映射。如果读取一个map中已经存在的数据，那么就不不用读取文件了。可是问题在于，Servlet是并发，上面会导致一个很严重的问题，死循环。因为，HashMap在并发修改的时候，可能是导致循环链表的构成！！！（具体你可以自行阅读HashMap源码）如果你没接触过多线程，可能到时候发现服务器没请求也巨卡，也不知道什么情况！好的，那就用ConcurrentHashMap，正如他的名字一样，他是一个线程安全的HashMap，这样能轻松解决问题。 1234567891011public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 这样真的解决问题了吗，这样虽然只要有用户访问过文件a，那另一个用户想访问文件a，也会从fileName2Data中拿数据，然后也不会引起死循环。 可是，如果你觉得这样就已经完了，那你把多线程也想的太简单了，骚年！你会发现，1000个用户首次访问同一个文件的时候，居然读取了1000次文件（这是最极端的，可能只有几百）。What the fuckin hell!!! 难道代码错了吗，难道我就这样过我的一生！ 好好分析下。Servlet是多线程的，那么 123456789101112public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 上面注释的“偶然”，这是完全有可能的，因此，这样做还是有问题。 因此，可以自己简单的封装一个任务来处理。 1234567891011121314151617181920212223242526272829public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, FutureTask&gt; fileName2Data = new ConcurrentHashMap&lt;String, FutureTask&gt;(); private static ExecutorService exec = Executors.newCacheThreadPool(); private void processFile3(String fName)&#123; FutureTask data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = newFutureTask(fName); FutureTask old = fileName2Data.putIfAbsent(fName, data); if(old==null)&#123; data = old; &#125;else&#123; exec.execute(data); &#125; &#125; String d = data.get(); //process with data &#125; private FutureTask newFutureTask(final String file)&#123; return new FutureTask(new Callable&lt;String&gt;()&#123; public String call()&#123; return readFromFile(file); &#125; private String readFromFile(String file)&#123;return &quot;&quot;;&#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>muti-thread</category>
      </categories>
      <tags>
        <tag>muti-thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下安装jdk详细步骤（共两种方法）]]></title>
    <url>%2Faliyun-jdk%2F</url>
    <content type="text"><![CDATA[配置阿里云服务器时遇到一些版本问题，需要重装jdk，以下是从网上搜索的方案，我用的是第一种。 第一种方法只需要一条命令就可以安装jdk： yum install java-1.8.0-openjdk* -y 执行过这条命令无需配置，直接可以使用。 第二种方法1. 登录Linux，切换到root用户su root 获取root用户权限，当前工作目录不变(需要root密码)或sudo -i 不需要root密码直接切换成root（需要当前用户密码） 2. 在usr目录下建立java安装目录cd /usr //进入usr目录 mkdir java //创建java目录 3. 将jdk-8u60-linux-x64.tar.gz拷贝到java目录下cp /mnt/hgfs/linux/jdk-8u60-linux-x64.tar.gz /usr/java/ 4. 解压jdk到当前目录tar -zxvf jdk-8u60-linux-x64.tar.gz 得到文件夹 jdk1.8.0_60 5. 安装完毕为他建立一个链接以节省目录长度ln -s /usr/java/jdk1.8.0_60/ /usr/jdk 6. 编辑配置文件，配置环境变量vim /etc/profile 添加如下内容：JAVA_HOME根据实际目录来 123export JAVA_HOME=/usr/java/jdk1.8.0_60export CLASSPATH=JAVAHOME/lib/exportPATH=PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 7. 重启机器或执行命令 ：source /etc/profilesudo shutdown -r now 8. 查看安装情况1234[root@bogon jdk]# java -versionopenjdk version “1.8.0_141”OpenJDK Runtime Environment (build 1.8.0_141-b16)OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode) 12[root@bogon jdk]# javac -versionjavac 1.8.0_141 可能出现的错误信息：1bash: ./java: cannot execute binary file 出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，查看jdk版本和Linux版本位数是否一致。查看你安装的Ubuntu是32位还是64位系统： 1sudo uname –m i686 //表示是32位x86_64 // 表示是64位]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器同步MySQL数据库]]></title>
    <url>%2Fmysql-question-3%2F</url>
    <content type="text"><![CDATA[将本地文件拷贝到远程服务上的指定目录命令scp基于SSH协议，可以将本地文件拷贝到远程服务上的指定目录，格式如下： 1scp filename username@remotehost:remotedirectory 数据库创建时，无法使用“-”等特殊字符在使用mysql命令进行数据库创建时，发现“-”等特殊字符无法使用，提示sql语句语法错误。 1mysql&gt;create database tw-travel; 解决方案：数据库名加上 `` 1mysql&gt;create database `tw-travel`; Linux系统下通过命令行对mysql数据库进行备份和还原备份： 进入MySQL目录 备份 1mysqldump -u root -p密码 数据库名 数据表名 &gt; mysql.sql 还原： 建立你要还原的数据库并use database 导入sql文件 1source mysql.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改善Mac系统MySQL配置环境变量]]></title>
    <url>%2Fmysql-question-2%2F</url>
    <content type="text"><![CDATA[本地MySQL：改善Mac系统MySQL配置环境变量1.首先修改.bash_profile 文件sudo vim .bash_profile 2.加上一行配置PATH，并保存export PATH=${PATH}:/usr/local/mysql/bin3.终端输入此命令使PATH生效source .bash_profile4.此时即可用mysql -u root -p 进入MySQL，但是有一个问题就是当你重启终端时会发现又无法用该命令了，原因是当你重启时此时PATH下没有mysql，难道每次关掉终端在打开都需要重新source .bash_profile 解决方案1.终端编辑~/.zshc 文件vim ~/.zshrc 2.添加并保存export PATH=${PATH}:/usr/local/mysql/bin 3.终端source ~/.zshc 4.一劳永逸~ 附：有的文章中提到修改~/.bashrc，如果系统是zsh的修改bashrc是无效的]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL解决中文乱码之全套方案]]></title>
    <url>%2FWebEncoding%2F</url>
    <content type="text"><![CDATA[今天遇到一堆MySQL 中文乱码的问题 ，总体来说分为数据库层面，Tomcat层面，web表示层面。 数据库层面先是MySQL数据库中文乱码问题，大概样子如下： 然后自我感觉这件事情不就是改下字段的编码吗，那就改一下呗如图，我更改了Encoding 然后发现事情并没有那简单，于是开始上网查解决方案，网上说需要修改/etc/my.cnf(此配置文件对于mac后缀是.cnf，对于Windows是.ini)。所以漫漫找寻之路开始了，最后连Linux查询find语句也试了就是找不到，终于在几篇文章里查到Mac上的MySQL没有my.cnf配置文件，好吧，继续寻找解决方案，有人说MySQL下的support-file中找一个.cnf复制一下再改；里面的东西，然而我连.cnf文件都没有找到。最后采用一位网友的办法，直接在/etc目录下 vim my.cnf新建一个文件，在此附上我修改过的文件里面内容，在[mysqld] 之后增加了一行 collation-server = utf8_general_ci 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 default-storage-engine = INNODB collation-server = utf8_general_ci init_connect=&apos;SET NAMES utf8&apos; port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos;# Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement,# if all processes that need to connect to mysqld run on the same host.# All interaction with mysqld must be made via Unix sockets or named pipes.# Note that using this option without enabling named pipes on Windows# (via the &quot;enable-named-pipe&quot; option) will render mysqld useless!##skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout 此时保存文件，再修改文件读写权限，将权限修改为664 1sudo chmod 664 /etc/my.cnf 之后再重启MySQL和配置文件就可以生效了。然后完成之后，确实，如果你查一下MySQL的各种编码，确实都变成了UTF-8通过以下命令 然而~输入不了中文了，报错 最后将当前数据库以及所有表所有字段都设置为UTF-8 惊喜的发现可以愉快的输入中文了~~至此，数据库层面告一段落 Tomcat层面接下来我说的简略一些，如果URL请求采取GET方法，那么你的URL中可能会出现中文，所以需要在Tomcat配置文件里面设置编码方式。 修改Tomcat下的conf/server.xml文件，找到如下代码： 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 这段代码规定了Tomcat监听HTTP请求的端口号等信息。可以在这里添加一个属性：URIEncoding，将该属性值设置为UTF-8，即可让Tomcat（默认ISO-8859-1编码）以UTF-8的编码处理get请求。更改后的代码如下所示： 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; URIEncoding=&quot;UTF-8&quot; redirectPort=&quot;8443&quot; /&gt; Web显示层面这里主要针对请求为POST方法的时候，你需要设置web.xml 文件，设置字符串过滤器 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 最后如果你要回显到页面上打印中文的话需要设置一下response如果你使用springMVC可以设置 1@RequestMapping(value = &quot;/XX.do&quot;, produces=&quot;text/html;charset=UTF-8&quot;)]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之order]]></title>
    <url>%2Fmysql-question-1%2F</url>
    <content type="text"><![CDATA[刚测试查询订单controller时候遇到这个问题，sql语句莫名其妙的出错了 命令行实验一下操作Mysql的时候尴尬地遇到了一个问题，试了试其他表都好的，就是怎么都查询不了order表。 后来试了试改成orders表就好了，后来一想order是MySQL的一个关键字啊~ order by]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ssm框架——Mybatis版本问题解决方案（一）]]></title>
    <url>%2Fssm1%2F</url>
    <content type="text"><![CDATA[前几天搭建了ssm框架准备开发后端，今天写mapper时遇到个棘手的问题-写select语句时发现入参报错总是提示找不到username，而且错误信息里面有四个参数，而我的入参只有两个，贴出源代码和错误信息。123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; Mybatis参数问题 然后经过一番折腾在网上找到解决方案，将变量改成参数形式0，1或者加上jdbcType，代码如下 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;0&#125; and password = #&#123;1&#125; &lt;/select&gt; And 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;username, jdbcType=VARCHAR&#125; and password = #&#123;password, jdbcType=VARCHAR&#125; &lt;/select&gt; 报错同上。 此时就很难受了，看源码debug。。。偶然间查到了可能是版本问题，然后尝试了以下解决方案搞定 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; 最后贴上码云项目地址]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习]]></title>
    <url>%2Fdeeplearning%2F</url>
    <content type="text"><![CDATA[随便翻一翻在wikipedia搜索时发现这个顿时慌张起来，截图留念。这DeepLearning要学的真不是一点两点，数学没学好真的伤。]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[这才是爱情最好的样子（转载）]]></title>
    <url>%2Fhunying%2F</url>
    <content type="text"><![CDATA[和女儿一起在书店打发时间，她看书看得入迷，我在边上的小咖啡吧写稿子。天气太热，咖啡吧里人不多，有两个女士在一旁闲聊。 其中一个问：“怎么你的黑眼圈看着又大了一点啊？” 答：“这有什么办法，我老公出差了，听不到他的呼噜声我反而睡不着了。” “噗呲……”边上的那个人忍不住乐了，在边上听着的我也有点忍俊不禁。 “你不知道，我老公只要一感冒了，就会连带着他的鼻炎更严重，半夜呼噜声特别大，那个声音就是在隔壁房里睡都清晰得不得了。 但是他的呼噜声有点吓人，一声大的“呼……”上去，半天你没听到接下来的那声响动，你的心思就会随着他的声音七上八下的，担心他是不是睡厥过去了。” 这个说话的女人越说越大声：“哎呀，你都不知道，他还有呼吸骤停的毛病，医生说了最好要侧卧，不能仰卧，他那呼噜声一停，往往就是仰面朝上的睡势，我得赶紧把他推醒，叫他侧着睡。” “那这样你肯定睡不好的呀，难怪你的黑眼圈天天都那么大。” “是啊，但结婚这么多年了，你说怪不怪，他要出差不在家的时候，听不到他的呼噜声我反而更睡不着了。” 在感情的世界里兜兜转转的人大概都知道的一个定理是，这世上最牢固的感情不是“我爱你”，而是“我习惯了有你”。 世间的夫妻都大同小异，一口锅里吃饭，一张床上睡觉，周而复始的生活让原本毫不相干的人亲密地生活在一起。时间久了，居然连原本恼人的呼噜声都成了婚姻里必不可少让人心定的安全感。 我想，在生活的烟熏火燎里仍然不离不弃的两个人应该就是爱情最好的样子。 这个世上并没有什么教科书似的完美爱情，有这么一对夫妻： 他向她求婚时，只说了三个字：相信我； 她为他生下第一个女儿的时候，他对她说：辛苦了； 女儿出嫁异地那天，他搂着她的肩说：还有我； 他收到她病危通知的那天，重复地对她说：我在这； 她要走的那一刻，他亲吻她的额头轻声说：你等我。 这一生，他没对她说过一次“我爱你”，但爱，从未离开过。 从没有多余的言语，也不是甜言蜜语制造的恩爱假象。只是平凡的生活中每个细节和眼神里透露出的体贴、关心。 我想，平淡而踏实地携手走完一生的两个人应该就是好的爱情该有的样子。 他是个搞设计的工程师，她是中学毕业班的班任老师，两人都错过了恋爱的最佳季节，后来经人介绍而相识。 没有惊天动地的过程，平平淡淡地相处，自自然然地结婚。 婚后第三天，他就跑到单位加班，为了赶设计，他甚至可以彻夜拼命，连续几天几夜不回家。她忙于毕业班的管理，经常晚归。 为了各自的事业，他们就像两个陀螺，在各自的轨道上高速旋转着。 送走了毕业班，清闲了的她开始重新审视自己的生活，审视自己的婚姻，她开始迷茫，不知道自己在他心里有多重，她似乎不记得他说过爱她。 一天，她问他是不是爱她，他说当然爱，不然怎么会结婚，她问他怎么不说爱，他说不知道怎么说。 她拿出写好的离婚协议，他愣了，说，那我们去旅游吧，结婚的蜜月我都没陪你，我亏欠你太多。 他们去了奇峰异石的张家界。飘雨的天气和他们阴郁的心情一样，走在盘旋的山道上，她发现他总是走在外侧，她问他为什么，他说路太滑，他怕外侧的栅栏不牢，怕她万一不小心跌倒。 她的心忽然感到了温暖，回家就把那份离婚协议撕掉了。 很多时候，爱是埋在心底的，尤其是婚姻进行中的爱，平平淡淡，说不出来，但是真实存在。 最好的爱情是陪伴，最靠谱的感觉是温暖，我想，这应该也是爱情最好的样子。 1942年底，杨绛创作了话剧《称心如意》。在金都大戏院上演后，一鸣惊人，迅速走红。杨绛的蹿红，使大才子钱钟书坐不住了。 一天，他对杨绛说：“我想写一部长篇小说，你支持吗？”杨绛大为高兴，催他赶紧写。 杨绛让他减少授课时间，为了节省开支，她还把家里的女佣辞退了，自己包揽了所有的家务活，劈材生火做饭样样都来，经常被烟火熏得满眼是泪，也会不小心切破手指。 可是杨绛并未抱怨过，她心甘情愿地做灶下婢，只盼着钟书的大作早日问世。 看着昔日娇生惯养的富家小姐，如今修炼成任劳任怨的贤内助，钱钟书心里虽有惭愧，但更多的是对爱妻的感激与珍爱。 两年后，《围城》成功问世。钱钟书在《围城》序中说：“这本书整整写了两年。两年里忧世伤生，屡想中止。由于杨绛女士不断的督促，替我挡了许多事，省出时间来，得以锱铢积累地写完。照例这本书该献给她。” 最深的爱无需诺言，总是相依相伴中把体贴展现；最纯的情无需语言，总是默默无声里守候身边。人生的路上风雨兼程，劳碌的生活嘘寒问暖。 婚后有一回，当杨绛在看英国传记作家描述最理想的婚姻：“在见到她之前，我从来没有想过要结婚，娶了她几十年，从来没有后悔娶她，也没有想过要娶别的女人。” 当杨绛读到这里，觉得甚好，于是把它念给在一旁的钱钟书听，钱钟书听完说：“我和他一样。” 杨绛随即回答：“我也是。” 好的爱情，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。 我想，三观一致的两个人应该就是爱情里最好的样子。 张小娴说，爱情的样子就是每天跟自己喜欢的人一起，通电话，旅行，重复一个承诺和梦想，听他第二十八次提起童年往事，每年的同一天和他庆祝生日，每年的情人节、圣诞节、除夕，也和他共度。甚至连吵架也是重复的，为了一些琐事吵架，然后冷战，疯狂思念对方，最后和好。 作家十二说，爱情中最让人愉悦的样子就是“你高兴，我随意”。 那到底什么才是爱情最好的样子？ “先睡吧，明天再吵。” 听说转载要注明出处，所以]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bible of a man —— 《教父》]]></title>
    <url>%2Fjiaofu%2F</url>
    <content type="text"><![CDATA[Bible of a man 一个真正的男人必须要花出时间和家人在一起，不照顾家人的男人，根本算不上是个男人。 要学会小心，女人和小孩能够粗心大意，但男人不行]]></content>
      <categories>
        <category>films</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用shadowsocks和阿里云服务器搭建从国外到国内的vpn]]></title>
    <url>%2Fvpn%2F</url>
    <content type="text"><![CDATA[刚开始看完教程感觉，哇，好简单。然而配置服务端shadowsocks文件的时候出了点小问题 建议把 SS 的配置文件放置在当前用户主目录下的 ss 文件夹内，对于 root 用户而言，则是：/root/ss 目录。其余用户一般则是：/home/用户名 目录。 因为服务器预装centOS 7,然后发现自己找不到root目录，更别说ss，于是，Google大法好，然而并没有找到正解。暂时告一段落，择明日再战。 之后换了个思路，先往下看呗，忽然发现这一步 nohup ssserver -c /root/ss/ssserver.json -d start &amp; 惊觉路径没关系，之后换一个就好。随后就解决了。 感谢大佬教程的帮助]]></content>
      <categories>
        <category>vpn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psychology]]></title>
    <url>%2Fpsychology%2F</url>
    <content type="text"><![CDATA[以下是看有土鳖psychology相关内容记下的笔记(纯手打) 人会在无意识的情况下模仿自己喜欢的人的动作，因为这会让她更有安全感。 多巴胺即“想要”，是生存发展的动力。 人的脑子一次只能专注于一件事情。 一个人如果开心，会更想尝试新事物；反之，希望做熟悉的事。 女生左右脑连接比男生紧密的多，左脑控制语言，右脑控制情绪，女生善用语言来表达情绪，且女生在小时候分泌雌性激素大约两年，而男生小时候大约分泌雄性激素只有八个月，所以初中之前女生语言表达理解能力会比男生强得多。 人的大脑有N1到N5的区域，男生大脑N5区域更发达，与距离、方向相关，女生N4区域更发达，与颜色、地标相关，这就能解释男女对路线描述的差异性，同时解释了为什么女生的方向感较弱。 男生的血清素分泌比女生快52%，血清素是能让人心情愉悦的物质，这就是为什么夫妻吵架，妻子气的半死而丈夫却呼呼大睡了。 男生平均一天讲七千个字，而女生一天讲两万个字。 女生比男生对表情的变化的辨识度快千分之二十秒，女生更能够发现别人表情的变化。]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I'll always love you]]></title>
    <url>%2Falways%2F</url>
    <content type="text"><![CDATA[小爽子我爱你 by——小可可]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[create]]></title>
    <url>%2FpostName%2F</url>
    <content type="text"><![CDATA[create a blog using hexoToday,i have made this blog.And i will write essays or articles on it.]]></content>
  </entry>
</search>