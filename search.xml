<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1081. Rational Sum (20)]]></title>
    <url>%2FPAT-1081%2F</url>
    <content type="text"><![CDATA[1081. Rational Sum (20)Given N rational numbers in the form “numerator/denominator”, you are supposed to calculate their sum. Input Specification: Each input file contains one test case. Each case starts with a positive integer N (&lt;=100), followed in the next line N rational numbers “a1/b1 a2/b2 …” where all the numerators and denominators are in the range of “long int”. If there is a negative number, then the sign must appear in front of the numerator. Output Specification: For each test case, output the sum in the simplest form “integer numerator/denominator” where “integer” is the integer part of the sum, “numerator” &lt; “denominator”, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample Input 1: 1252/5 4/15 1/30 -2/60 8/3 Sample Output 1: 13 1/3 Sample Input 2: 1224/3 2/3 Sample Output 2: 12 Sample Input 3: 1231/3 -1/6 1/8 Sample Output 3: 17/24 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;struct fraction &#123; long long up,down;&#125;frac[101];/* 求最大公约数 */long long gcd(long long a,long long b) &#123; if (b==0) &#123; return a; &#125; else &#123; return gcd(b, a%b); &#125;&#125;/* 化简 */void simplify(long long &amp;up,long long &amp;down) &#123; if (down&lt;0) &#123; down=-down; up=-up; &#125; if (up==0) &#123; down=1; &#125; else &#123; long long d=gcd(abs(up), abs(down)); up/=d; down/=d; &#125;&#125;/* 分数相加 */void add(fraction a,fraction &amp;temp) &#123; long long up=a.up*temp.down+temp.up*a.down; long long down=a.down*temp.down; simplify(up, down); temp.up=up; temp.down=down;&#125;int main() &#123; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%lld/%lld",&amp;frac[i].up,&amp;frac[i].down); simplify(frac[i].up, frac[i].down); &#125; fraction temp; temp.up=0;temp.down=1; for (int i=0; i&lt;n; i++) &#123; add(frac[i], temp); &#125; if (temp.down==1) &#123; printf("%lld",temp.up/temp.down); &#125; else if (abs(temp.up)&gt;temp.down) &#123; printf("%lld %lld/%lld",temp.up/temp.down,abs(temp.up)%temp.down,temp.down); &#125; else &#123; printf("%lld/%lld",temp.up,temp.down); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1104. Sum of Number Segments (20)]]></title>
    <url>%2FPAT-1104%2F</url>
    <content type="text"><![CDATA[1104. Sum of Number Segments (20)Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence {0.1, 0.2, 0.3, 0.4}, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 105. The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification: For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input: 1240.1 0.2 0.3 0.4 Sample Output: 15.00 目前最短的代码。不清楚int*double与double*int有什么区别，sum+=m*(n-i+1)*i;这表达式里为啥m必须不能放最后.. 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n;double m,sum=0;int main() &#123; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; scanf("%lf",&amp;m); sum+=m*(n-i+1)*i; &#125; printf("%.2lf",sum); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1069. The Black Hole of Numbers (20)]]></title>
    <url>%2FPAT-1069%2F</url>
    <content type="text"><![CDATA[1069. The Black Hole of Numbers (20)For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 – the “black hole” of 4-digit numbers. This number is named Kaprekar Constant. For example, start from 6767, we’ll get: 7766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174… … Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole. Input Specification: Each input file contains one test case which gives a positive integer N in the range (0, 10000). Output Specification: If all the 4 digits of N are the same, print in one line the equation “N - N = 0000”. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input 1: 16767 Sample Output 1: 12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 Sample Input 2: 12222 Sample Output 2: 12222 - 2222 = 0000 一开始没考虑到a=6174的情况，不能用while而要用do…while… 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool cmp1(int a,int b) &#123; return a&gt;b;&#125;bool cmp2(int a,int b) &#123; return a&lt;b;&#125;int toNumber(int a[]) &#123; return a[0]*1000+a[1]*100+a[2]*10+a[3];&#125;void toArray(int a,int *b) &#123; for (int i=0; i&lt;4; i++) &#123; b[i]=a%10; a/=10; &#125;&#125;int a,x,y;int main() &#123; scanf("%d",&amp;a); int b[4]; do &#123; toArray(a, b); sort(b, b+4, cmp1); x=toNumber(b); sort(b, b+4, cmp2); y=toNumber(b); printf("%04d - %04d = %04d\n",x,y,x-y); a=x-y; &#125; while (a!=6174&amp;&amp;a!=0); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1101. Quick Sort (25)]]></title>
    <url>%2FPAT-1101%2F</url>
    <content type="text"><![CDATA[1101. Quick Sort (25)There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N = 5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; Hence in total there are 3 pivot candidates. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;= 105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces. Output Specification: For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input: 1251 3 2 4 5 Sample Output: 1231 4 5 不知道为啥这题当主元为零的时候要输出俩空格，难道是因为要假装第二行有输出？ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[100010],leftMax[100010];vector&lt;int&gt; b;int main() &#123; int n; cin&gt;&gt;n; scanf("%d",&amp;a[0]); for (int i=1; i&lt;n; i++) &#123; scanf("%d",&amp;a[i]); leftMax[i]=max(leftMax[i-1], a[i-1]); &#125; int rightMin=999999999; if (leftMax[n-1]&lt;=a[n-1]) &#123; b.push_back(a[n-1]); &#125; for (int i=n-2; i&gt;=0; i--) &#123; rightMin=min(rightMin, a[i+1]); if (leftMax[i]&lt;=a[i]&amp;&amp;a[i]&lt;=rightMin) &#123; b.push_back(a[i]); &#125; &#125; printf("%ld\n",b.size()); if (b.size()==0) &#123; return 0; &#125; sort(b.begin(), b.end()); for (long i=0; i&lt;b.size(); i++) &#123; printf("%d",b[i]); if (i!=b.size()-1) &#123; printf(" "); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1093. Count PAT's (25)]]></title>
    <url>%2FPAT-1093%2F</url>
    <content type="text"><![CDATA[1093. Count PAT’s (25)The string APPAPT contains two PAT‘s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters. Now given any string, you are supposed to tell the number of PAT‘s contained in the string. Input Specification: Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only P, A, or T. Output Specification: For each test case, print in one line the number of PAT‘s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input: 1APPAPT Sample Output: 12 每一个位置都保存前面有几个P后面有几个T。对于每一个A，将前面P的个数与后面Q的个数相乘，都加起来取模就得到个数了。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string str;int leftP[100001],rightT[100001];long long cnt=0;int main() &#123; getline(cin,str); for (int i=1; i&lt;str.size(); i++) &#123; if (str[i-1]=='P') &#123; leftP[i]=leftP[i-1]+1; &#125; else &#123; leftP[i]=leftP[i-1]; &#125; &#125; for (int i=str.size()-2; i&gt;=0; i--) &#123; if (str[i+1]=='T') &#123; rightT[i]=rightT[i+1]+1; &#125; else &#123; rightT[i]=rightT[i+1]; &#125; if (str[i]=='A') &#123; cnt=(cnt+rightT[i]*leftP[i])%1000000007; &#125; &#125; printf("%lld",cnt); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1029. Median (25)]]></title>
    <url>%2FPAT-1029%2F</url>
    <content type="text"><![CDATA[1029. Median (25)Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13. Given two increasing sequences of integers, you are asked to find their median. Input Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (&lt;=1000000) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int. Output For each test case you should output the median of the two given sequences in a line. Sample Input 124 11 12 13 145 9 10 15 16 17 Sample Output 113 试试没想到直接一个sort函数就搞定了😂 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long a[2000010];int main() &#123; int n,m; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%ld",&amp;a[i]); &#125; cin&gt;&gt;m; for (int i=n; i&lt;n+m; i++) &#123; scanf("%ld",&amp;a[i]); &#125; sort(a, a+m+n); printf("%ld",*(a+(m+n-1)/2)); return 0;&#125; 然后又写了一遍序列合并： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long a[1000010],b[1000010],c[2000010];int main() &#123; int n,m; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%ld",&amp;a[i]); &#125; cin&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; scanf("%ld",&amp;b[i]); &#125; int l1=0,l2=0,index=0; while (l1&lt;n&amp;&amp;l2&lt;m) &#123; if (a[l1]&lt;=b[l2]) &#123; c[index++]=a[l1++]; &#125; else &#123; c[index++]=b[l2++]; &#125; &#125; while (l1&lt;n) &#123; c[index++]=a[l1++]; &#125; while (l2&lt;m) &#123; c[index++]=b[l2++]; &#125; printf("%ld",*(c+(m+n-1)/2)); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089. Insert or Merge (25)]]></title>
    <url>%2FPAT-1089%2F</url>
    <content type="text"><![CDATA[1089. Insert or Merge (25)Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification: For each test case, print in the first line either “Insertion Sort” or “Merge Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1: 123103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0 Sample Output 1: 12Insertion Sort1 2 3 5 7 8 9 4 6 0 Sample Input 2: 123103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6 Sample Output 2: 12Merge Sort1 2 3 8 4 5 7 9 0 6 插排还是归并~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,init[101],mid[101];void insertSort(int a[], int pos) &#123; int temp=a[pos],i=pos; while (i&gt;0&amp;&amp;temp&lt;a[i-1]) &#123; a[i]=a[i-1]; i--; &#125; a[i]=temp;&#125;bool isSame(int a[], int b[]) &#123; for (int i=0; i&lt;n; i++) &#123; if (a[i]!=b[i]) &#123; return false; &#125; &#125; return true;&#125;void mergeSort(int a[]) &#123; int flag=0; for (int step=2; step&lt;=n; step*=2) &#123; for (int i=0; i&lt;n; i+=step) &#123; sort(a+i,min(a+i+step,a+n)); &#125; if (flag==1) &#123; for (int i=0; i&lt;n; i++) &#123; printf("%d",a[i]); if (i!=n-1) &#123; printf(" "); &#125; &#125; return; &#125; if (isSame(a, mid)) &#123; flag=1; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;init[i]); &#125; for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;mid[i]); &#125; int temp=0,i; for (i=0; i&lt;n; i++) &#123; if (mid[i]&lt;=mid[i+1]) &#123; continue; &#125; else &#123; temp=i+1; break; &#125; &#125; int flag=0; while (temp&lt;n) &#123; if (init[temp]==mid[temp]) &#123; temp++; continue; &#125; flag=1; break; &#125; if (flag==0) &#123; printf("Insertion Sort\n"); insertSort(mid,i+1); for (int i=0; i&lt;n; i++) &#123; printf("%d",mid[i]); if (i!=n-1) &#123; printf(" "); &#125; &#125; return 0; &#125; printf("Merge Sort\n"); mergeSort(init); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1048. Find Coins (25)]]></title>
    <url>%2FPAT-1048%2F</url>
    <content type="text"><![CDATA[1048. Find Coins (25)Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 105 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (&lt;=105, the total number of coins) and M(&lt;=103, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification: For each test case, print in one line the two face values V1 and V2 (separated by a space) such that V1 + V2 = M and V1 &lt;= V2. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output “No Solution” instead. Sample Input 1: 128 151 2 8 7 2 4 11 15 Sample Output 1: 14 11 Sample Input 2: 127 141 8 7 2 4 11 15 Sample Output 2: 1No Solution 自定义的方法全过： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,v1,v2;vector&lt;int&gt; coin;int binarySearch(int i) &#123; int left=i+1,right=n-1,mid; while (left&lt;right) &#123; mid=(left+right)/2; if (coin[mid]+coin[i]==m) &#123; return mid; &#125; else if (coin[mid]+coin[i]&gt;m) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return right;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; coin.resize(n); for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;coin[i]); &#125; sort(coin.begin(), coin.end()); for (int i=0; i&lt;n; i++) &#123; int j=binarySearch(i); if (coin[i]+coin[j]==m) &#123; printf("%d %d",coin[i],coin[j]); return 0; &#125; &#125; printf("No Solution"); return 0;&#125; upper_bound方法错一处： 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,v1,v2;vector&lt;int&gt; coin;int main() &#123; cin&gt;&gt;n&gt;&gt;m; coin.resize(n); for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;coin[i]); &#125; sort(coin.begin(), coin.end()); for (int i=0; i&lt;n; i++) &#123; vector&lt;int&gt;::iterator j=lower_bound(coin.begin()+i+1, coin.end(), m-coin[i]); if (coin[i]+*j==m&amp;&amp;j!=coin.begin()+i) &#123; printf("%d %d",coin[i],*j); return 0; &#125; &#125; printf("No Solution"); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1044. Shopping in Mars (25)]]></title>
    <url>%2FPAT-1044%2F</url>
    <content type="text"><![CDATA[1044. Shopping in Mars (25)Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: \1. Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).\2. Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).\3. Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15). Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification: Each input file contains one test case. For each case, the first line contains 2 numbers: N (&lt;=105), the total number of diamonds on the chain, and M (&lt;=108), the amount that the customer has to pay. Then the next line contains N positive numbers D1 … DN (Di&lt;=103 for all i=1, …, N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification: For each test case, print “i-j” in a line for each pair of i &lt;= j such that Di + … + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output “i-j” for pairs of i &lt;= j such that Di + … + Dj &gt; M with (Di + … + Dj - M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1: 1216 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13 Sample Output 1: 12341-54-67-811-11 Sample Input 2: 125 132 4 5 7 9 Sample Output 2: 122-44-5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int sum[100010],n,m;vector&lt;int&gt; solution;int binarySearch(int i) &#123; int left=i,right=n,mid; while (left&lt;right) &#123; mid=(left+right)/2; int s=sum[mid]-sum[i-1]; if (s&gt;=m) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return left;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; sum[0]=0; for (int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; int mins=sum[n]; for (int i=1; i&lt;=n; i++) &#123; int j,tempsum; j=binarySearch(i); tempsum=sum[j]-sum[i-1]; if (tempsum&gt;mins) &#123; continue; &#125; if (tempsum&gt;=m) &#123; if (tempsum&lt;mins) &#123; solution.clear(); mins=tempsum; &#125; solution.push_back(i); solution.push_back(j); &#125; &#125; for (int i=0; i&lt;solution.size(); i+=2) &#123; printf("%d-%d\n",solution[i],solution[i+1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1085. Perfect Sequence (25)]]></title>
    <url>%2FPAT-1085%2F</url>
    <content type="text"><![CDATA[1085. Perfect Sequence (25)Given a sequence of positive integers and another positive integer p. The sequence is said to be a “perfect sequence” if M &lt;= m * p where M and m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification: Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (&lt;= 105) is the number of integers in the sequence, and p (&lt;= 109) is the parameter. In the second line there are N positive integers, each is no greater than 109. Output Specification: For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input: 1210 82 3 20 4 5 1 6 7 8 9 Sample Output: 18 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long long a[100010],n,p;long long binarySearch(long long i, long long x) &#123; if (a[n-1]&lt;=x) &#123; return n; &#125; long long left=i+1,right=n-1; while (left&lt;right) &#123; long long mid=(left+right)/2; if (a[mid]&gt;x) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return left;&#125;int main() &#123; long long maxnum=0; cin&gt;&gt;n&gt;&gt;p; for (long long i=0; i&lt;n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a, a+n); for (long long i=0; i&lt;n; i++) &#123; long long x=binarySearch(i, a[i]*p); maxnum=max(maxnum, x-i); &#125; cout&lt;&lt;maxnum; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1067. Sort with Swap(0,*) (25)]]></title>
    <url>%2FPAT-1067%2F</url>
    <content type="text"><![CDATA[1067. Sort with Swap(0,*) (25)Given any permutation of the numbers {0, 1, 2,…, N-1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4} Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification: Each input file contains one test case, which gives a positive N (&lt;=105) followed by a permutation sequence of {0, 1, …, N-1}. All the numbers in a line are separated by a space. Output Specification: For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input: 110 3 5 7 2 6 4 9 0 8 1 Sample Output: 19 两个易错点，我一开始都错了~ 多次涉及到想要知道某个数所在的位置，每次都遍历数组太麻烦了，干脆在保存的时候就保存每个数字所在的位置，即pos[i] = j表示i数字在j位置，所以每次交换i和0只需要交换pos[i]和pos[0]就好了 很容易超时~如果不处理会产生两个测试点超时：当0在0位时，找寻第一个不在本位的数的时候，如果每次都for循环从头开始找，那么时间复杂度会很高，但是，找的时候找的是第一个不在本位的数，那么index每前进一步都说明前面的数字都是在本位上的，而且在本位上的数是不可能再交换变化的，所以直接设置一个index的变量，每次找第一个数的时候就可以直接从上一次index开始查找，避免了每次都从头找。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int pos[100010]/*pos[i]=j表示数字i在j位置*/, n;int main() &#123; int num=0, index=1 /*保存第一个不在本位的数字*/, left /*剩下left个不在本位的数字*/; cin&gt;&gt;n; left=n; for (int i=0; i&lt;n; i++) &#123; int x; scanf("%d",&amp;x); pos[x]=i; if (pos[x]==x&amp;&amp;x!=0) &#123; left--; &#125; &#125; while (left&gt;0) &#123; if (pos[0]==0) &#123; left--; for (int i=index; i&lt;n; i++) &#123; if (pos[i]!=i) &#123; index=i; swap(pos[0],pos[i]); left++; num++; index=i; break; &#125; &#125; &#125; while (pos[0]!=0) &#123; swap(pos[0], pos[pos[0]]); num++; left--; break; &#125; &#125; printf("%d",num); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1070. Mooncake (25)]]></title>
    <url>%2FPAT-1070%2F</url>
    <content type="text"><![CDATA[1070. Mooncake (25)Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the region’s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made. Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans). Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers N (&lt;=1000), the number of different kinds of mooncakes, and D (&lt;=500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space. Output Specification: For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places. Sample Input: 1233 200180 150 1007.5 7.2 4.5 Sample Output: 19.45 这题超阴险的，很容易没想到的一点就是需求量可能会大于总库存，看样例的时候很容易默认需求量会小点，导致一个点段错误(数组越界). 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct cake &#123; double amount; double price,profit;&#125;c[1010];bool cmp(cake a,cake b) &#123; return a.profit&gt;b.profit;&#125;int main() &#123; int n; double d; cin&gt;&gt;n&gt;&gt;d; for (int i=0; i&lt;n; i++) &#123; scanf("%lf",&amp;c[i].amount); &#125; for (int i=0; i&lt;n; i++) &#123; scanf("%lf",&amp;c[i].price); c[i].profit=c[i].price/c[i].amount; &#125; sort(c, c+n, cmp); int i=0; double profits=0; while (d-c[i].amount&gt;0&amp;&amp;i&lt;n-1) &#123; d-=c[i].amount; profits+=c[i].price; i++; &#125; /* 考虑需求量超大的情况，大于总库存 */ if (d&gt;c[i].amount) &#123; profits+=c[i].price; printf("%.2lf",profits); return 0; &#125; profits+=d*c[i].profit; printf("%.2lf",profits); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1092. To Buy or Not to Buy (20)]]></title>
    <url>%2FPAT-1092%2F</url>
    <content type="text"><![CDATA[1092. To Buy or Not to Buy (20)Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is “Yes”, please tell her the number of extra beads she has to buy; or if the answer is “No”, please tell her the number of beads missing from the string. For the sake of simplicity, let’s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification: Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification: For each test case, print your answer in one line. If the answer is “Yes”, then also output the number of extra beads Eva has to buy; or if the answer is “No”, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1: 12ppRYYGrrYBR2258YrR8RrY Sample Output 1: 1Yes 8 Sample Input 2: 12ppRYYGrrYB225YrR8RrY Sample Output 1: 1No 2 hash散列 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool hashtable[1001]=&#123;false&#125;;int main() &#123; int havein=0,less=0; string a,b; cin&gt;&gt;a&gt;&gt;b; for (int i=0; i&lt;b.size(); i++) &#123; int flag=0; for (int j=0; j&lt;a.size(); j++) &#123; if (a[j]==b[i]&amp;&amp;!hashtable[j]) &#123; flag=1; hashtable[j]=true; havein++; break; &#125; &#125; if (flag==0) &#123; less++; &#125; &#125; if (less==0) &#123; printf("Yes %d",a.size()-havein); &#125; else &#123; printf("No %d",less); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1084. Broken Keyboard (20)]]></title>
    <url>%2FPAT-1084%2F</url>
    <content type="text"><![CDATA[1084. Broken Keyboard (20)On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen. Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out. Input Specification: Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or “_” (representing the space). It is guaranteed that both strings are non-empty. Output Specification: For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key. Sample Input: 127_This_is_a_test_hs_s_a_es Sample Output: 17TI hash散列 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=37;int hasOutput[maxn];int hash1(char a) &#123; if (a&lt;='9'&amp;&amp;a&gt;='0') &#123; return a-'0'; &#125; else if (a&gt;='A'&amp;&amp;a&lt;='Z') &#123; return a-'A'+10; &#125; else &#123; return 36; &#125;&#125;int main() &#123; int dec='a'-'A'; string b; cin&gt;&gt;b; for (int i=0; i&lt;b.size(); i++) &#123; if (b[i]&gt;='a'&amp;&amp;b[i]&lt;='z') &#123; b[i]-=dec; &#125; &#125; string op; cin&gt;&gt;op; for (int i=0; i&lt;op.size(); i++) &#123; if (op[i]&gt;='a'&amp;&amp;op[i]&lt;='z') &#123; op[i]-=dec; &#125; &#125; int value; for (int i=0; i&lt;b.size(); i++) &#123; value=hash1(b[i]); if (op.find(b[i])==-1&amp;&amp;hasOutput[value]==0) &#123; printf("%c",b[i]); hasOutput[value]=1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1028. List Sorting (25)]]></title>
    <url>%2FPAT-1028%2F</url>
    <content type="text"><![CDATA[1028. List Sorting (25)Excel can sort records according to any column. Now you are supposed to imitate this function. Input Each input file contains one test case. For each case, the first line contains two integers N (&lt;=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive). Output For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to ID’s; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order. Sample Input 1 12343 1000007 James 85000010 Amy 90000001 Zoe 60 Sample Output 1 123000001 Zoe 60000007 James 85000010 Amy 90 Sample Input 2 123454 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 98 Sample Output 2 1234000010 Amy 90000002 James 98000007 James 85000001 Zoe 60 Sample Input 3 123454 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 90 Sample Output 3 1234000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct record &#123; char name[10],id[8]; int grade;&#125;r[100010];bool cmp1(record r1,record r2) &#123; return strcmp(r1.id, r2.id)&lt;0;&#125;bool cmp2(record r1,record r2) &#123; if (strcmp(r1.name, r2.name)!=0) &#123; return strcmp(r1.name, r2.name)&lt;0; &#125; return strcmp(r1.id, r2.id)&lt;0;&#125;bool cmp3(record r1,record r2) &#123; if (r1.grade!=r2.grade) &#123; return r1.grade&lt;r2.grade; &#125; return strcmp(r1.id, r2.id)&lt;0;&#125;int main() &#123; int n,c; cin&gt;&gt;n&gt;&gt;c; for (int i=0; i&lt;n; i++) &#123; scanf("%s%s%d",r[i].id,r[i].name,&amp;r[i].grade); &#125; switch (c) &#123; case 1: sort(r, r+n, cmp1); break; case 2: sort(r, r+n, cmp2); break; case 3: sort(r, r+n, cmp3); break; default: break; &#125; for (int i=0; i&lt;n; i++) &#123; printf("%s %s %d\n",r[i].id,r[i].name,r[i].grade); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1016. Phone Bills (25)]]></title>
    <url>%2FPAT-1016%2F</url>
    <content type="text"><![CDATA[1016. Phone Bills (25)A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification: Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N (&lt;= 1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word “on-line” or “off-line”. For each test case, all dates will be within a single month. Each “on-line” record is paired with the chronologically next record for the same customer provided it is an “off-line” record. Any “on-line” records that are not paired with an “off-line” record are ignored, as are “off-line” records not paired with an “on-line” record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification: For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customers’ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input: 12345678910111210 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line Sample Output: 12345678910CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 做了半天的题告诉我只对了样例，其他是段错误？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct record &#123; char name[25]; int month,date,hour,min; int state; //0下线 1上线&#125;r[1010];int cost[25]; //每个时间段电话费率bool cmp(record a,record b) &#123; if (strcmp(a.name, b.name)!=0) &#123; return strcmp(a.name, b.name)&lt;0; &#125; else if (a.month!=b.month) &#123; return a.month&lt;b.month; &#125; else if (a.date!=b.date) &#123; return a.date&lt;b.date; &#125; else if (a.hour!=b.hour) &#123; return a.hour&lt;b.hour; &#125; else &#123; return a.min&lt;b.min; &#125;&#125;/* 计算一天内两个时间点之间花的钱 */double costFromHourToHour(record r1,record r2) &#123; double amount=0; int h=r1.hour; amount=(60-r1.min)*cost[h]; while (++h != r2.hour) &#123; amount+=60*cost[h]; &#125; amount+=r2.min*cost[h]; amount/=100; return amount;&#125;int main() &#123; double costAday=0; for (int i=0; i&lt;24; i++) &#123; scanf("%d",&amp;cost[i]); costAday+=60*cost[i]/100; &#125; int n; scanf("%d",&amp;n); for (int i=0; i&lt;n; i++) &#123; char s[10]; scanf("%s%d:%d:%d:%d%s",r[i].name,&amp;r[i].month,&amp;r[i].date,&amp;r[i].hour,&amp;r[i].min,s); if (strcmp(s, "on-line")==0) &#123; r[i].state=1; &#125; else &#123; r[i].state=0; &#125; &#125; sort(r, r+n, cmp); char name1[25]; //暂存当前用户名 strcpy(name1, r[0].name); int flag=0, /*flag前后为1 0的话就说明这两条记录可计算话费*/ hasPrintName=0; double totalAmount=0; //当前用户总话费 for (int i=0; i&lt;n; i++) &#123; if (strcmp(name1, r[i].name)==0) &#123; if (hasPrintName==0) &#123; //没输出过当前用户名就输出 printf("%s %02d\n",r[i].name,r[i].month); hasPrintName=1; &#125; if (r[i].state==1) &#123; flag=1; &#125; else if (r[i].state==0&amp;&amp;flag==1) &#123; printf("%02d:%02d:%02d",r[i-1].date,r[i-1].hour,r[i-1].min); printf(" %02d:%02d:%02d",r[i].date,r[i].hour,r[i].min); int totalmin=((r[i].date-r[i-1].date)*24+r[i].hour-r[i-1].hour)*60+r[i].min-r[i-1].min; printf(" %d",totalmin); double amount=0.0; //当前时间段的话费 if (r[i].date!=r[i-1].date) &#123; int d=r[i-1].date; record rec; rec.hour=23;rec.min=60; amount+=costFromHourToHour(r[i-1],rec); while (++d != r[i].date) &#123; amount+=costAday; &#125; rec.hour=0;rec.min=0; amount+=costFromHourToHour(rec,r[i]); &#125; else &#123; amount=costFromHourToHour(r[i-1],r[i]); &#125; printf(" $%.2lf\n",amount); totalAmount+=amount; flag=0; &#125; &#125; else &#123; strcpy(name1, r[i].name); hasPrintName=0; if (r[i].state==1) &#123; flag=1; &#125; if (totalAmount!=0) &#123; printf("Total amount: $%.2lf\n",totalAmount); &#125; totalAmount=0; &#125; &#125; if (totalAmount!=0) &#123; printf("Total amount: $%.2lf\n",totalAmount); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1062. Talent and Virtue (25)]]></title>
    <url>%2FPAT-1062%2F</url>
    <content type="text"><![CDATA[1062. Talent and Virtue (25)About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about people’s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a “sage（圣人）”; being less excellent but with one’s virtue outweighs talent can be called a “nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man is better than a “small man（小人）” who prefers talent than virtue. Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guang’s theory. Input Specification: Each input file contains one test case. Each case first gives 3 positive integers in a line: N (&lt;=105), the total number of people to be ranked; L (&gt;=60), the lower bound of the qualified grades – that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H (&lt;100), the higher line of qualification – that is, those with both grades not below this line are considered as the “sages”, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the “noblemen”, and are also ranked in non-increasing order according to their total grades, but they are listed after the “sages”. Those with both grades below H, but with virtue not lower than talent are considered as the “fool men”. They are ranked in the same way but after the “noblemen”. The rest of people whose grades both pass the L line are ranked after the “fool men”. Then N lines follow, each gives the information of a person in the format: 1ID_Number Virtue_Grade Talent_Grade Output Specification: The first line of output must give M (&lt;=N), the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their ID’s. Sample Input: 12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 Sample Output: 123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 结构体排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;struct people &#123; int id; int v_grade,t_grade,totalgrade; int flag; int rank;&#125;p[100010];bool cmp(people a,people b) &#123; if (a.rank!=b.rank) &#123; return a.rank&lt;b.rank; &#125; else if (a.totalgrade!=b.totalgrade) &#123; return a.totalgrade&gt;b.totalgrade; &#125; else if (a.v_grade!=b.v_grade) &#123; return a.v_grade&gt;b.v_grade; &#125; return a.id&lt;b.id;&#125;int main() &#123; int n,l,h,num=0; cin&gt;&gt;n&gt;&gt;l&gt;&gt;h; for (int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;p[i].id,&amp;p[i].v_grade,&amp;p[i].t_grade); p[i].totalgrade=p[i].v_grade+p[i].t_grade; if (p[i].v_grade&lt;l||p[i].t_grade&lt;l) &#123; p[i].flag=1; //不会被排名 continue; &#125; if (p[i].v_grade&gt;=h&amp;&amp;p[i].t_grade&gt;=h) &#123; p[i].rank=1; //圣人 &#125; else if (p[i].v_grade&gt;=h&amp;&amp;p[i].t_grade&lt;h) &#123; p[i].rank=2; //君子 &#125; else if (p[i].v_grade&gt;=p[i].t_grade&amp;&amp;p[i].v_grade&lt;h&amp;&amp;p[i].t_grade&lt;h) &#123; p[i].rank=3; //愚人 &#125; else &#123; p[i].rank=4; //剩下的人 &#125; num++; &#125; cout&lt;&lt;num&lt;&lt;endl; sort(p, p+n, cmp); for (int i=0; i&lt;n; i++) &#123; if (p[i].flag==0) &#123; printf("%d %d %d\n",p[i].id,p[i].v_grade,p[i].t_grade); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1025. PAT Ranking (25)]]></title>
    <url>%2FPAT-1025%2F</url>
    <content type="text"><![CDATA[1025. PAT Ranking (25)Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification: Each input file contains one test case. For each case, the first line contains a positive number N (&lt;=100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (&lt;=300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rank The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input: 123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 Sample Output: 1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 估计是面向玄学编程，最后一个点怎么会过不了呢，数字很大的情况也都考虑了呀… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; long long int id; int grade,locationNum,localrank,finalrank;&#125;stu[30001];bool cmp(student a,student b) &#123; if (a.grade!=b.grade) &#123; return a.grade&gt;b.grade; &#125; return a.id&lt;b.id;&#125;int main() &#123; int n,k,num=0; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;k; for (int j=num; j&lt;num+k; j++) &#123; scanf("%lld%d",&amp;stu[j].id,&amp;stu[j].grade); stu[j].locationNum=i; &#125; sort(stu+num, stu+num+k, cmp); stu[num].localrank=1; for (int j=1; j&lt;=k-1; j++) &#123; if (stu[num+j].grade==stu[num+j-1].grade) &#123; stu[num+j].localrank=stu[num+j-1].localrank; &#125; else &#123; stu[num+j].localrank=j+1; &#125; &#125; num+=k; &#125; printf("%d\n",num); sort(stu, stu+num, cmp); if (num!=0) &#123; stu[0].finalrank=1; printf("%lld %d %d %d\n",stu[0].id,stu[0].finalrank,stu[0].locationNum,stu[0].localrank); &#125; for (int j=1; j&lt;num; j++) &#123; if (stu[j].grade==stu[j-1].grade) &#123; stu[j].finalrank=stu[j-1].finalrank; &#125; else &#123; stu[j].finalrank=j+1; &#125; printf("%013lld %d %d %d\n",stu[j].id,stu[j].finalrank,stu[j].locationNum,stu[j].localrank); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1082. Read Number in Chinese (25)]]></title>
    <url>%2FPAT-1082%2F</url>
    <content type="text"><![CDATA[1082. Read Number in Chinese (25)Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output “Fu” first if it is negative. For example, -123456789 is read as “Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu”. Note: zero (“ling”) must be handled correctly according to the Chinese tradition. For example, 100800 is “yi Shi Wan ling ba Bai”. Input Specification: Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification: For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1: 1-123456789 Sample Output 1: 1Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2: 1100800 Sample Output 2: 1yi Shi Wan ling ba Bai 这个题目真心麻烦，挺变态的。一开始都想从length=1到9分类枚举算了，机制忒复杂~主要还是因为我大中华文字博大精深。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char num[10][5]=&#123;"ling","yi","er","san","si","wu","liu","qi","ba","jiu"&#125;;char wei[5][5]=&#123;"Shi","Bai","Qian","Wan","Yi"&#125;;int main() &#123; char a[11]; scanf("%s",a); int len,left=0,right; len=strlen(a); if (a[0]=='-') &#123; printf("Fu"); left++; &#125; right=len-1; while (right-4&gt;=left) &#123; right-=4; &#125; int flag,hasPrint; while (len-1-right&gt;=0) &#123; flag=0; //当flag=1时说明前面有一个累积的零 hasPrint=0; //此四位是否有输出过数字 while (left&lt;=right) &#123; if (left&gt;0 /*特殊输入为零时*/ &amp;&amp;a[left]=='0') &#123; flag=1; &#125; else &#123; if (flag==1) &#123; printf(" ling"); flag=0; &#125; if (left&gt;0) &#123; printf(" "); &#125; printf("%s",num[a[left]-'0']); hasPrint=1; if (left!=right) &#123; printf(" %s",wei[right-left-1]); &#125; &#125; left++; &#125; if (hasPrint==1&amp;&amp;right!=len-1) &#123; printf(" %s",wei[(len-1-right)/4+2]); &#125; right+=4; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1077. Kuchiguse (20)]]></title>
    <url>%2FPAT-1077%2F</url>
    <content type="text"><![CDATA[1077. Kuchiguse (20)The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification: Each input file contains one test case. For each case, the first line is an integer N (2&lt;=N&lt;=100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive. Output Specification: For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write “nai”. Sample Input 1: 12343Itai nyan~Ninjin wa iyadanyan~uhhh nyan~ Sample Output 1: 1nyan~ Sample Input 2: 12343Itai!Ninjinnwaiyada T_TT_T Sample Output 2: 1nai 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct line &#123; char l[260]; int len;&#125;line[101];int main() &#123; int n,min=270; cin&gt;&gt;n; cin.get(); //接收回车换行符 for (int i=0; i&lt;n; i++) &#123; cin.getline(line[i].l, 260); line[i].len=strlen(line[i].l); if (line[i].len&lt;min) &#123; min=line[i].len; &#125; &#125; int j=1,flag=0; while (j &lt;= min) &#123; for (int i=0; i&lt;n-1; i++) &#123; if (line[i].l[line[i].len-j]==line[i+1].l[line[i+1].len-j]) &#123; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; break; &#125; j++; &#125; if (j==1) &#123; cout&lt;&lt;"nai"; return 0; &#125; for (int i=line[0].len-j+1; i&lt;line[0].len; i++) &#123; cout&lt;&lt;line[0].l[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1035. Password (20)]]></title>
    <url>%2FPAT-1035%2F</url>
    <content type="text"><![CDATA[1035. Password (20)To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords. Input Specification: Each input file contains one test case. Each case contains a positive integer N (&lt;= 1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space. Output Specification: For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line “There are N accounts and no account is modified” where N is the total number of accounts. However, if N is one, you must print “There is 1 account and no account is modified” instead. Sample Input 1: 12343Team000002 Rlsp0dfaTeam000003 perfectpwdTeam000001 R1spOdfa Sample Output 1: 1232Team000002 RLsp%dfaTeam000001 R@spodfa Sample Input 2: 121team110 abcdefg332 Sample Output 2: 1There is 1 account and no account is modified Sample Input 3: 1232team110 abcdefg222team220 abcdefg333 Sample Output 3: 1There are 2 accounts and no account is modified 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct user &#123; char name[11],password[11];&#125;user[1001];int main() &#123; int n,num=0; cin&gt;&gt;n; vector&lt;int&gt; id; for (int i=0; i&lt;n; i++) &#123; scanf("%s%s", user[i].name, user[i].password); int len=strlen(user[i].password),flag=0; char *pass=user[i].password; for (int j=0; j&lt;len; j++) &#123; if (pass[j]=='1') &#123; pass[j]='@'; flag=1; &#125; else if (pass[j]=='0') &#123; pass[j]='%'; flag=1; &#125; else if (pass[j]=='l') &#123; pass[j]='L'; flag=1; &#125; else if (pass[j]=='O') &#123; pass[j]='o'; flag=1; &#125; &#125; if (flag==1) &#123; num++; id.push_back(i); &#125; &#125; if (num==0) &#123; if (n==1) &#123; printf("There is 1 account and no account is modified"); &#125; else &#123; printf("There are %d accounts and no account is modified",n); &#125; return 0; &#125; cout&lt;&lt;num&lt;&lt;endl; for (int i=0; i&lt;num; i++) &#123; printf("%s %s",user[id[i]].name,user[id[i]].password); if (i!=num-1) &#123; printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1073. Scientific Notation (20)]]></title>
    <url>%2FPAT-1073%2F</url>
    <content type="text"><![CDATA[1073. Scientific Notation (20)Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]”.”[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponent’s signs are always provided even when they are positive. Now given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures. Input Specification: Each input file contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponent’s absolute value is no more than 9999. Output Specification: For each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros, Sample Input 1: 1+1.23400E-03 Sample Output 1: 10.00123400 Sample Input 2: 1-1.2E+10 Sample Output 2: 1-12000000000 此代码还有一个一分的小点没过，暂时没找出问题… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; char a[10000]; scanf("%s",a); char x[10000]="\0",y[10000]="\0"; sscanf(a, "%[+-0-9]E%[+-0-9]", x, y); if (x[0]=='-') &#123; printf("%c",x[0]); &#125; int k; k=abs(stoi(y)); /* 特殊情况 指数为零 */ if (k==0) &#123; for (int i=1; x[i]!='\0'; i++) &#123; cout&lt;&lt;x[i]; &#125; return 0; &#125; /* 特殊情况 底数为零 */ if (abs(stoi(x))==0) &#123; for (int i=1; x[i]!='\0'; i++) &#123; cout&lt;&lt;x[i]; &#125; return 0; &#125; /* 指数为正 */ if (y[0]=='+') &#123; k=stoi(y); cout&lt;&lt;x[1]; int i; for (i=3; i&lt;3+k; i++) &#123; if (x[i]=='\0') &#123; cout&lt;&lt;'0'; &#125; else &#123; cout&lt;&lt;x[i]; &#125; &#125; if (x[i]!='\0') &#123; cout&lt;&lt;"."; &#125; for (int j=i; x[j]!='\0'; j++) &#123; cout&lt;&lt;x[j]; &#125; &#125; /* 指数为负 */ else if (y[0]=='-') &#123; k=abs(stoi(y)); cout&lt;&lt;"0."; for (int i=0; i&lt;k-1; i++) &#123; cout&lt;&lt;'0'; &#125; cout&lt;&lt;x[1]; for (int i=3; x[i]!='\0'; i++) &#123; cout&lt;&lt;a[i]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1061. Dating (20)]]></title>
    <url>%2FPAT-1061%2F</url>
    <content type="text"><![CDATA[1061. Dating (20)Sherlock Holmes received a note with some strange strings: “Let’s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”. It took him only a minute to figure out that those strange strings are actually referring to the coded time “Thursday 14:04” – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter ‘D’, representing the 4th day in a week; the second common character is the 5th capital letter ‘E’, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is ‘s’ at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification: Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification: For each test case, print the decoded time in one line, in the format “DAY HH:MM”, where “DAY” is a 3-character abbreviation for the days in a week – that is, “MON” for Monday, “TUE” for Tuesday, “WED” for Wednesday, “THU” for Thursday, “FRI” for Friday, “SAT” for Saturday, and “SUN” for Sunday. It is guaranteed that the result is unique for each case. Sample Input: 12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm Sample Output: 1THU 14:04 这题目意思有点难看懂，星期对应{A-G}七个字母，小时对应{0-9 A-N} 24个数字，分钟对应{A-Z a-z} 52个英文字母 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; string a[7]=&#123;"MON","TUE","WED","THU","FRI","SAT","SUN"&#125;; char b[122],c[61],d[122],e[61]; cin&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; int i; for (i=0; b[i]!='\0'&amp;&amp;c[i]!='\0'; i++) &#123; if (b[i]==c[i]&amp;&amp;b[i]-'A'&gt;=0&amp;&amp;b[i]-'A'&lt;=6) &#123; int j=b[i]-'A'; cout&lt;&lt;a[j]&lt;&lt;" "; break; &#125; &#125; for (int j=i+1; b[j]!='\0'&amp;&amp;c[j]!='\0'; j++) &#123; if (b[j]==c[j]) &#123; int x; if (b[j]-'0'&gt;=0&amp;&amp;b[j]-'0'&lt;=9) &#123; x=b[j]-'0'; printf("0%d",x); break; &#125; else if (b[j]-'A'&gt;=0&amp;&amp;b[j]-'A'&lt;=14) &#123; x=b[j]-'A'+10; printf("%d",x); break; &#125; &#125; &#125; printf(":"); for (i=0; d[i]!='\0'&amp;&amp;e[i]!='\0'; i++) &#123; if (d[i]==e[i]) &#123; if ((d[i]-'A'&gt;=0&amp;&amp;d[i]-'A'&lt;=25)||(d[i]-'a'&gt;=0&amp;&amp;d[i]-'a'&lt;=25)) &#123; printf("%02d",i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1058. A+B in Hogwarts (20)]]></title>
    <url>%2FPAT-1058%2F</url>
    <content type="text"><![CDATA[1058. A+B in Hogwarts (20)If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of “Galleon.Sickle.Knut” (Galleon is an integer in [0, 107], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)). Input Specification: Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space. Output Specification: For each test case you should output the sum of A and B in one line, with the same format as the input. Sample Input: 13.2.1 10.16.27 Sample Output: 114.1.28 唔，这里a2不需要取余（10^7+1），题目没说会进位，一开始我给默认了… 1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b,c,a1,b1,c1,a2,b2,c2; scanf("%d.%d.%d",&amp;a,&amp;b,&amp;c); scanf("%d.%d.%d",&amp;a1,&amp;b1,&amp;c1); c2 = (c+c1)%29; b2 = (b+b1+(c+c1)/29)%17; a2 = a+a1+(b+b1+(c+c1)/29)/17; printf("%d.%d.%d",a2,b2,c2); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1027. Colors in Mars (20)]]></title>
    <url>%2FPAT-1027%2F</url>
    <content type="text"><![CDATA[1027. Colors in Mars (20)People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Each input file contains one test case which occupies a line containing the three decimal color values. Output For each test case you should output the Mars RGB value in the following format: first output “#”, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a “0” to the left. Sample Input 115 43 71 Sample Output 1#123456 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; char x[13]=&#123;'0','1','2','3','4','5','6','7','8','9','A','B','C'&#125;; cout&lt;&lt;"#"; char m,n; m=x[a%13]; a/=13; n=x[a%13]; printf("%c%c",n,m); m=x[b%13]; b/=13; n=x[b%13]; printf("%c%c",n,m); m=x[c%13]; c/=13; n=x[c%13]; printf("%c%c",n,m); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019. General Palindromic Number (20)]]></title>
    <url>%2FPAT-1019%2F</url>
    <content type="text"><![CDATA[1019. General Palindromic Number (20)A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N &gt; 0 in base b &gt;= 2, where it is written in standard notation with k+1 digits ai as the sum of (aibi) for i from 0 to k. Here, as usual, 0 &lt;= ai &lt; b for all i and ak is non-zero. Then N is palindromic if and only if ai = ak-i for all i. Zero is written 0 in any base and is also palindromic by definition. Given any non-negative decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b. Input Specification: Each input file contains one test case. Each case consists of two non-negative numbers N and b, where 0 &lt;= N &lt;= 109 is the decimal number and 2 &lt;= b &lt;= 109 is the base. The numbers are separated by a space. Output Specification: For each test case, first print in one line “Yes” if N is a palindromic number in base b, or “No” if not. Then in the next line, print N as the number in base b in the form “ak ak-1 … a0”. Notice that there must be no extra space at the end of output. Sample Input 1: 127 2 Sample Output 1: 12Yes1 1 0 1 1 Sample Input 2: 1121 5 Sample Output 2: 12No4 4 1 容易遗漏的一个特殊情况，那就是当N=0的时候，需要输出一个零，所以将循环改成了do…while 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; a;int main() &#123; int n,b; cin&gt;&gt;n&gt;&gt;b; do &#123; a.push_back(n%b); n=n/b; &#125; while (n!=0); int flag=0; for (int i=a.size()-1; i&gt;=0; i--) &#123; if (a[i]!=a[a.size()-i-1]) &#123; flag=1; break; &#125; &#125; if (flag==0) &#123; cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; for (int i=a.size()-1; i&gt;=0; i--) &#123; cout&lt;&lt;a[i]; if (i!=0) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031. Hello World for U (20)]]></title>
    <url>%2FPAT-1031%2F</url>
    <content type="text"><![CDATA[1031. Hello World for U (20)Given any string of N (&gt;=5) characters, you are asked to form the characters into the shape of U. For example, “helloworld” can be printed as: 1234h de ll rlowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible – that is, it must be satisfied that n1 = n3 = max { k| k &lt;= n2 for all 3 &lt;= n2 &lt;= N } with n1 + n2 + n3 - 2 = N. Input Specification: Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification: For each test case, print the input string in the shape of U as specified in the description. Sample Input: 1helloworld! Sample Output: 1234h !e dl llowor 模拟打印一个尽可能接近正方形的U型~ 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a; cin&gt;&gt;a; int len=a.length(); //总长度 int x,y; //x为左上和右上两竖的长度，y为底边的长度 y=len/3+1; if ((len-y)%2==0) &#123; x=(len-y)/2; //如果剩余为偶数直接除二得到x &#125; else &#123; y++; x=(len-y)/2; //如果剩余为奇数先减一再除二得到x &#125; for (int i=0; i&lt;x; i++) &#123; int space=y-2; cout&lt;&lt;a[i]; while (space-- &gt; 0) &#123; cout&lt;&lt;" "; &#125; cout&lt;&lt;a[len-i-1]&lt;&lt;endl; &#125; for (int i=0; i&lt;y; i++) &#123; cout&lt;&lt;a[i+x]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1036. Boys vs Girls (25)]]></title>
    <url>%2FPAT-1036%2F</url>
    <content type="text"><![CDATA[1036. Boys vs Girls (25)This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification: For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF-gradeM. If one such kind of student is missing, output “Absent” in the corresponding line, and output “NA” in the third line instead. Sample Input 1: 12343Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95 Sample Output 1: 123Mary EE990830Joe Math9901126 Sample Input 2: 121Jean M AA980920 60 Sample Output 2: 123AbsentJean AA980920NA 特别注意一个点：scanf里面的%c是可以接受空格字符的，所以”%c”前要加上一个空格即” %c”，如下： 1scanf("%s %c%s%d",stu[i].name,&amp;stu[i].sex,stu[i].id,&amp;stu[i].grade); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char name[15]; char sex; char id[15]; int grade;&#125;stu[100];int main() &#123; int n; scanf("%d",&amp;n); for (int i=0; i&lt;n; i++) &#123; scanf("%s %c%s%d",stu[i].name,&amp;stu[i].sex,stu[i].id,&amp;stu[i].grade); &#125; int female=-1,male=-1,femalescore=-1,malescore=101; for (int i=0; i&lt;n; i++) &#123; if (stu[i].sex=='F') &#123; if (stu[i].grade&gt;femalescore) &#123; female=i; femalescore=stu[i].grade; &#125; &#125; else if (stu[i].sex=='M') &#123; if (stu[i].grade&lt;malescore) &#123; male=i; malescore=stu[i].grade; &#125; &#125; &#125; if (female!=-1) &#123; printf("%s %s\n",stu[female].name,stu[female].id); &#125; else &#123; printf("Absent\n"); &#125; if (male!=-1) &#123; printf("%s %s\n",stu[male].name,stu[male].id); &#125; else &#123; printf("Absent\n"); &#125; if (femalescore!=-1&amp;&amp;malescore!=101) &#123; printf("%d",femalescore-malescore); &#125; else &#123; printf("NA"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1046. Shortest Distance (20)]]></title>
    <url>%2FPAT-1046%2F</url>
    <content type="text"><![CDATA[1046. Shortest Distance (20)The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification: Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification: For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input: 123455 1 2 4 14 931 32 54 1 Sample Output: 1233107 简单模拟，数据量比较大，容易超时。所以选择采用dis[i]保存从i节点到1的距离，这样两点间的一个距离就是abs(dis[x]-dis[y])，另一个用sum一减就出来了，时间复杂度o(n). 然后不知道是玄学还是什么，刚开始直接输入一个就直接输出一个结果答案是可以，但是oj却wrong answer，那我不得不用vector保存了结果再输出，可是当我又用刚才直接输出的代码跑一遍却过了，真是玄学~ 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dis[100002];int main() &#123; int num,sum=0; scanf("%d",&amp;num); dis[1]=0; for (int i=2; i&lt;=num; i++) &#123; scanf("%d",&amp;dis[i]); dis[i]+=dis[i-1]; &#125; int end; scanf("%d",&amp;end); sum=dis[num]+end; int num1; cin&gt;&gt;num1; vector&lt;int&gt; result; for (int i=1; i&lt;=num1; i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int l1=0,l2=0; l1=abs(dis[y]-dis[x]); l2=sum-l1; result.push_back(min(l1, l2)); &#125; for (auto it=result.begin(); it!=result.end(); it++) &#123; printf("%d\n",*it); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042. Shuffling Machine (20)]]></title>
    <url>%2FPAT-1042%2F</url>
    <content type="text"><![CDATA[1042. Shuffling Machine (20)Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2 where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification: For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input: 12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output: 1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H1 简单模拟，题目还挺长。。🤣 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string a[55];int main() &#123; for (int i=0; i&lt;13; i++) &#123; a[i+1]="S"+to_string(i+1); a[14+i]="H"+to_string(i+1); a[27+i]="C"+to_string(i+1); a[40+i]="D"+to_string(i+1); &#125; a[53]="J1";a[54]="J2"; string b[55]; //暂存 int num; cin&gt;&gt;num; int order[55]; for (int i=1; i&lt;=54; i++) &#123; int temp; cin&gt;&gt;temp; order[i]=temp; &#125; while (num-- &gt; 0) &#123; for (int i=1; i&lt;=54; i++) &#123; b[order[i]]=a[i]; &#125; for (int i=1; i&lt;=54; i++) &#123; a[i]=b[i]; &#125; &#125; for (int i=1; i&lt;=54; i++) &#123; cout&lt;&lt;a[i]; if (i!=54) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1012. The Best Rank (25)]]></title>
    <url>%2FPAT-1012%2F</url>
    <content type="text"><![CDATA[1012. The Best Rank (25)To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algebra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: 12345StudentID C M E A310101 98 85 88 90310102 70 95 88 84310103 82 87 94 88310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (&lt;=2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output “N/A”. Sample Input 1234567891011125 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output 1234561 C1 M1 E1 A3 AN/A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student&#123; int sid,best; int score[4],rank[4];&#125;stu[2001];int exsit[1000001];int flag=0;bool cmp(student a,student b) &#123; return a.score[flag]&gt;b.score[flag];&#125;int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for (int i=0; i&lt;n; i++) &#123; scanf("%d%d%d%d",&amp;stu[i].sid,&amp;stu[i].score[1],&amp;stu[i].score[2],&amp;stu[i].score[3]); stu[i].score[0]=(stu[i].score[1]+stu[i].score[2]+stu[i].score[3])/3; &#125; for (flag=0; flag&lt;=3; flag++) &#123; sort(stu, stu+n, cmp); stu[0].rank[flag]=1; for (int i=1; i&lt;n; i++) &#123; stu[i].rank[flag]=i+1; if (stu[i].score[flag]==stu[i-1].score[flag]) &#123; stu[i].rank[flag]=stu[i-1].rank[flag]; &#125; &#125; &#125; for (int i=0; i&lt;n; i++) &#123; exsit[stu[i].sid]=i+1; stu[i].best=0; int min=stu[i].rank[0]; for (int j=1; j&lt;=3; j++) &#123; if (stu[i].rank[j]&lt;min) &#123; min=stu[i].rank[j]; stu[i].best=j; &#125; &#125; &#125; char a[5]=&#123;'A','C','M','E'&#125;; for (int i=0; i&lt;m; i++) &#123; int id; scanf("%d",&amp;id); if (exsit[id]==0) &#123; printf("N/A\n"); &#125; else &#123; int sid=exsit[id]-1; printf("%d %c\n",stu[sid].rank[stu[sid].best],a[stu[sid].best]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1011. World Cup Betting (20)]]></title>
    <url>%2FPAT-1011%2F</url>
    <content type="text"><![CDATA[1011. World Cup Betting (20)With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%. For example, 3 games’ odds are given as the following: 1234 W T L1.1 2.5 1.71.2 3.0 1.64.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.13.02.565%-1)2 = 37.98 yuans (accurate up to 2 decimal places). Input Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1231.1 2.5 1.71.2 3.0 1.64.1 1.2 1.1 Sample Output 1T T W 37.98 目前碰到最简单的题了😆 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;map&lt;double,string&gt; m;int main() &#123; double a,b,c,maxNum,sum=1; for (int i=0; i&lt;3; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; m[a]="W"; m[b]="T"; m[c]="L"; maxNum=max(a, b); maxNum=max(maxNum,c); sum*=maxNum; cout&lt;&lt;m[maxNum]&lt;&lt;" "; &#125; double result=(sum*0.65-1)*2; printf("%.2lf",result); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1034. Head of a Gang (30)]]></title>
    <url>%2FPAT-1034%2F</url>
    <content type="text"><![CDATA[1034. Head of a Gang (30)One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification: Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format: Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes. Output Specification: For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1: 1234567898 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1: 1232AAA 3GGG 3 Sample Input 2: 1234567898 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 2: 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string,int&gt; a; //每个人的名字对应编号map&lt;int,string&gt; b; //每个编号对应人名map&lt;string,int&gt; result; //输出结果int line[2001][2001] /*边权*/, point[2001] /*点权*/, visit[2001] /*是否已经遍历过*/;int n,k; //n为总电话数，k为判断阈值 int digitNo=1; //digitNo-1为总人数/* 将人名转化为编号 */int stringToNum(string s) &#123; if (a[s]==0) &#123; a[s]=digitNo; b[digitNo]=s; return digitNo++; &#125; else &#123; return a[s]; &#125;&#125;/* DFS统计当前连通分量 */void dfs(int now,int &amp;head,int &amp;memberNum,int &amp;totalWeight) &#123; visit[now]=1; memberNum++; if (point[now]&gt;point[head]) &#123; head=now; &#125; for (int i=1; i&lt;digitNo; i++) &#123; if (line[now][i]&gt;0) &#123; totalWeight+=line[now][i]; line[now][i]=line[i][now]=0; if (visit[i]==0) &#123; dfs(i, head, memberNum, totalWeight); &#125; &#125; &#125;&#125;void DFS() &#123; for (int i=1; i&lt;digitNo; i++) &#123; if (visit[i]==0) &#123; int head=i,memberNum=0,totalWeight=0; dfs(i,head,memberNum,totalWeight); /* 每当找到一个连通分量则判断是否为犯罪团伙 */ if (memberNum&gt;2&amp;&amp;totalWeight&gt;k) &#123; result[b[head]]=memberNum; &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for (int i=0; i&lt;n; i++) &#123; string x,y; int z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; int id1=stringToNum(x); int id2=stringToNum(y); point[id1]+=z; point[id2]+=z; line[id1][id2]+=z; line[id2][id1]+=z; &#125; DFS(); cout&lt;&lt;result.size()&lt;&lt;endl; /* auto为C++11新特性-动态类型，自动推导类型 */ for (auto it=result.begin(); it!=result.end(); it++) &#123; /* it迭代器指向的是一个个键值对（pair&lt;string,int&gt;），first相当于key，second相当于value */ cout&lt;&lt;it-&gt;first&lt;&lt;" "&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1045. Favorite Color Stripe (30)]]></title>
    <url>%2FPAT-1045%2F</url>
    <content type="text"><![CDATA[1045. Favorite Color Stripe (30)Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (&lt;=200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (&lt;=10000) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line are separated by a space. Output Specification: For each test case, simply print in a line the maximum length of Eva’s favorite stripe. Sample Input: 12365 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6 Sample Output: 17 动态规划，最大上升子列问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int favor[201] /*喜欢的颜色*/, a[10001] /*保存输入元素在favor中的权值*/, dp[10001] /*保存对应a中当前元素以前最大递增子列（LIS）长度*/;int main() &#123; int n,m,l; cin&gt;&gt;n&gt;&gt;m; for (int i=1; i&lt;=m; i++) &#123; int temp; cin&gt;&gt;temp; favor[temp]=i; &#125; cin&gt;&gt;l; int num=0; for (int i=0; i&lt;l; i++) &#123; int temp; cin&gt;&gt;temp; if (favor[temp]&gt;=1) &#123; a[num++]=favor[temp]; &#125; &#125; for (int i=0; i&lt;num; i++) &#123; int maxLength=0; for (int j=0; j&lt;i; j++) &#123; if (a[i]&gt;=a[j]) &#123; maxLength=max(maxLength, dp[j]); //找到每个位置之前最大的dp[j] &#125; &#125; dp[i]=maxLength+1; &#125; int maxAll=0; for (int i=0; i&lt;num; i++) &#123; if (dp[i]&gt;maxAll) &#123; maxAll=dp[i]; &#125; &#125; cout&lt;&lt;maxAll; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1038. Recover the Smallest Number (30)]]></title>
    <url>%2FPAT-1038%2F</url>
    <content type="text"><![CDATA[1038. Recover the Smallest Number (30)Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification: Each input file contains one test case. Each case gives a positive integer N (&lt;=10000) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification: For each test case, print the smallest number in one line. Do not output leading zeros. Sample Input: 15 32 321 3214 0229 87 Sample Output: 122932132143287 cmp竟然可以有a+b&lt;b+a这种字符串操作…认怂… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//bool cmp(string a, string b) &#123;// int i=0;// while (a[i]!='\0'&amp;&amp;b[i]!='\0') &#123;// if (a[i]==b[i]) &#123;// i++;// continue;// &#125; else &#123;// break;// &#125;// &#125;// return a[i]&lt;b[i];//&#125;bool cmp(string a,string b) &#123; return a+b &lt; b+a;&#125;int main() &#123; int n; cin&gt;&gt;n; vector&lt;string&gt; v(n); for (int i=0; i&lt;n; i++) &#123; string temp; cin&gt;&gt;temp; v[i]=temp; &#125; sort(v.begin(), v.end(), cmp); string s; for (int i=0; i&lt;n; i++) &#123; s+=v[i]; &#125;// for (int i=0; i&lt;s.size(); i++) &#123;// if (v[0][i]=='0') &#123;// continue;// &#125;// cout&lt;&lt;v[0][i];// &#125;// for (int i=1; i&lt;n; i++) &#123;// cout&lt;&lt;v[i];// &#125; while (s.length()&gt;0&amp;&amp;s[0]=='0') &#123; s.erase(s.begin()); &#125; if (s.length()==0) &#123; cout&lt;&lt;0; return 0; &#125; cout&lt;&lt;s; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1037. Magic Coupon (25)]]></title>
    <url>%2FPAT-1037%2F</url>
    <content type="text"><![CDATA[1037. Magic Coupon (25)The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus product… but hey, magically, they have some coupons with negative N’s! For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification: Each input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here 1&lt;= NC, NP &lt;= 105, and it is guaranteed that all the numbers will not exceed 230. Output Specification: For each test case, simply print in a line the maximum amount of money you can get back. Sample Input: 123441 2 4 -147 6 -2 -3 Sample Output: 143 采用贪心算法，却一波三折。思路转变了两次。最开始想随机组合求当前最大的积，并且维护两个标记向量来表示是否已经遍历过，最笨的方法时间复杂度为O(n^3)。运行超时一个之后改变思路，将两个向量排序，每次取两个向量最前面的没标记的两个数与最后两个数进行大小比较，取大的算入总和，取过的打上标记。可是这样依然超时，想了想时间复杂度没变，只是比刚才少了一部分遍历的操作。 换一种思路，其实将两个向量排序之后只需要把相对前面的负数与负数相乘，相对后面的正数与正数相乘，并加起来，一直到没有为止。其实最多只循环了max(numc,nump)次，也就是O(n)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; nc;vector&lt;int&gt; np;int main() &#123; int numc,nump,temp; cin&gt;&gt;numc; for (int i=0; i&lt;numc; i++) &#123; cin&gt;&gt;temp; nc.push_back(temp); &#125; cin&gt;&gt;nump; for (int i=0; i&lt;nump; i++) &#123; cin&gt;&gt;temp; np.push_back(temp); &#125;// vector&lt;int&gt; c(numc);// vector&lt;int&gt; p(nump);// memset(c, 0, sizeof(c));// memset(p, 0, sizeof(p)); sort(nc.begin(), nc.end()); sort(np.begin(), np.end()); int total=0; for (int i=0,j=0; i&lt;numc&amp;&amp;j&lt;nump; i++,j++) &#123; if (nc[i]&lt;0&amp;&amp;np[j]&lt;0) &#123; total+=nc[i]*np[j]; &#125; else &#123; break; &#125; &#125; for (int i=numc-1,j=nump-1; i&gt;=0&amp;&amp;j&gt;=0; i--,j--) &#123; if (nc[i]&gt;0&amp;&amp;np[j]&gt;0) &#123; total+=nc[i]*np[j]; &#125; else &#123; break; &#125; &#125; cout&lt;&lt;total; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1033. To Fill or Not to Fill (25)]]></title>
    <url>%2FPAT-1033%2F</url>
    <content type="text"><![CDATA[1033. To Fill or Not to Fill (25)With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification: Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space. Output Specification: For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1: 12345678950 1300 12 86.00 12507.00 6007.00 1507.10 07.20 2007.50 4007.30 10006.85 300 Sample Output 1: 1749.17 Sample Input 2: 12350 1300 12 27.10 07.00 600 Sample Output 2: 1The maximum travel distance = 1200.00 此题采用贪心算法，每次在可到达的点中挑价格最小的加油站去。其中如果有比当前更便宜的点，就加油到刚好到达下个点用完，不然就加满油。 感觉题目比较繁琐~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct station &#123; double price,dis;&#125;;bool cmp(station a,station b) &#123; return a.dis&lt;b.dis;&#125;const int inf = 99999999;int main() &#123; double tank,fullDis,disPerFuel; int stationNum; cin&gt;&gt;tank&gt;&gt;fullDis&gt;&gt;disPerFuel&gt;&gt;stationNum; vector&lt;station&gt; list(stationNum+1); list[0]=&#123;0.0,fullDis&#125;; double tempPrice,tempDis; for (int i=1; i&lt;=stationNum; i++) &#123; cin&gt;&gt;tempPrice&gt;&gt;tempDis; list[i]=&#123;tempPrice,tempDis&#125;; &#125; sort(list.begin(), list.end(), cmp); double nowDis=0,leftDis=0,maxDis,nowPrice=list[0].price,totalPrice=0; if (list[0].dis!=0) &#123; cout&lt;&lt;"The maximum travel distance = 0.00"; return 0; &#125; while (nowDis&lt;fullDis) &#123; int flag=0; maxDis=disPerFuel*tank+nowDis; //最远能到达的距离 double minPrice=inf,minDis=inf; for (int i=1; i&lt;list.size(); i++) &#123; if (list[i].dis&lt;=maxDis&amp;&amp;list[i].dis&gt;nowDis) &#123; //minDis=list[i].dis-nowDis; if (list[i].price&lt;=nowPrice) &#123; totalPrice+=(list[i].dis-nowDis-leftDis)/disPerFuel*nowPrice; nowPrice=list[i].price; nowDis=list[i].dis; leftDis=0; flag=1; &#125; if (list[i].price&lt;minPrice) &#123; minPrice=list[i].price; minDis=list[i].dis; &#125; &#125; &#125; if (flag==0&amp;&amp;minDis!=inf) &#123; totalPrice+=(tank-leftDis/disPerFuel)*nowPrice; leftDis=tank*disPerFuel-(minDis-nowDis); nowDis=minDis; nowPrice=minPrice; &#125; if (flag==0&amp;&amp;minDis==inf) &#123; cout&lt;&lt;"The maximum travel distance = "; printf("%.2lf",maxDis); return 0; &#125; &#125; printf("%.2lf",totalPrice); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1039. Course List for Student (25)]]></title>
    <url>%2FPAT-1039%2F</url>
    <content type="text"><![CDATA[1039. Course List for Student (25)Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (&lt;=40000), the number of students who look for their course lists, and K (&lt;=2500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni (&lt;= 200) are given in a line. Then in the next line, Ni student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification: For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the student’s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input: 12345678910111211 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9 Sample Output: 1234567891011ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 一个点运行超时，写的时候就想到了可能会超时，还可以优化~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; courseList[2510];vector&lt;int&gt; a;int main() &#123; int cNum,sNum; cin&gt;&gt;sNum&gt;&gt;cNum; int cNo,sNo; string stuName; for (int i=0; i&lt;cNum; i++) &#123; cin&gt;&gt;cNo&gt;&gt;sNo; for (int j=0; j&lt;sNo; j++) &#123; cin&gt;&gt;stuName; courseList[cNo].push_back(stuName); &#125; &#125; /* 每输入一个学生姓名就输出一行 */ for (int i=1; i&lt;=sNum; i++) &#123; cin&gt;&gt;stuName; /* 对于每一门课进行遍历匹配自己的名字，如果有就加到容器a里 */ for (int j=cNum; j&gt;=1; j--) &#123; for (int k=0; k&lt;courseList[j].size(); k++) &#123; if (stuName==courseList[j][k]) &#123; a.push_back(j); break; &#125; &#125; &#125; /* 输出一行 */ cout&lt;&lt;stuName&lt;&lt;" "; if (a.empty()) &#123; cout&lt;&lt;0&lt;&lt;endl; break; &#125; cout&lt;&lt;a.size(); while (!a.empty()) &#123; cout&lt;&lt;" "&lt;&lt;a.back(); a.pop_back(); &#125; cout&lt;&lt;endl; a.clear(); //清空容器a &#125; return 0;&#125; 考虑string操作耗时，于是用了hash函数，将学生名字的string转化为int存储。然而还是不够，cin&gt;&gt;string还是超时，于是将其改成scanf，AC 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=26*26*26*10;vector&lt;int&gt; studentList[maxn];int getId(char *name) &#123; int id=0; for (int i=0; i&lt;3; i++) &#123; id=id*26+name[i]-'A'; &#125; id=id*10+name[3]-'0'; return id;&#125;int main() &#123; int cNum,sNum; cin&gt;&gt;sNum&gt;&gt;cNum; int cNo,sNo; char stuName[5]; for (int i=0; i&lt;cNum; i++) &#123; cin&gt;&gt;cNo&gt;&gt;sNo; for (int j=0; j&lt;sNo; j++) &#123; scanf("%s",stuName); int id=getId(stuName); studentList[id].push_back(cNo); &#125; &#125; for (int i=0; i&lt;sNum; i++) &#123; scanf("%s",stuName); int id=getId(stuName); sort(studentList[id].begin(),studentList[id].end()); printf("%s %d",stuName,studentList[id].size()); for (int i=0; i&lt;studentList[id].size(); i++) &#123; cout&lt;&lt;" "&lt;&lt;studentList[id][i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1041. Be Unique (20)]]></title>
    <url>%2FPAT-1041%2F</url>
    <content type="text"><![CDATA[1041. Be Unique (20)Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1, 104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on 5 31 5 88 67 88 17, then the second one who bets on 31 wins. Input Specification: Each input file contains one test case. Each case contains a line which begins with a positive integer N (&lt;=105) and then followed by N bets. The numbers are separated by a space. Output Specification: For each test case, print the winning number in a line. If there is no winner, print “None” instead. Sample Input 1: 17 5 31 5 88 67 88 17 Sample Output 1: 131 Sample Input 2: 15 888 666 666 888 888 Sample Output 2: 1None 第一次运行超时 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; u;int main() &#123; int num; cin&gt;&gt;num; int temp; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;temp; u.push_back(temp); &#125; int flag=0,hasOutput=0; for (int i=0; i&lt;num; i++) &#123; for (int j=0; j&lt;num; j++) &#123; if (u[i]==u[j]&amp;&amp;i!=j) &#123; flag=1; break; &#125; &#125; if (flag==0) &#123; cout&lt;&lt;u[i]; hasOutput=1; break; &#125; flag=0; &#125; if (hasOutput==0) &#123; cout&lt;&lt;"None"; &#125; return 0;&#125; 用空间换时间，从O(n^2)变成O(n) 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int a[100001],m[100001];int main() &#123; int num; cin&gt;&gt;num; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;a[i]; m[a[i]]++; &#125; for (int i=0; i&lt;num; i++) &#123; if (m[a[i]]==1) &#123; cout&lt;&lt;a[i]; return 0; &#125; &#125; cout&lt;&lt;"None"; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1040. Longest Symmetric String (25)]]></title>
    <url>%2FPAT-1040%2F</url>
    <content type="text"><![CDATA[1040. Longest Symmetric String (25)Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given “Is PAT&amp;TAP symmetric?”, the longest symmetric sub-string is “s PAT&amp;TAP s”, hence you must output 11. Input Specification: Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification: For each test case, simply print the maximum length in a line. Sample Input: 1Is PAT&amp;TAP symmetric? Sample Output: 111 刚开始考虑的时候觉得题目是要求以一个字母为中心两侧的字母对称的最长序列长度，其实这样我只考虑了单数长度的情况，还有偶数的没考虑，分开考虑之后还是有一个点失败。这里的算法采用从前往后每一个点往两侧一格一格遍历成功一次就长度加二，理论上可行，时间复杂度o(n^2)。 过不了于是换成动态规划算法，维护一个dp的二维数组，表示从a[i]到a[j]是否是回文串，递归子问题求解。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1001][1001];int main() &#123; int max=1; string a; getline(cin, a); for (int i=0; i&lt;a.size(); i++) &#123; dp[i][i]=1; if (a[i]==a[i+1]&amp;&amp;i&lt;a.size()-1) &#123; dp[i][i+1]=1; max=2; &#125; &#125; for (int len=3; len&lt;=a.size(); len++) &#123; for (int i=0; i+len-1&lt;a.size(); i++) &#123; int j=i+len-1; if (a[i]==a[j]&amp;&amp;dp[i+1][j-1]==1) &#123; dp[i][j]=1; max=len; &#125; else &#123; dp[i][j]=0; &#125; &#125; &#125; cout&lt;&lt;max; return 0;&#125; 后面是一处错误的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main() &#123; string a; getline(cin, a); int max=1; for (int i=0; i&lt;a.length(); i++) &#123; int j=1,num=1; while (i-j&gt;=0&amp;&amp;i+j&lt;=a.size()-1) &#123; if (a[i-j]==a[i+j]) &#123; num+=2; j++; if (num&gt;max) &#123; max=num; &#125; &#125; else &#123; break; &#125; &#125; if (a[i]==a[i+1]) &#123; int j=1; num=2; while (i-j&gt;=0&amp;&amp;i+1+j&lt;=a.size()-1) &#123; if (a[i-j]==a[i+j]) &#123; num+=2; j++; if (num&gt;max) &#123; max=num; &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125; cout&lt;&lt;max; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065. A+B and C (64bit) (20)]]></title>
    <url>%2FPAT-1065%2F</url>
    <content type="text"><![CDATA[1065. A+B and C (64bit) (20)Given three integers A, B and C in [-263, 263], you are supposed to tell whether A+B &gt; C. Input Specification: The first line of the input gives the positive number of test cases, T (&lt;=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification: For each test case, output in one line “Case #X: true” if A+B&gt;C, or “Case #X: false” otherwise, where X is the case number (starting from 1). Sample Input: 123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output: 123Case #1: falseCase #2: trueCase #3: false 简单题，大数相加考虑溢出的情况。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; int num; cin&gt;&gt;num; long long a,b,c,sum; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sum=a+b; if (a&gt;0&amp;&amp;b&gt;0&amp;&amp;sum&lt;0) &#123; printf("Case #%d: true\n",i+1); &#125; else if (a&lt;0&amp;&amp;b&lt;0&amp;&amp;sum&gt;=0) &#123; printf("Case #%d: false\n",i+1); &#125; else if (sum&gt;c) &#123; printf("Case #%d: true\n",i+1); &#125; else &#123; printf("Case #%d: false\n",i+1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1064. Complete Binary Search Tree (30)]]></title>
    <url>%2FPAT-1064%2F</url>
    <content type="text"><![CDATA[1064. Complete Binary Search Tree (30)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification: For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input: 12101 2 3 4 5 6 7 8 9 0 Sample Output: 16 3 8 1 5 7 9 0 2 4 中序遍历完全二叉搜索树（CBT+BST）的结果顺序为所有节点递增排序 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,num[1001],level[1001],coun=0;void inOrder(int i) &#123; if (i&gt;n) &#123; return; &#125; /* 中序遍历 完全二叉树 */ inOrder(2*i); level[i]=num[coun++]; inOrder(2*i+1);&#125;int main() &#123; int x; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; cin&gt;&gt;x; num[i]=x; &#125; sort(num,num+n); inOrder(1); for (int i=1; i&lt;=n; i++) &#123; cout&lt;&lt;level[i]; if(i&lt;n) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1066. Root of AVL Tree (25)]]></title>
    <url>%2FPAT-1066%2F</url>
    <content type="text"><![CDATA[1066. Root of AVL Tree (25)An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, print ythe root of the resulting AVL tree in one line. Sample Input 1: 12588 70 61 96 120 Sample Output 1: 170 Sample Input 2: 12788 70 61 96 120 90 65 Sample Output 2: 188 突然兴起想研究AVL平衡树，结果就是花了两天代码还是参考网上的，不过总算是理解了。就是感觉自己对于递归的理解还是不够透彻~ 代码命名很清晰就不多加注释了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;struct node &#123; int val; struct node* left; struct node *right;&#125;;/* 左旋 */node* rotateLeft(node* root) &#123; node* t=root-&gt;right; root-&gt;right=t-&gt;left; t-&gt;left=root; return t;&#125;/* 右旋 */node* rotateRight(node* root) &#123; node* t=root-&gt;left; root-&gt;left=t-&gt;right; t-&gt;right=root; return t;&#125;/* 先左旋后右旋 */node* rotateLeftRight(node* root) &#123; root-&gt;left=rotateLeft(root-&gt;left); return rotateRight(root);&#125;/* 先右旋后左旋 */node* rotateRightLeft(node* root) &#123; root-&gt;right=rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root==NULL) &#123; return 0; &#125; else &#123; return max(getHeight(root-&gt;left), getHeight(root-&gt;right))+1; &#125;&#125;node* insert(node* root, int val) &#123; if (root==NULL) &#123; root=new node(); root-&gt;val=val; root-&gt;left=root-&gt;right=NULL; &#125; else if (val&lt;root-&gt;val) &#123; root-&gt;left=insert(root-&gt;left, val); if (getHeight(root-&gt;left)-getHeight(root-&gt;right)==2) &#123; return val&lt;root-&gt;left-&gt;val?rotateRight(root):rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right=insert(root-&gt;right, val); if (getHeight(root-&gt;left)-getHeight(root-&gt;right)==-2) &#123; return val&gt;root-&gt;right-&gt;val?rotateLeft(root):rotateRightLeft(root); &#125; &#125; return root;&#125;int main() &#123; int num; cin&gt;&gt;num; int val; node* root=NULL; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;val; root=insert(root,val); &#125; cout&lt;&lt;root-&gt;val; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1014. Waiting in Line (30)]]></title>
    <url>%2FPAT-1014%2F</url>
    <content type="text"><![CDATA[1014. Waiting in Line (30)Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (NM+1)st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customer[i] will take T[i] minutes to have his/her transaction processed. The first N customers are assumed to be served at 8:00am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer1 is served at window1 while customer2 is served at window2. Customer3 will wait in front of window1 and customer4 will wait in front of window2. Customer5 will wait behind the yellow line. At 08:01, customer1 is done and customer5 enters the line in front of window1 since that line seems shorter now. Customer2 will leave at 08:02, customer4 at 08:06, customer3 at 08:07, and finally customer5 at 08:10. Input Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (&lt;=20, number of windows), M (&lt;=10, the maximum capacity of each line inside the yellow line), K (&lt;=1000, number of customers), and Q (&lt;=1000, number of customer queries). The next line contains K positive integers, which are the processing time of the K customers. The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K. Output For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output “Sorry” instead. Sample Input 1232 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output 1234508:0708:0608:1017:00Sorry 题意是一堆人排队去银行办业务，算其中几个人个人办好的时间。 使用队列queue解决，参考柳神的算法，很妙。直接用一个结构体表示一个窗口的状态信息，其中用poptime表示队首的人离开的时间，用endtime表示队尾结束的时间，省去了许多麻烦，比如可以直接在插入一个顾客的同时得到他离开的时间result[index]即当时的endtime，在当前队列同步更新累加poptime从而选到最小的poptime进行下一次插入，用sorry这个数组来给超过下班时间的顾客打上标记。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int t[1001]=&#123;0&#125;;struct node &#123; int poptime; //队首的人离开的时间 int endtime; //队尾结束的时间 queue&lt;int&gt; q;&#125;;int main() &#123; int n,m,k,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q; for (int i=1; i&lt;=k; i++) &#123; cin&gt;&gt;t[i]; &#125; int index=1; //当前顾客编号 vector&lt;node&gt; window(n+1); vector&lt;bool&gt; sorry(k+1,false); vector&lt;int&gt; result(k+1); for (int i=1; i&lt;=m; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; if (index&lt;=k) &#123; window[j].q.push(t[index]); if (window[j].endtime&gt;=540) &#123; sorry[index]=true; &#125; window[j].endtime+=t[index]; if (i==1) &#123; window[j].poptime=t[index]; &#125; result[index]=window[j].endtime; index++; &#125; &#125; &#125; while (index&lt;=k) &#123; int tempmin=window[1].poptime,tempwindow=1; for (int i=1; i&lt;=n; i++) &#123; if (window[i].poptime&lt;tempmin) &#123; tempmin=window[i].poptime; tempwindow=i; &#125; &#125; window[tempwindow].q.pop(); window[tempwindow].q.push(t[index]); /* 最关键的一步（计算当前第一个顾客离开距离八点的时间，用来比较选择）*/ window[tempwindow].poptime+=window[tempwindow].q.front(); if (window[tempwindow].endtime&gt;=540) &#123; sorry[index]=true; &#125; window[tempwindow].endtime+=t[index]; result[index]=window[tempwindow].endtime; index++; &#125; int query; for (int i=1; i&lt;=q; i++) &#123; cin&gt;&gt;query; if (sorry[query]==true) &#123; cout&lt;&lt;"Sorry"&lt;&lt;endl; &#125; else &#123; int minute=result[query]; printf("%02d:%02d\n",(minute+480)/60,(minute+480)%60); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1013. Battle Over Cities (25)]]></title>
    <url>%2FPAT-1013%2F</url>
    <content type="text"><![CDATA[1013. Battle Over Cities (25)It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting city1-city2 and city1-city3. Then if city1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city2-city3. Input Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern. Output For each of the K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input 12343 2 31 21 31 2 3 Sample Output 123100 DFS深度优先搜索计算连通分量的个数~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int v[1001][1001]; //两城市之间是否连通，1为连通，0不连通bool visit[1001]; //是否被访问过int n; //城市个数/* DFS找到一个连通分量并返回 */void DFS(int node) &#123; visit[node]=true; for (int i=1; i&lt;=n; i++) &#123; if (visit[i]==false&amp;&amp;v[i][node]==1) &#123; DFS(i); &#125; &#125;&#125;int main() &#123; int m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int a,b; memset(v, 0, sizeof(v)); for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;a&gt;&gt;b; v[a][b]=v[b][a]=1; &#125; int city; for (int i=0; i&lt;k; i++) &#123; fill(visit, visit+1001, false); cin&gt;&gt;city; visit[city]=true; int count=0; for (int j=1; j&lt;=n; j++) &#123; if (visit[j]==false) &#123; DFS(j); count++; &#125; &#125; cout&lt;&lt;count-1&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1010. Radix (25)]]></title>
    <url>%2FPAT-1010%2F</url>
    <content type="text"><![CDATA[1010. Radix (25)Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is “yes”, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification: Each input file contains one test case. Each case occupies a line which contains 4 positive integers:N1 N2 tag radixHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number “radix” is the radix of N1 if “tag” is 1, or of N2 if “tag” is 2. Output Specification: For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print “Impossible”. If the solution is not unique, output the smallest possible radix. Sample Input 1: 16 110 1 10 Sample Output 1: 12 Sample Input 2: 11 ab 1 2 Sample Output 2: 1Impossible 我感觉这是我目前接触到最难，最有挑战性的题了。首先第一遍看完题目，只看了大概，明白这道题讲的是什么，但是却没有什么思路，思来想去摸不着头脑，于是乎找解答，有了个大概的解题思路，只是我一直不明白为什么（未知进制的）那个数的上限是根据那个数本身的大小来定，即本身大小与下限取个最大值作为上限。 解题思路是这样的：首先输入这四个数，将已知的那个数(m)转化为十进制，然后确定上下限，即找到未知进制的那个数(n)的最大一位，将其加1得到下限low，未知进制那个数(n)本身大小与下限取个最大值作为上限high。因为[low,high]是个单调区间，于是采用二分法进行查找。其中一个坑是数据的位数问题，之前采用int来存错一半，用long long 来存能多对几个，说明存在很大的数；其次，二分查找时的由mid进制转为10进制时会溢出，即long long 会溢出，直接导致num&lt;0，所以要加一个判断条件才行，最后就是我那个问题还是不懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int map[256];long long convertToTen(char a[], long long radix) &#123; long long len=strlen(a); long long ans=0; for (int i=0; i&lt;len; i++) &#123; ans=ans*radix+map[a[i]]; &#125; return ans;&#125;int findlowest(char n[]) &#123; int ans=0; long long len=strlen(n); for (int i=0; i&lt;len; i++) &#123; if (map[n[i]]&gt;ans) &#123; ans=map[n[i]]; &#125; &#125; return ans;&#125;long long binarySearch(long long left, long long right, char n[], long long t) &#123; while (left&lt;=right) &#123; long long mid=(left+right)/2; long long num=convertToTen(n, mid); if (num&gt;t||num&lt;0) &#123; right=mid-1; &#125; else if (num&lt;t) &#123; left=mid+1; &#125; else if (num==t) &#123; return mid; &#125; &#125; return -1;&#125;int main() &#123; char m[20],n[20]; int tag,radix; long long result=-1; cin&gt;&gt;m&gt;&gt;n&gt;&gt;tag&gt;&gt;radix; for (int i='0'; i&lt;='9'; i++) &#123; map[i]=i-'0'; &#125; for (int j='a'; j&lt;='z'; j++) &#123; map[j]=j-'a'+10; &#125; if (tag==2) &#123; swap(m, n); &#125; long long t=convertToTen(m,radix); long long low=findlowest(n); long long high=max(t,low)+1; result=binarySearch(low,high,n,t); if (result==-1) &#123; cout&lt;&lt;"Impossible"; &#125; else &#123; cout&lt;&lt;result; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1009. Product of Polynomials (25)]]></title>
    <url>%2FPAT-1009%2F</url>
    <content type="text"><![CDATA[1009. Product of Polynomials (25)This time, you are supposed to find A*B where A and B are two polynomials. Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output Specification: For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 13 3 3.6 2 6.0 1 1.6 又是一道多项式的题，上一次相加，这一次相乘。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main() &#123; double line[2001]=&#123;0.0&#125;; double m[1001]=&#123;0.0&#125;; int a,b; cin&gt;&gt;a; int key; double value; for (int i=0; i&lt;a; i++) &#123; cin&gt;&gt;key&gt;&gt;value; m[key]=value; &#125; cin&gt;&gt;b; for (int i=0; i&lt;b; i++) &#123; cin&gt;&gt;key&gt;&gt;value; for (int j=0; j&lt;1001; j++) &#123; line[j+key]+=m[j]*value; &#125; &#125; /* 项数 */ int count=0; for (int i=0; i&lt;2001; i++) &#123; if (line[i]!=0) &#123; count++; &#125; &#125; cout&lt;&lt;count; for (int i=2000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; printf(" %d %.1lf",i,line[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1008. Elevator (20)]]></title>
    <url>%2FPAT-1008%2F</url>
    <content type="text"><![CDATA[1008. Elevator (20)The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. Output Specification: For each test case, print the total time on a single line. Sample Input: 13 2 3 1 Sample Output: 141 简单的计算题 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b=0, now = 0, sum = 0; cin &gt;&gt; a; for(int i=0; i&lt;a; i++) &#123; cin&gt;&gt;b; if(b &gt; now) sum += 6 * (b - now); else sum += 4 * (now - b); now = b; sum += 5; &#125; cout &lt;&lt; sum; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1007. Maximum Subsequence Sum (25)]]></title>
    <url>%2FPAT-1007%2F</url>
    <content type="text"><![CDATA[1007. Maximum Subsequence Sum (25)Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification: Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space. Output Specification: For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input: 1210-10 1 2 3 4 -5 -23 3 7 -21 Sample Output: 110 1 4 初始的暴力枚举法o(n^3)我感觉是可以的，但是只AC了一个答案，不知道为什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=0,from=0,to=0; int num,tempsum=0; cin&gt;&gt;num; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; int mini1=0,i1=0,mink1=0,k1=0; for (int i=0; i&lt;num; i++/*从第i个开始*/) &#123; i1=i; for (int k=1; k&lt;=num-i; k++/*有k个*/) &#123; k1=k; for (int j=0; j&lt;k; j++) &#123; tempsum+=v[i+j]; &#125; if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=i1; to=i1+k1-1; mini1=i1; mink1=k1; &#125; else if (tempsum==maxsum) &#123; if (i1&lt;mini1) &#123; from=i1; to=i1+k1-1; &#125; &#125; tempsum=0; &#125; &#125; if (maxsum&lt;0) &#123; cout&lt;&lt;0&lt;&lt;" "&lt;&lt;0&lt;&lt;" "&lt;&lt;num-1; return 0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;from&lt;&lt;" "&lt;&lt;to; return 0;&#125; 终于找到了这傻逼的错误原因，题意看错了，要求输出一前一后俩数字而不是俩下标，也不知道是因为我看得太快还是英语太烂。。。 修改如下，但还是有问题，那就是超时~： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=0,from=0,to; int num,tempsum=0; cin&gt;&gt;num; to=num-1; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; int mini1=0,i1=0,mink1=0,k1=0; for (int i=0; i&lt;num; i++/*从第i个开始*/) &#123; i1=i; for (int k=1; k&lt;=num-i; k++/*有k个*/) &#123; k1=k; for (int j=0; j&lt;k; j++) &#123; tempsum+=v[i+j]; &#125; if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=i1; to=i1+k1-1; mini1=i1; mink1=k1; &#125; else if (tempsum==maxsum) &#123; if (i1&lt;mini1) &#123; from=i1; to=i1+k1-1; &#125; &#125; tempsum=0; &#125; &#125; if (maxsum&lt;0) &#123; cout&lt;&lt;0&lt;&lt;" "&lt;&lt;v[0]&lt;&lt;" "&lt;&lt;v[num-1]; return 0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;v[from]&lt;&lt;" "&lt;&lt;v[to]; return 0;&#125; 然后从网上找到一种o(n)的方法，根据判断前面子列和是否小于零，如小于零则只会对后面的和起反作用，所以直接舍弃。 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=-1,tempsum=0,from=0,to; int num,tempindex=0; cin&gt;&gt;num; to=num-1; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; for (int i=0; i&lt;num; i++) &#123; tempsum+=v[i]; if (tempsum&lt;0) &#123; tempsum=0; tempindex=i+1; &#125; else if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=tempindex; to=i; &#125; &#125; if (maxsum&lt;0) &#123; maxsum=0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;v[from]&lt;&lt;" "&lt;&lt;v[to]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006. Sign In and Sign Out (25)]]></title>
    <url>%2FPAT-1006%2F</url>
    <content type="text"><![CDATA[1006. Sign In and Sign Out (25)At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: 1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input: 12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output: 1SC3021234 CS301133 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int num; cin&gt;&gt;num; vector&lt;string&gt; id; //编号 vector&lt;string&gt; in; //进去时间 vector&lt;string&gt; out; //出去时间 for (int i=0; i&lt;num; i++) &#123; string temp; cin&gt;&gt;temp; id.push_back(temp); cin&gt;&gt;temp; in.push_back(temp); cin&gt;&gt;temp; out.push_back(temp); &#125; int signin_id=0; int signout_id=0; int minhour=0,minmin=0,minsec=0; int maxhour=0,maxmin=0,maxsec=0;// int minsec=0;// int maxsec=0;// string maxtime="00:00:00"; /* 先设定第一条数据为进门最早，否则初始化为零会出错 */ string temp=in[0]; minhour=(temp[0]-'0')*10+temp[1]-'0'; minmin=(temp[3]-'0')*10+temp[4]-'0'; minsec=(temp[6]-'0')*10+temp[7]-'0'; for (int i=0; i&lt;id.size(); i++) &#123; string temp=in[i]; int hour=(temp[0]-'0')*10+temp[1]-'0'; int min=(temp[3]-'0')*10+temp[4]-'0'; int sec=(temp[6]-'0')*10+temp[7]-'0';// int sumsec=hour*3600+min*60+sec; if (hour==minhour) &#123; if (min==minmin) &#123; if (sec&lt;minsec) &#123; minsec=sec; signin_id=i; &#125; &#125; else if (min&lt;minmin) &#123; minmin=min; signin_id=i; &#125; &#125; else if (hour&lt;minhour) &#123; minhour=hour; signin_id=i; &#125; temp=out[i]; hour=(temp[0]-'0')*10+temp[1]-'0'; min=(temp[3]-'0')*10+temp[4]-'0'; sec=(temp[6]-'0')*10+temp[7]-'0'; if (hour==maxhour) &#123; if (min==maxmin) &#123; if (sec&gt;maxsec) &#123; maxsec=sec; signout_id=i; &#125; &#125; else if (min&gt;maxmin) &#123; maxmin=min; signout_id=i; &#125; &#125; else if (hour&gt;maxhour) &#123; maxhour=hour; signout_id=i; &#125;// if (sumsec&lt;minsec) &#123;// minsec=sumsec;// signin_id=i;// &#125;// if (sumsec&gt;maxsec) &#123;// maxsec=sumsec;// signout_id=i;// &#125; &#125; cout&lt;&lt;id[signin_id]&lt;&lt;" "&lt;&lt;id[signout_id]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1005. Spell It Right (20)]]></title>
    <url>%2FPAT-1005%2F</url>
    <content type="text"><![CDATA[1005. Spell It Right (20)Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification: Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100). Output Specification: For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input: 112345 Sample Output: 1one five 简单题：字符串处理 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int sum=0; string a; cin&gt;&gt;a; for (int i=0; i&lt;a.length(); i++) &#123; /* 一个数字字符的ASCII码减去字符0的ASCII码等于该数字的数值 */ sum+=a[i]-'0'; &#125; string s=to_string(sum); string chinese[10]=&#123;"zero","one","two","three","four","five","six","seven","eight","nine"&#125;; for (int j=0; j&lt;s.length()-1; j++) &#123; int temp=s[j]-'0'; cout&lt;&lt;chinese[temp]&lt;&lt;" "; &#125; cout&lt;&lt;chinese[s[s.length()-1]-'0']; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004. Counting Leaves (30)]]></title>
    <url>%2FPAT-1004%2F</url>
    <content type="text"><![CDATA[1004. Counting Leaves (30)Input Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] Output For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line. Sample Input 122 101 1 02 Sample Output 10 1 BFS: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //二维数组存储所有节点int level[100]=&#123;0&#125;; //节点对应的层次int leafnum[100]=&#123;0&#125;; //存储对应深度的叶子节点个数int maxlevel=0; //最大层次void BFS() &#123; queue&lt;int&gt; q; q.push(1); level[1]=0; while (!q.empty()) &#123; int index=q.front(); q.pop(); if (node[index].size()==0) &#123; //没有叶子节点 leafnum[level[index]]++; maxlevel=max(level[index], maxlevel); &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; q.push(node[index][i]); level[node[index][i]]=level[index]+1; &#125; &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; BFS(); for (int i=0; i&lt;maxlevel; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;" "; &#125; cout&lt;&lt;leafnum[maxlevel]; return 0;&#125; DFS: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //二维数组存储所有节点//int level[100]=&#123;0&#125;;int leafnum[100]=&#123;0&#125;; //存储对应深度的叶子节点个数//int maxlevel=0;int maxdepth=0; //最大深度//void BFS() &#123;// queue&lt;int&gt; q;// q.push(1);// level[1]=0;// while (!q.empty()) &#123;//// int index=q.front();// q.pop();//// if (node[index].size()==0) &#123;// //没有叶子节点// leafnum[level[index]]++;// maxlevel=max(level[index], maxlevel);// &#125;//// for (int i=0; i&lt;node[index].size(); i++) &#123;// q.push(node[index][i]);// level[node[index][i]]=level[index]+1;// &#125;// &#125;////&#125;void DFS(int index, int depth) &#123; maxdepth=max(depth, maxdepth); if (node[index].size()==0) &#123; leafnum[depth]++; return; &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; DFS(node[index][i], depth+1); &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; DFS(1,0); for (int i=0; i&lt;maxdepth; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;" "; &#125; cout&lt;&lt;leafnum[maxdepth]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. Emergency (25)]]></title>
    <url>%2FPAT-1003%2F</url>
    <content type="text"><![CDATA[1003. Emergency (25)As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output 12 4 此题用dijastra算法搞定，搞了两天，先搞定dijastra算法，再整这个变种，参考了网上的博客写的，自己之前写的好多bug。 此处记一个C++知识点，memset函数初始化一个集合。 memset 函数是内存赋值函数，用来给某一块内存空间进行赋值的。 其原型是：void memset(void _Dst, int _Val, size_t _Size) _Dst是目标起始地址，_Val是要赋的值，_Size是要赋值的字节数。 例如代码中的 memset(mux, MAX, sizeof(mux)); 不多说，贴代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; const int MAX=1000000; const int CITY=501; int cityNum,roadNum,in,to; int rescue[CITY]; int mux[CITY][CITY]; int dis[CITY]; int amount[CITY]; int acount[CITY]; int v[MAX]; cin&gt;&gt;cityNum&gt;&gt;roadNum&gt;&gt;in&gt;&gt;to; for (int i=0; i&lt;cityNum; i++) &#123; cin&gt;&gt;rescue[i]; &#125; memset(mux, MAX, sizeof(mux)); memset(dis, MAX, sizeof(dis)); memset(v, 0, sizeof(v)); memset(amount, 0, sizeof(amount)); memset(acount, 0, sizeof(acount));// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=MAX;// for (int j=0; j&lt;cityNum; j++) &#123;// mux[i][j]=&#123;MAX&#125;;// if (i==j) &#123;// mux[i][j]=0;// &#125;// &#125;// &#125; for (int j=0; j&lt;roadNum; j++) &#123; int linka,linkb,dis; cin&gt;&gt;linka&gt;&gt;linkb&gt;&gt;dis; mux[linka][linkb]=mux[linkb][linka]=dis; &#125;// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=mux[in][i];// v[i]=0;// &#125; dis[in]=0; acount[in]=1; amount[in]=rescue[in]; v[in]=1; for (int i=1; i&lt;cityNum; i++) &#123; int u=in,min=MAX; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0&amp;&amp;dis[i]&lt;min) &#123; min=dis[i]; u=i; &#125; &#125; // if (min==MAX||u==to) &#123;// break;// &#125; v[u]=1; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0) &#123; if (dis[i]&gt;dis[u]+mux[u][i]) &#123; dis[i]=dis[u]+mux[u][i]; amount[i]=amount[u]+rescue[i]; acount[i]=acount[u]; &#125; else if (dis[i]==dis[u]+mux[u][i]) &#123; acount[i]+=acount[u]; if (amount[i]&lt;amount[u]+rescue[i]) &#123; amount[i]=amount[u]+rescue[i]; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;acount[to]&lt;&lt;" "&lt;&lt;amount[to]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. A+B for Polynomials (25)]]></title>
    <url>%2FPAT-1002%2F</url>
    <content type="text"><![CDATA[1002. A+B for Polynomials (25)This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 13 2 1.5 1 2.9 0 3.2 第二题还算是个简单题，关于多项式，是昨天AC的，今天来贴上代码。 首先是用Java写的，代码有问题，后来改用C++了 不多说，贴代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.TreeMap;public class Sum1 &#123; /** * Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner=new Scanner(System.in); int num1=scanner.nextInt(); TreeMap&lt;Integer, Double&gt; map1 = new TreeMap&lt;Integer, Double&gt;(); TreeMap&lt;Integer, Double&gt; map2 = new TreeMap&lt;Integer, Double&gt;();// Map&lt;Integer, Double&gt; map1 = Collections.synchronizedMap(m1);// Map&lt;Integer, Double&gt; map2 = Collections.synchronizedMap(m2); for (int i = 0; i &lt; num1; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map1.put(key, value); &#125; int num2=scanner.nextInt(); for (int i = 0; i &lt; num2; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map2.put(key, value); &#125; scanner.close();// synchronized (map1) &#123;// synchronized (map2) &#123;// for (int key1 : map1.keySet()) &#123;// for (int key2 : map2.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// &#125;// &#125;// &#125;// &#125;// // &#125; // for (int k2 : map2.keySet()) &#123;// for (int k1 : map1.keySet()) &#123;// if (k1==k2) &#123;// break;// &#125;// double value=map2.get(k2);// map1.put(k2, value);// &#125;// &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it1 = map1.entrySet().iterator(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it2 = map2.entrySet().iterator(); int flag = 0; while (it2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry2 = it2.next(); while (it1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry1 = it1.next(); //System.out.println(entry2.getKey()+" "+entry1.getKey()); //System.out.println(entry1.getKey().toString().equals(entry2.getKey().toString())); if (entry1.getKey().equals(entry2.getKey())) &#123; map1.remove(entry1.getKey()); map1.put(entry1.getKey(), entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); System.out.println(entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); flag=1; &#125; &#125; if (flag==0) &#123; map1.put(entry2.getKey(), entry2.getValue()); &#125; if (flag==1) &#123; flag=0; &#125; &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries1 = map1.entrySet().iterator(); while (entries1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries1.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; System.out.println(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries2 = map2.entrySet().iterator(); while (entries2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries2.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; System.out.println();// for (int key1:map1.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// break;// &#125;// map1.put(key2, map2.get(key2));// &#125; Map&lt;Integer, Double&gt; map=new TreeMap&lt;Integer, Double&gt;(Collections.reverseOrder()); map.putAll(map1); System.out.print(map.size() + " "); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; &#125;&#125; 这个我是用treemap来存储，使得其自动排序，后面用到了Collections.reverseOrder() 。 以下是C++代码： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main() &#123; // insert code here... float line[1001]=&#123;0&#125;; int count1,count2,m; int count=0; float n; cin&gt;&gt;count1; for (int i =0; i&lt;count1; i++) &#123; scanf("%d%f",&amp;m,&amp;n); line[m]+=n; &#125; cin&gt;&gt;count2; for (int i =0; i&lt;count2; i++) &#123; scanf("%d%f",&amp;m,&amp;n); line[m]+=n; &#125; for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; count++; &#125; &#125; printf("%d",count); for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; printf(" %d %.1f",i,line[i]); &#125; &#125; return 0;&#125; 感觉用C++的数组实现简单得多啊。]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001. A+B Format (20)]]></title>
    <url>%2FPAT-1001%2F</url>
    <content type="text"><![CDATA[1001. A+B Format (20)Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input 1-1000000 9 Sample Output 1-999,991 pat第一题终于编译通过了，必须要class Main才行啊 1234567891011121314151617181920212223import java.util.Scanner;class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); String sum = String.valueOf(a+b); for (int i = 0; i &lt; sum.length(); i++) &#123; System.out.print(sum.charAt(i)); if (sum.charAt(i)=='-') &#123; continue; &#125; if ((i+1)%3==sum.length()%3 &amp;&amp; i!=(sum.length()-1)) &#123; System.out.print(','); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java_dynamicProxy]]></title>
    <url>%2Fjava-dynamicProxy%2F</url>
    <content type="text"><![CDATA[Spring有两大思想，一个是Ioc,一个是AOP, AOP的原理就是java的动态代理机制，所以本篇文章就是对java的动态机制的解释。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法： 12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: 指代我们所代理的那个真实对象method: 指代的是我们所要调用真实对象的某个方法的Method对象args: 指代的是调用真实对象某个方法时接受的参数 Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法： 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 我们来通过一个实例来看看我们的动态代理模式是什么样的： 首先我们定义了一个Subject类型的接口，为其声明了两个方法： 123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; 接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject类： 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println("I want to rent my house"); &#125; @Override public void hello(String str) &#123; System.out.println("hello: " + str); &#125;&#125; 下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外： 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println("before rent house"); System.out.println("Method:" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println("after rent house"); return null; &#125;&#125; 最后，来看看我们的Client类： 1234567891011121314151617181920212223public class Client&#123; public static void main(String[] args) &#123; // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello("world"); &#125;&#125; 我们先来看看控制台的输出： 1234567891011$Proxy0before rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()I want to rent my houseafter rent housebefore rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)hello: worldafter rent house 我们首先来看看 $Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？ 1Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); 可能我以为返回的这个代理对象会是Subject类型的对象，或者是InvocationHandler的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为Subject类型的对象？原因就是在newProxyInstance这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。 同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行： 12345678910111213141516public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println("before rent house"); System.out.println("Method:" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println("after rent house"); return null; &#125; 我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的： 123public abstract void com.xiaoluo.dynamicproxy.Subject.rent()public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String) 正好就是我们的Subject接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo new之后立即打开Markdown文稿]]></title>
    <url>%2Fhexo-openPostQuick%2F</url>
    <content type="text"><![CDATA[由于每次使用hexo new新建之后都要到文件夹里自己去找出文件再打开，当文件多起来更是件麻烦事。基于此，在网上发现有直接能在新建完后自动打开markdown文档的js脚本，怀着试一试的心态按着步骤走，最后成功了。 首先安装 shelljs模块，实现自动部署加载JS脚本，键入以下命令： 1npm install --save shelljs 在 Hexo 根目录的 scripts文件夹下新建一个 js文件。此处js脚本根据hexo版本而定。我的是hexo-cli:1.0.3 稍微修改后用这个脚本成功： 12345var exec = require('child_process').exec; hexo.on('new', function(data)&#123; exec('open -a "/Applications/Typora.app" ' + [data.path]);&#125;); 最后一行里面执行的是系统命令open -a “/Applications/Typora.app” path,直接就可以在终端用命令打开，是 OS X 下的open。换到Windows中,可能需要改为start。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class类加载机制]]></title>
    <url>%2Fjvm-leijiazai%2F</url>
    <content type="text"><![CDATA[类加载过程Java类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们开始的顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 ​ 这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定： 静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。 动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。 ​ 下面详细讲述类加载过程中每个阶段所做的工作。 加载​ 加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： ​ 1、通过一个类的全限定名来获取其定义的二进制字节流。 ​ 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ​ 3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 ​ 注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。 ​ 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 ​ 加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 ​ 说到加载，不得不提到类加载器，下面就具体讲述下类加载器。 ​ 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 ​ 站在Java虚拟机的角度来讲，只存在两种不同的类加载器： 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的）,是虚拟机自身的一部分。 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 ​ 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）,开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 ​ 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点： 1）在执行非置信代码之前，自动验证数字签名。 2）动态地创建符合用户特定需要的定制化构建类。 3）从特定的场所取得java class，例如数据库中和网络中。 事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。 ​ 这几种类加载器的层次关系如下图所示： ​ 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 ​ 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 ​ 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。 验证​ 验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验）,保证不存在不符合Java语法规范的元数据信息。 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解）,主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 准备​ 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： ​ 1、这时候进行内存分配的仅包括类变量（static）,而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 ​ 2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等）,而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value = 3； ​ 那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器()方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。 ​ 下表列出了Java中所有基本数据类型以及reference类型的默认零值： 这里还需要注意如下几点： 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。 ​ 3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 假设上面的类变量value被定义为： public static final int value = 3； ​ 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。 解析 解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前）,还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 ​ 对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态）,从而避免解析动作重复进行。 ​ 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。 ​ 1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 ​ 2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示： 从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序： 1234567891011121314151617181920212223242526class Super&#123; public static int m = 11; static&#123; System.out.println("执行了super类静态语句块"); &#125;&#125;class Father extends Super&#123; public static int m = 33; static&#123; System.out.println("执行了父类静态语句块"); &#125;&#125;class Child extends Father&#123; static&#123; System.out.println("执行了子类静态语句块"); &#125;&#125;public class StaticTest&#123; public static void main(String[] args)&#123; System.out.println(Child.m); &#125;&#125; ​ 执行了super类静态语句块​ 执行了父类静态语句块​ 33​ 如果注释掉Father类中对m定义的那一行，则输出结果如下： ​ 执行了super类静态语句块​ 11 分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。 ​ 最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误： StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m都匹配​ System.out.println(Child.m);​ ^1 错误 ​ 3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 4、接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。 初始化​ 初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 这里简单说明下()方法的执行规则: ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 ​ 下面给出一个简单的例子，以便更清晰地说明如上规则： 12345678910111213141516class Father&#123; public static int a = 1; static&#123; a = 2; &#125;&#125;class Child extends Father&#123; public static int b = a;&#125;public class ClinitTest&#123; public static void main(String[] args)&#123; System.out.println(Child.b); &#125;&#125; 执行上面的代码，会打印出2，也就是说b的值被赋为了2。 ​ 我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用()方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的()方法，根据规则2，在此之前，要先执行完其父类Father的()方法，又根据规则1，在执行()方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的()方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的()方法，这样便会将b的赋值为2. ​ 如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的()方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。 ​ 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量）,在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。 总结​ 整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码）,但这里的执行代码只是个开端，它仅限于()方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class类文件结构]]></title>
    <url>%2Fjvm-classFileConstructor%2F</url>
    <content type="text"><![CDATA[Class类文件结构无关的基石Sun 公司发布了各种平台上不同的虚拟机版本,这些不同平台上的虚拟机只识别字节码文件,这种字节码文件就是构成平台无关性的基石.除了平台无关性,语言无关性也有很大的优势, Java 虚拟机不和包括 Java 在内的所有语言绑定,只与”Class 文件”这种特定的二进制文件格式所关联, Class 文件包含了 Java 虚拟机指令和符号表以及若干其他辅助信息.虚拟机不关心 Class 的来源是何种语言. Class 文件结构Class 文件采用类似 C 语言结构体的伪结构体来存储数据,这种伪结构只有两种数据类型,无符号数和表.无符号数可以描述数字,索引引用,数量值或者按照 UTF-8编码构成的字符串值.表是由无符号数或者其他表作为数据项构成的复合数据类型 魔数与 Class 文件版本每个 Class 文件的头4个字节是魔数,它的唯一作用是确定当前文件能否被虚拟机进行加载.很多文件存储格式否使用魔数来进行身份识别,使用魔数而不使用扩展名是因为扩展名随意更改.紧接着魔数后的4个字节是版本号,高版本的虚拟机能够向下兼容以前版本的 Class 文件,但不能运行以后版本的 Class 文件. 常量池常量池中有14种常量类型,每种类型都有自己的结构.由于这些常量的个数是不固定的,所以在常量池的入口放置一项 u2类型的数据,代表常量池容量计数值.虚拟机的常量池主要存放两大类常量:字面量和符号引用.字面量接近于 Java 语言层面的常量概念,如字符串,声明为 final 的常量值等.符号引用则数据编译原理方面的概念,包括:类和结构的全限定名,字段和名称的描述符,方法的名称和描述符. 访问标识在常量池结束后的两个字节代表访问标识,用于识别类或者接口的访问信息,包括:这个 Class 是类还是接口,是否定义为 public 类型,是否定义为 abstract 类型等. 类索引,父类索引与接口索引集合Class 文件由这三项来确定类的继承关系,类索引确定这个类的全限定名,父类索引确定这个类父类的全限定名,接口索引集合用来描述这个类实现了那些接口. 字段表集合字段表用来描述类或接口中声明的变量,包括类级变量以及实例级变量,但不包括方法内部声明的局部变量. 方法表集合方法表的结构如字段一样,包含了访问标识,名称索引,描述符索引几项. 属性表集合 Code 属性 当代码经过编译之后,最终字节码指令存储在 Code 属性内. Exceptions 属性 列举出方法可能抛出的受查异常 LineNumberTable 属性 描述 Java 源代码行号与字节码行号之间的关系. LocalVarableTable 属性 描述栈帧中局部变量表中的变量与 Java 源代码中定义的变量之间的关系. SourceFile 属性 记录生成这个 Class 文件的源码文件名称. ConstantValue 属性 通知虚拟机自动为静态变量赋值. InnerClasses 属性 记录内部类与宿主类之间的关联. Deprecated 及 Synthetic 属性 这两个属性都数据标志类型的布尔属性.Deprecated 用于表示某个类,字段或者方法被程序作者定位不再推荐使用.Synthetic 代表此字段或者方法并不是由 Java 源码产生的,而是由编辑器自行添加. StackMapTable 属性 一个复杂的变长属性,位于 Code 属性的属性表中.这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用,目的是代替以前比较消耗新能的基于数据流分析的类型推导验证器. Signature 属性 可以出现于类,属性表和方法表结构的属性表中,在 JDK1.5之后,任何类,接口,方法的泛型签名如果包含了类型变量或参数化类型,则 Signature 属性会记录泛型签名信息.因为 Java 语言的泛型采用擦除方法实现,在字节码中,泛型信息编译之后统统被擦除掉.使用擦除的原因是实现简单,运行期也能节省一些类型所占的内存空间,坏处是运行期无法像 C# 等有真泛型支持的语言那样,将泛型类型与用户定义的类型信息同等对待, Signature 就是为了弥补这个缺陷,如 Java 的反射 API 能够获取泛型类型,就是来源这个属性. 字节码指令简介由一个字节长度的,代表某种特定操作含义的数据以及后面的零到多个代表此操作所所需参数构成.由于Java 虚拟机面向操作数栈而不是寄存器及架构,所以大多数的指令都不包含操作数. 字节码与数据类型在 Java 虚拟机的指令集中,大多数的指令都包含了其操作所对应的数据类型信息.如: iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中. 加载与存储指令加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输.如:将一个局部变量加载到操作栈: iload将一个数值从操作数栈存储到局部变量表: istore 运算指令将两个操作数栈上的数据进行某种特定操作,并将结构重新存入操作栈顶. 类型转化指令对两个数值类型进行相互转换,一般用于实现用户代码中的显式类型转换操作. 操作数栈管理指令操作一个普通操作数据结构中的堆栈一样, Java 虚拟机提供了一些用于直接操作操作数栈的指令,包括: 将操作数栈的栈顶一个或者两个元素出栈: pop,pop2 将栈最顶端的两个数值互换: swap. 控制转移指令可以让 Java 虚拟机有条件或无条件地从指定位置指令而不是控制转移指令的下一条指令继续执行程序. 公有设计和私有设计Java 虚拟机的实现运行在满足虚拟机规范的约束下对具体实现做出修改和优化.只要优化后的 Class 文件依然可以被正确读取,实现者可以选择任何方式去实现这些语义. Class 文件结构的发展自 Class 文件发布十多年以来, Class 文件的主体结构,字节码指令的语义和数量几乎没有改动,所有的改动都集中在 访问标识,属性表这些在设计上可扩展的数据结构中添加内容.Class 文件格式锁具备的平台中立,紧凑,稳定和可扩展的特点,是 Java 技术体系实现平台无关,语言无关两项特性的重要支柱.]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Java中的组合和继承]]></title>
    <url>%2Fjicheng-and-zuhe%2F</url>
    <content type="text"><![CDATA[深入理解Java中的组合和继承前言由于感觉自己对Java基础知识有点遗忘，就找了一篇文章来巩固一下。 面向对象的复用技术复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。 作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。本文将重点介绍继承复用和组合复用。 继承继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种is-a关系。（图片来自网络，侵删。） 组合组合(Composition)体现的是整体与部分、拥有的关系，即has-a的关系。 组合与继承的区别和联系 在继承结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种白盒式代码复用。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；） 组合是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是黑盒式代码复用。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法） 继承，在写代码的时候就要指名具体继承哪个类，所以，在编译期就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。） 组合，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在运行期确定。 优缺点对比 组 合 关 系 继 承 关 系 优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立 缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性 优点：具有较好的可扩展性 缺点：支持扩展，但是往往以增加系统结构的复杂度为代价 优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象 缺点：不支持动态继承。在运行时，子类无法选择不同的父类 优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口 缺点：子类不能改变父类的接口 缺点：整体类不能自动获得和局部类同样的接口 优点：子类能自动继承父类的接口 缺点：创建整体类的对象时，需要创建所有局部类的对象 优点：创建子类的对象时，无须创建父类的对象 如何选择相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。 所以， 建议在同样可行的情况下，优先使用组合而不是继承。 因为组合更安全，更简单，更灵活，更高效。 注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。 转载自http://www.hollischuang.com/archives/1319]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm垃圾收集器与内存分配策略]]></title>
    <url>%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略垃圾回收算法引用计数算法：给对象添加一个引用计数器，每当有一个地方引用时就加1，当引用失效就减1。当引用为0时会被回收。 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路作为引用链，当一个对象没有任何引用链相联，则该对象不可达，即为可回收的对象。 GC-Roots包括： 虚拟机栈（栈帧中本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（一般为Native方法）引用的对象 标记-清除算法：首先标记所有需要回收的对象，在标记完成后统一回收所有被标记的对象 不足之处： 标记和清除两个过程效率都不高 结束后会产生大量碎片 复制算法：把内存划分为大小相等的两块，每次使用其中一块，使用的那块发生GC时将存活的对象复制到另一块，每次只对一个半区进行回收。 不足：将内存缩小为原来的一半，浪费空间 标记-整理算法：标记过程与“标记-清除算法”相同，然后将对象碎片都向一边移动，合成一个整体 再谈引用强引用：普遍存在，即Object obj = new Object(); 只要强引用还在对象就不会被回收 软引用：描述一些有用但却非必需的对象，在发生内存溢出异常之前会被回收。 弱引用：描述非必需对象，比软引用弱一些，在发生GC之前会被回收。 虚引用：最弱的引用，对于对象的生存周期无影响，也无法通过虚引用来获得对象实例。只是在对象被回收时会收到通知。 垃圾收集器Serial收集器单线程收集器，在GC时需要STW，即“Stop The World”暂停其他所有工作线程。缺点显而易见，停顿长体验差。唯一的优点是没有多余的线程开销，最高的单线程收集效率，对于分配内存较小的桌面应用（Client）停顿一般控制在几十毫秒，这是一个很好的选择。 ParNew收集器Serial的多线程版本，是许多运行在server模式下jvm首选的新生代收集器，而且除了Serial只有ParNew能与CMS收集器配合工作 并行：多个处理器上多个任务 并发：一个处理器上多个任务 Parallel Scavenge收集器多线程使用复制算法的新生代收集器，关注点与CMS等收集器尽可能缩短停顿时间不同，其目标是达到一个可控制的吞吐量（吞吐量=运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）），称为吞吐量优先收集器。 Serial Old收集器Serial老年代版本，单线程收集器，使用“标记-整理算法”。 Parallel Old收集器Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法。Parallel Scavenge + Parallel Old真正的吞吐量优先收集器。 CMS收集器基于“标记-清除”算法，过程分为四步： 初始标记 并发标记 重新标记 并发清除 其中初始标记和重新标记需要STW 缺点有三： 对CPU资源敏感，并发标记时用户线程没有暂停，收集器占用部分CPU资源，可能会使用户程序反应变慢 无法处理浮动垃圾，由于GC时用户线程还在进行，不停地会有新的垃圾产生，只能在下一次GC时处理，这部分垃圾叫做浮动垃圾 基于“标记-清除”算法，会产生大量空间碎片，导致无法找到足够大的连续空间分配而提前GC G1收集器运作步骤： 初始标记 并发标记 最终标记 筛选回收 特点： 并行与并发 分代收集（仍然保留了分代的概念） 空间整合（整体上属于“标记-整理”算法，不会导致空间碎片） 可预测的停顿（比CMS更先进的地方在于能让使用者明确指定时间片段内，消耗在垃圾收集上的时间） 内存分配策略对象优先在Eden（年轻代）分配 新生代GC（Mirror GC）：Java对象大部分都具备朝生夕灭的特性，Mirror GC非常频繁 老年代GC（Full GC）：出现Full GC常伴随着Mirror GC，比Mirror GC慢十倍以上 大对象直接进入老年代超过参数的对象直接在老年代分配 长期存活的对象将进入老年代虚拟机给每个对象定义一个对象年龄计数器，当对象在Eden出生并且熬过第一次GC进入Survivor空间，那么它的年龄即设为1，每熬过一次GC年龄就加1，达到阈值就会晋升到老年代中 对象年龄判断然而也并不是一定要到达阈值才能晋升，如果在Survivor空间相同年龄的对象的总和大于Survivor空间的一半，大于等于该年龄的对象即可直接进入老年代 空间分配担保Mirror GC之前虚拟机会检查老年代可用空间是否大于新生代所有对象大小总和，如果是，那么可以确保Mirror GC安全。如果不是的话，看是否允许担保失败（允许冒险），如果允许那么将检查老年代可用空间是否大于历次晋升对象大小的平均值，如果是的话将进行一次Mirror GC，尽管有风险会失败；如果小于那么将进行Full GC]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm之内存区域]]></title>
    <url>%2Fjvm-neicun%2F</url>
    <content type="text"><![CDATA[Java内存区域划分： 程序计数器：线程私有。当前所执行线程的行号指示器 虚拟机栈：线程私有。方法执行的同时创建一个栈帧，用于存储局部变量表（包括基本数据类型、对象引用）、操作数栈、动态链接、方法出口等。每一个方法从调用执行直到结束的过程就对应一个栈帧入栈到出栈的过程。 本地方法栈：线程私有。与虚拟机栈（为Java方法即字节码服务）类似，而本地方法栈为Native方法服务，即非Java方法（如C方法）。有些虚拟机（如HotSpot）会将虚拟机栈和本地方法栈合二为一。 堆区：所有线程共享。对象实例分配内存的地方 方法区（非堆）：所有线程共享。存储已被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据 运行时常量池：是方法区的一部分，用于存放编译期产生的各种字面量（类似于常量）和符号引用。 内存泄漏与内存溢出 内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即被分配的对象引用链可达但已无用。（可用内存减少） 内存溢出：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 内存泄露是内存溢出的一种诱因，不是唯一因素。 对象创建的堆内存分配方式 指针碰撞：内存规整无碎片时，直接划分堆尾部内存给对象。 空闲列表：有碎片时，维护一个列表记录哪些内存可用，并分配足够大的内存给对象。 对象的内存布局对象的内存布局包括： 对象头：储存对象自身运行时数据，如哈希码、GC分代年龄、线程持有锁等 实例数据：对象真正储存的有效信息 对齐填充：由于对象大小必须是8的整数倍，对象头正好是8的整数倍，如果实例数据部分没有对齐，则需要对齐成8的倍数 对象的访问定位 通过句柄访问：使用句柄访问方式，java堆将会划分出来一部分内存去来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中则包含对象实例数据的地址和对象类型数据（如对象的类型，实现的接口、方法、父类、field等）的具体地址信息。 通过直接指针访问： 如果使用指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型的相关信息（如对象的类型，实现的接口、方法、父类、field等），而reference中存储的就是对象的地址 这两种访问方式各有利弊，使用句柄访最大的好处是reference中存储着稳定的句柄地址，当对象移动之后（垃圾收集时移动对象是非常普遍的行为），只需要改变句柄中的对象实例地址即可，reference不用修改。 使用指针访问的好处是访问速度快，它减少了一次指针定位的时间开销，由于java是面向对象的语言，在开发中java对象的访问非常的频繁，因此这类开销积少成多也是非常可观的，反之则提升访问速度。对于HotSpot虚拟机来说，使用的就是直接指针访问的方式。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射的理解]]></title>
    <url>%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[首先，从动态语言讲起。像Python、Ruby这种语言，只要修改了代码，修改的效果立即生效，因为这种语言是无需编译，直接执行代码的，我们称这类语言是“动态语言”。而C++、Java这种，在运行之前需要先编译，如果中途修改了代码不重新编译去执行的话就没有变化。但是，Java有一个非常突出的动态相关机制，即反射：我们可以于运行时（区别于编译时）加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class（在这之前修改这个类即时不编译都有效），获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。 再通俗地说一下什么是反射？ 普通的Java对象是通过new关键字把对应类的字节码文件加载到内存，然后创建该对象的。 反射是通过一个名为Class的特殊类，用Class.forName(“类名”);得到类的字节码对象，然后用newInstance()方法在虚拟机内部构造这个对象（针对无参构造函数）。 也就是说反射机制让我们可以在程序运行时动态地拿到Java类对应的字节码对象（而不是在编译的时候），然后动态的进行任何可能的操作。反射的功能主要包括： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法（这样就可以修改这个对象的属性） 生成动态代理 使用反射的主要作用是方便程序的扩展，由于其运行时动态加载的特性。 Class类Java中只有2种东西不是面向对象的，一个基本类型，一个静态成员（方法、变量、常量）。我们提供的每一个类也是对象，一个类的类类型是java.lang.Class类的实例对象。 123456789101112131415161718192021// 创建类Foo的实例对象Foo foo1 = new Foo();// Foo这个类也是一个实例对象，Class类的实例对象// 任何一个类都是Class的实例对象，这个实例对象有三种表达方式// 第一种表达方式。实际上表明任何一个类都有一个隐含的静态成员变量ClassClass c1 = Foo.class;// 第二种表达方式Class c2 = foo1.getClass();// 根据官网说法，c1,c2表示了Foo类的类类型(class type)// 类也是对象，是Class类的实例对象，这个对象我们成为该类的类类型System.out.println(c1==c2) // true // 第三种表达方式Class c3 = Class.forName("Foo"); System.out.println(c1==c3) // true Class类的构造器是私有的，只能JVM能创建Class类的实例对象。 可以通过类类型 (上面的c1 c2 c3)创建Foo类的实例对象： 1Foo foo = (Foo)c1.newInstance(); 动态加载类什么是动态加载？什么是静态加载？ 静态加载的类在编译的时候就要提供，而动态加载的类在源程序编译时可以缺席。区分编译时和运行时。 Class.forName(“类名”) 这种方式，不仅表示了类的类类型，还代表了动态加载类。 用new这种方式静态加载方式，编译的时候，如果new的对象的那个类不存在的话，编译不通过；但是用Class.forName这种动态加载方式，没有这个类编译的时候不会报任何错，但是运行的时候会因为找不到这个类而报错。动态加载有什么好处呢？配合接口编程，可以实现一个接口对多种实现，从而可以动态地去选择完成不同的功能。因此，类动态加载对扩展功能很有用。 其实，动态类加载主要就是通过反射机制将类对象注入进去。 静态加载： 12345678910111213public class Office_Static &#123; public static void main(String[] args) &#123; //new 创建对象，是静态加载类，在编译时刻就需要用到Word和Excel，并将其编译 if("Word".equals(args[0]))&#123; Word w = new Word(); w.start(); &#125; if("Excel".equals(args[0]))&#123; Excel e = new Excel(); e.start(); &#125; &#125; &#125; 动态加载： 123public interface OfficeAble &#123; public void start(); &#125; 12345public class Word implements OfficeAble &#123; public void start()&#123; System.out.println("word start"); &#125; &#125; 12345public class Excel implements OfficeAble &#123; public void start()&#123; System.out.println("excel start"); &#125; &#125; 1234567891011121314public class OfficeBetter &#123; public static void main(String[] args) &#123; try &#123; //动态加载类，在运行时刻才要用这个类 Class c = Class.forName(args[0]);//在运行配置里面输入com.imooc.加载类.Excel //通过类类型，创建该类对象(先转换为Word和Excel的共同接口OfficeAble) OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通过反射动态获取对象的方法属性构造器信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.lang.reflect.Method;import java.lang.reflect.Field;import java.lang.reflect.Constructor;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * * @param obj * 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj) &#123; // 要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();// 传递的是哪个子类的对象 c就是该子类的类类型 // 获取类的名称 System.out.println("类的名称是:" + c.getName()); /* * Method类，方法对象 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();// c.getDeclaredMethods() for (int i = 0; i &lt; ms.length; i++) &#123; // 得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName() + " "); // 得到方法的名称 System.out.print(ms[i].getName() + "("); // 获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + ","); &#125; System.out.println(")"); &#125; &#125; /** * 获取成员变量的信息 * * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 java.lang.reflect.Field Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ // Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; // 得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); // 得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * * @param obj */ public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* * 构造函数也是对象 java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 getDeclaredConstructors得到所有的构造函数 */ // Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName() + "("); // 获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + ","); &#125; System.out.println(")"); &#125; &#125;&#125; 通过反射运行时动态调用对象的方法用方法对象进行反射操作，运行时动态调用一个对象的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; // 要获取print(int ,int )方法 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型 A a1 = new A(); Class c = a1.getClass(); /* * 2.获取方法 名称和参数列表来决定 getMethod获取的是public的方法 getDelcaredMethod自己声明的方法 */ try &#123; // Method m = c.getMethod("print", new // Class[]&#123;int.class,int.class&#125;); Method m = c.getMethod("print", int.class, int.class); // 方法的反射操作 // a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同 // 方法如果没有返回值返回null,有返回值返回具体的返回值 // Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); Object o = m.invoke(a1, 10, 20); System.out.println("=================="); // 获取方法print(String,String) Method m1 = c.getMethod("print", String.class, String.class); // 用方法进行反射操作 // a1.print("hello", "WORLD"); o = m1.invoke(a1, "hello", "WORLD"); System.out.println("==================="); // Method m2 = c.getMethod("print", new Class[]&#123;&#125;); Method m2 = c.getMethod("print"); // m2.invoke(a1, new Object[]&#123;&#125;); m2.invoke(a1); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class A &#123; public void print() &#123; System.out.println("helloworld"); &#125; public void print(int a, int b) &#123; System.out.println(a + b); &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125;&#125; 通过反射了解Java泛型的本质反射的操作都是编译之后的操作，反射动态加载的类是在程序运行时编译并加载的。来看看下面这个例子。 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo2&#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("hello"); //list1.add(20);错误的 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2);// 都是ArrayList的类类型，true //反射的操作都是编译之后的操作 /* * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效， * 绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try &#123; Method m = c2.getMethod("add", Object.class); m.invoke(list1, 20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) &#123; System.out.println(string); &#125;*///现在不能这样遍历 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 转载自：http://lioncruise.github.io/2016/11/29/java-reflection/]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的弱引用]]></title>
    <url>%2Fjava-reference-1%2F</url>
    <content type="text"><![CDATA[强引用(Strong Reference)强引用就是我们经常使用的引用，其写法如下 StringBuffer buffer = new StringBuffer(); 上面创建了一个StringBuffer对象，并将这个对象的（强）引用存到变量buffer中。是的，就是这个小儿科的操作（请原谅我这样的说法）。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达(Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的。 但是强引用如此之强在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然这个完全可以通过类标记成final实现。或者也可以更加复杂一些，就是通过内部包含了未知数量具体实现的工厂方法返回一个接口(Interface)。举个例子，我们想要使用一个叫做Widget的类，但是这个类不能被继承，所以无法增加新的功能。 但是我们如果想追踪Widget对象的额外信息，我们该怎么办？ 假设我们需要记录每个对象的序列号，但是由于Widget类并不包含这个属性，而且也不能扩展导致我们也不能增加这个属性。其实一点问题也没有，HashMap完全可以解决上述的问题。 serialNumberMap.put(widget, widgetSerialNumber); 这表面看上去没有问题，但是widget对象的强引用很有可能会引发问题。我们可以确信当一个widget序列号不需要时，我们应该将这个条目从map中移除。如果我们没有移除的话，可能会导致内存泄露，亦或者我们手动移除时删除了我们正在使用的widgets，会导致有效数据的丢失。其实这些问题很类似，这就是没有垃圾回收机制的语言管理内存时常遇到的问题。但是我们不用去担心这个问题，因为我们使用的时具有垃圾回收机制的Java语言。 另一个强引用可能带来的问题就是缓存,尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是做图片数据缓存，因为从磁盘加载图片代价很大，并且同时我们也想避免在内存中同时存在两份一样的图片数据。 缓存被设计的目的就是避免我们去再次加载哪些不需要的文件。你会很快发现在缓存中会一直包含一个到已经指向内存中图片数据的引用。使用强引用会强制图片数据留在内存，这就需要你来决定什么时候图片数据不需要并且手动从缓存中移除，进而可以让垃圾回收器回收。因此你再一次被强制做垃圾回收器该做的工作，并且人为决定是该清理到哪一个对象。 弱引用(Weak Reference)弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。创建弱引用如下 WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget); 使用weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现（当没有任何强引用到widget对象时）使用get时突然返回null。 解决上述的widget序列数记录的问题，最简单的办法就是使用Java内置的WeakHashMap类。WeakHashMap和HashMap几乎一样，唯一的区别就是它的键（不是值!!!）使用WeakReference引用。当WeakHashMap的键标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的Widget对象手动删除的问题。使用WeakHashMap可以很便捷地转为HashMap或者Map。 引用队列(Reference Queue)一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。 引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。 四种引用Java中实际上有四种强度不同的引用，从强到弱它们分别是，强引用，软引用，弱引用和虚引用。上面部分介绍了强引用和弱引用，下面介绍剩下的两个，软引用和虚引用。 软引用（Soft Reference）软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象。 由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。 虚引用 （Phantom Reference）与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。 当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。 虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。 第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。 使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。 显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式自我总结-1]]></title>
    <url>%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[看了一部分设计模式，自己都用一句话总结了下： 单例模式Singleton类内定义私有的构造方法，并实例化一个静态的Singleton对象（全局只有一个），于是外部只能调用你封装的getSingleton方法取得Singleton实例 工厂模式是设置一个过渡端（即工厂类）用以取得接口对应的子类类型并实例化，然后回传接口的引用到客户端（调用处，如主方法） 代理模式就是将真实类作为属性注入到代理类，然后先调用代理类的其他业务操作再调用真实类的业务 适配器模式主要用于子类只需要实现接口的一部分方法，此时设定一个适配器抽象类实现若干或者所有抽象方法（方法体为空即可）来过渡，然后子类有选择的实现一部分适配器类的方法即可]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring四种依赖注入方式]]></title>
    <url>%2Fspring-1%2F</url>
    <content type="text"><![CDATA[spring四种依赖注入方式​ ​ 平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。 ​ spring有多种依赖注入的形式，下面仅介绍spring通过xml进行IOC配置的方式： set方法注入​ 这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）： 12345678910111213package com.bless.springdemo.action;public class SpringAction &#123; //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125;&#125; ​ 随后编写spring的xml文件，中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在标签中创建一个标签指定SpringDao。标签中的name就是SpringAction类中的SpringDao属性名，ref指下面，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入： 1234567&lt;!--配置bean,配置后该类由spring管理--&gt;&lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name="springDao" ref="springDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="springDao" class="com.bless.springdemo.dao.impl.SpringDaoImpl"&gt;&lt;/bean&gt; 构造器注入​ 这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来： 12345678910111213141516public class SpringAction &#123; //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println("构造方法调用springDao和user"); &#125; public void save()&#123; user.setName("卡卡"); springDao.save(user); &#125;&#125; 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref="springDao"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref="user"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name="springDao" class="com.bless.springdemo.dao.impl.SpringDaoImpl"&gt;&lt;/bean&gt; &lt;bean name="user" class="com.bless.springdemo.vo.User"&gt;&lt;/bean&gt; ​ 解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理： ​ 下面是设置index，就是参数位置： 1234&lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;constructor-arg index="0" ref="springDao"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" ref="user"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 另一种是设置参数类型： 1&lt;constructor-arg type="java.lang.String" ref=""/&gt; 静态工厂构造​ 静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取： 123456789101112package com.bless.springdemo.factory;import com.bless.springdemo.dao.FactoryDao;import com.bless.springdemo.dao.impl.FactoryDaoImpl;import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125; ​ 同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别: 123456789101112 public class SpringAction &#123; //注入对象 private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //注入对象的set方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125; ​ Spring的IOC配置文件，注意看指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=”getStaticFactoryDaoImpl”指定调用哪个工厂方法： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction" &gt; &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt; &lt;property name="staticFactoryDao" ref="staticFactoryDao"&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name="staticFactoryDao" class="com.bless.springdemo.factory.DaoFactory" factory-method="getStaticFactoryDaoImpl"&gt;&lt;/bean&gt; 实例工厂构造​ 实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法： 123456public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125; ​ 那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象： 123456789101112public class SpringAction &#123; //注入对象 private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125; 最后看spring配置文件 123456789&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt; &lt;property name="factoryDao" ref="factoryDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name="daoFactory" class="com.bless.springdemo.factory.DaoFactory"&gt;&lt;/bean&gt; &lt;bean name="factoryDao" factory-bean="daoFactory" factory-method="getFactoryDaoImpl"&gt;&lt;/bean&gt; 总结​ Spring IOC注入方式用得最多的是(1)(2)种，多写多练就会非常熟练。 ​ 另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在标签后面添加一个属性： 1&lt;bean name="..." class="..." scope="prototype"&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运行时多态性：继承和接口的实现]]></title>
    <url>%2Fduotai-1%2F</url>
    <content type="text"><![CDATA[先插一句题外话： 继承与多态的区别 ​ 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 ​ 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 进入正题： Java运行时多态性：继承和接口的实现Java是面向对象的语言，而运行时多态性是面向对象程序设计代码重用的一个最强大机制，动态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制，下面就继承和接口实现两方面谈谈java运行时多态性的实现。 一、通过继承中超类对象引用变量引用子类对象来实现举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940//定义超类superA class superA &#123; int i = 100; void fun() &#123; System.out.println(“This is superA”); &#125;&#125;//定义superA的子类subB class subB extends superA &#123; int m = 1; void fun() &#123; System.out.println(“This is subB”); &#125;&#125;//定义superA的子类subC class subC extends superA &#123; int n = 1; void fun() &#123; System.out.println(“This is subC”); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; superA a; subB b = new subB(); subC c = new subC(); a = b; a.fun(); (1) a = c; a.fun(); (2) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940 运行结果为： 123This is subBThis is subC123 上述代码中subB和subC是超类superA的子类，我们在类Test中声明了3个引用变量a, b, c，通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。也许有人会问：“为什么(1)和(2)不输出：This is superA”。java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 所以，不要被上例中(1)和(2)所迷惑，虽然写成a.fun()，但是由于(1)中的a被b赋值，指向了子类subB的一个实例，因而(1)所调用的fun()实际上是子类subB的成员方法fun()，它覆盖了超类superA的成员方法fun()；同样(2)调用的是子类subC的成员方法fun()。 另外，如果子类继承的超类是一个抽象类，虽然抽象类不能通过new操作符实例化，但是可以创建抽象类的对象引用指向子类对象，以实现运行时多态性。具体的实现方法同上例。 不过，抽象类的子类必须覆盖实现超类中的所有的抽象方法，否则子类必须被abstract修饰符修饰，当然也就不能被实例化了。 二、通过接口类型变量引用实现接口的类的对象来实现接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的引用变量来引用实现接口的类的实例，当这个引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和上述的超类对象引用访问子类对象的机制相似。 举例说明： 1234567891011121314151617181920212223242526272829303132//定义接口InterA interface InterA&#123; void fun();&#125;//实现接口InterA的类B class B implements InterA&#123; public void fun() &#123; System.out.println(“This is B”); &#125;&#125;//实现接口InterA的类C class C implements InterA&#123; public void fun() &#123; System.out.println(“This is C”); &#125;&#125;class Test&#123; public static void main(String[] args) &#123; InterA a; a= new B(); a.fun(); a = new C(); a.fun(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132 输出结果为： 123This is BThis is C123 上例中类B和类C是实现接口InterA的两个类，分别实现了接口的方法fun()，通过将类B和类C的实例赋给接口引用a而实现了方法在运行时的动态绑定，充分利用了“一个接口，多个方法”展示了Java的动态多态性。 需要注意的一点是：Java在利用接口变量调用其实现类的对象的方法时，该方法必须已经在接口中被声明，而且在接口的实现类中该实现方法的类型和参数必须与接口中所定义的精确匹配。 结束语：以上就是java运行时多态性的实现方法，大家在编程过程中可以灵活运用，但是在性能要求较高的代码中不提倡运用运行时多态，毕竟Java的运行时动态方法调用较之普通的方法调用的系统开销是比较大的。 Java静态方法不具有多态性详解动态绑定机制使得基类的引用能够指向正确的子类对象，从而使得面向基类编程成为可能。然而动态绑定在以下两种情况会失效。 1、基类方法是private或final修饰的 这个很好理解，因为private说明该方法对子类是不可见的，子类再写一个同名的方法并不是对父类方法进行复写(Override)，而是重新生成一个新的方法，也就不存在多态的问题了。同理也可以解释final，因为方法同样是不可覆盖的。 2、方法是static修饰的 代码如下所示. 123456789101112131415161718192021222324252627class Base &#123; public static void staticMethod() &#123; System.out.println("Base staticMehtod"); &#125; public void dynamicMehtod() &#123; System.out.println("Base dynamicMehtod"); &#125;&#125;class Sub extends Base &#123; public static void staticMethod() &#123; System.out.println("Sub staticMehtod"); &#125; public void dynamicMehtod() &#123; System.out.println("Sub dynamicMehtod"); &#125;&#125;public class TJ4 &#123; public static void main(String args[]) &#123; Base c = new Sub(); c.staticMethod(); c.dynamicMehtod(); &#125;&#125;123456789101112131415161718192021222324252627 输出结果如下： 123 Base staticMehtod Sub dynamicMehtod123 输出结果并不像设想的那样，输出 “Sub staticMehtod”。因为静态方法是与类而不是与某个对象相关联，c.staticMethod();等同于Car.staticMethod(); 所以尽量不要使用实例变量去调用静态方法，避免混淆。 转载：http://blog.csdn.net/jdsjlzx/article/details/52518723]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程之使用目的]]></title>
    <url>%2Fthread-1%2F</url>
    <content type="text"><![CDATA[多线程使用的主要目的在于： 吞吐量：你做WEB，容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。如果是单线程，那同时只能处理一个用户的请求。 伸缩性：也就是说，你可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，肯定没办法通过增加CPU核数来提升性能。 鉴于做WEB的第1点可能几乎不涉及。那这里就讲第二点吧。 –举个简单的例子：假设有个请求，这个请求服务端的处理需要执行3个很缓慢的IO操作（比如数据库查询或文件查询），那么正常的顺序可能是（括号里面代表执行时间）：a、读取文件1 （10ms）b、处理1的数据（1ms）c、读取文件2 （10ms）d、处理2的数据（1ms）e、读取文件3 （10ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。那如果你在这个请求内，把ab、cd、ef分别分给3个线程去做，就只需要12ms了。 所以多线程不是没怎么用，而是，你平常要善于发现一些可优化的点。然后评估方案是否应该使用。假设还是上面那个相同的问题：但是每个步骤的执行时间不一样了。a、读取文件1 （1ms）b、处理1的数据（1ms）c、读取文件2 （1ms）d、处理2的数据（1ms）e、读取文件3 （28ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。如果还是按上面的划分方案（上面方案和木桶原理一样，耗时取决于最慢的那个线程的执行速度），在这个例子中是第三个线程，执行29ms。那么最后这个请求耗时是30ms。比起不用单线程，就节省了4ms。但是有可能线程调度切换也要花费个1、2ms。因此，这个方案显得优势就不明显了，还带来程序复杂度提升。不太值得。 那么现在优化的点，就不是第一个例子那样的任务分割多线程完成。而是优化文件3的读取速度。可能是采用缓存和减少一些重复读取。首先，假设有一种情况，所有用户都请求这个请求，那其实相当于所有用户都需要读取文件3。那你想想，100个人进行了这个请求，相当于你花在读取这个文件上的时间就是28×100=2800ms了。那么，如果你把文件缓存起来，那只要第一个用户的请求读取了，第二个用户不需要读取了，从内存取是很快速的，可能1ms都不到。 1234567891011public class MyServlet extends Servlet&#123; private static Map&lt;String, String&gt; fileName2Data = new HashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 看起来好像还不错，建立一个文件名和文件数据的映射。如果读取一个map中已经存在的数据，那么就不不用读取文件了。可是问题在于，Servlet是并发，上面会导致一个很严重的问题，死循环。因为，HashMap在并发修改的时候，可能是导致循环链表的构成！！！（具体你可以自行阅读HashMap源码）如果你没接触过多线程，可能到时候发现服务器没请求也巨卡，也不知道什么情况！好的，那就用ConcurrentHashMap，正如他的名字一样，他是一个线程安全的HashMap，这样能轻松解决问题。 1234567891011public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 这样真的解决问题了吗，这样虽然只要有用户访问过文件a，那另一个用户想访问文件a，也会从fileName2Data中拿数据，然后也不会引起死循环。 可是，如果你觉得这样就已经完了，那你把多线程也想的太简单了，骚年！你会发现，1000个用户首次访问同一个文件的时候，居然读取了1000次文件（这是最极端的，可能只有几百）。What the fuckin hell!!! 难道代码错了吗，难道我就这样过我的一生！ 好好分析下。Servlet是多线程的，那么 123456789101112public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 上面注释的“偶然”，这是完全有可能的，因此，这样做还是有问题。 因此，可以自己简单的封装一个任务来处理。 1234567891011121314151617181920212223242526272829public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, FutureTask&gt; fileName2Data = new ConcurrentHashMap&lt;String, FutureTask&gt;(); private static ExecutorService exec = Executors.newCacheThreadPool(); private void processFile3(String fName)&#123; FutureTask data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = newFutureTask(fName); FutureTask old = fileName2Data.putIfAbsent(fName, data); if(old==null)&#123; data = old; &#125;else&#123; exec.execute(data); &#125; &#125; String d = data.get(); //process with data &#125; private FutureTask newFutureTask(final String file)&#123; return new FutureTask(new Callable&lt;String&gt;()&#123; public String call()&#123; return readFromFile(file); &#125; private String readFromFile(String file)&#123;return "";&#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>muti-thread</category>
      </categories>
      <tags>
        <tag>muti-thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下安装jdk详细步骤（共两种方法）]]></title>
    <url>%2Faliyun-jdk%2F</url>
    <content type="text"><![CDATA[配置阿里云服务器时遇到一些版本问题，需要重装jdk，以下是从网上搜索的方案，我用的是第一种。 第一种方法只需要一条命令就可以安装jdk： 1yum install java-1.8.0-openjdk* -y 执行过这条命令无需配置，直接可以使用。 第二种方法1. 登录Linux，切换到root用户su root 获取root用户权限，当前工作目录不变(需要root密码)或sudo -i 不需要root密码直接切换成root（需要当前用户密码） 2. 在usr目录下建立java安装目录cd /usr //进入usr目录 mkdir java //创建java目录 3. 将jdk-8u60-linux-x64.tar.gz拷贝到java目录下cp /mnt/hgfs/linux/jdk-8u60-linux-x64.tar.gz /usr/java/ 4. 解压jdk到当前目录tar -zxvf jdk-8u60-linux-x64.tar.gz 得到文件夹 jdk1.8.0_60 5. 安装完毕为他建立一个链接以节省目录长度ln -s /usr/java/jdk1.8.0_60/ /usr/jdk 6. 编辑配置文件，配置环境变量vim /etc/profile 添加如下内容：JAVA_HOME根据实际目录来 123export JAVA_HOME=/usr/java/jdk1.8.0_60export CLASSPATH=JAVAHOME/lib/exportPATH=PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 7. 重启机器或执行命令 ：source /etc/profilesudo shutdown -r now 8. 查看安装情况1234[root@bogon jdk]# java -versionopenjdk version “1.8.0_141”OpenJDK Runtime Environment (build 1.8.0_141-b16)OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode) 12[root@bogon jdk]# javac -versionjavac 1.8.0_141 可能出现的错误信息：1bash: ./java: cannot execute binary file 出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，查看jdk版本和Linux版本位数是否一致。查看你安装的Ubuntu是32位还是64位系统： 1sudo uname –m i686 //表示是32位x86_64 // 表示是64位]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器同步MySQL数据库]]></title>
    <url>%2Fmysql-question-3%2F</url>
    <content type="text"><![CDATA[将本地文件拷贝到远程服务上的指定目录命令scp基于SSH协议，可以将本地文件拷贝到远程服务上的指定目录，格式如下： 1scp filename username@remotehost:remotedirectory 数据库创建时，无法使用“-”等特殊字符在使用mysql命令进行数据库创建时，发现“-”等特殊字符无法使用，提示sql语句语法错误。 1mysql&gt;create database tw-travel; 解决方案：数据库名加上 `` 1mysql&gt;create database `tw-travel`; Linux系统下通过命令行对mysql数据库进行备份和还原备份： 进入MySQL目录 备份 1mysqldump -u root -p密码 数据库名 数据表名 &gt; mysql.sql 还原： 建立你要还原的数据库并use database 导入sql文件 1source mysql.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改善Mac系统MySQL配置环境变量]]></title>
    <url>%2Fmysql-question-2%2F</url>
    <content type="text"><![CDATA[本地MySQL：改善Mac系统MySQL配置环境变量1.首先修改.bash_profile 文件sudo vim .bash_profile 2.加上一行配置PATH，并保存export PATH=${PATH}:/usr/local/mysql/bin3.终端输入此命令使PATH生效source .bash_profile4.此时即可用mysql -u root -p 进入MySQL，但是有一个问题就是当你重启终端时会发现又无法用该命令了，原因是当你重启时此时PATH下没有mysql，难道每次关掉终端在打开都需要重新source .bash_profile 解决方案1.终端编辑~/.zshc 文件vim ~/.zshrc 2.添加并保存export PATH=${PATH}:/usr/local/mysql/bin 3.终端source ~/.zshc 4.一劳永逸~ 附：有的文章中提到修改~/.bashrc，如果系统是zsh的修改bashrc是无效的]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL解决中文乱码之全套方案]]></title>
    <url>%2FWebEncoding%2F</url>
    <content type="text"><![CDATA[今天遇到一堆MySQL 中文乱码的问题 ，总体来说分为数据库层面，Tomcat层面，web表示层面。 数据库层面先是MySQL数据库中文乱码问题，大概样子如下： 然后自我感觉这件事情不就是改下字段的编码吗，那就改一下呗如图，我更改了Encoding 然后发现事情并没有那简单，于是开始上网查解决方案，网上说需要修改/etc/my.cnf(此配置文件对于mac后缀是.cnf，对于Windows是.ini)。所以漫漫找寻之路开始了，最后连Linux查询find语句也试了就是找不到，终于在几篇文章里查到Mac上的MySQL没有my.cnf配置文件，好吧，继续寻找解决方案，有人说MySQL下的support-file中找一个.cnf复制一下再改；里面的东西，然而我连.cnf文件都没有找到。最后采用一位网友的办法，直接在/etc目录下 vim my.cnf新建一个文件，在此附上我修改过的文件里面内容，在[mysqld] 之后增加了一行 collation-server = utf8_general_ci 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the "--help" option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 default-storage-engine = INNODB collation-server = utf8_general_ci init_connect='SET NAMES utf8' port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect='SET NAMES utf8'# Don't listen on a TCP/IP port at all. This can be a security enhancement,# if all processes that need to connect to mysqld run on the same host.# All interaction with mysqld must be made via Unix sockets or named pipes.# Note that using this option without enabling named pipes on Windows# (via the "enable-named-pipe" option) will render mysqld useless!##skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master's port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST='125.564.12.1', MASTER_PORT=3306, # MASTER_USER='joe', MASTER_PASSWORD='secret'; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables' values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout 此时保存文件，再修改文件读写权限，将权限修改为664 1sudo chmod 664 /etc/my.cnf 之后再重启MySQL和配置文件就可以生效了。然后完成之后，确实，如果你查一下MySQL的各种编码，确实都变成了UTF-8通过以下命令 然而~输入不了中文了，报错 最后将当前数据库以及所有表所有字段都设置为UTF-8 惊喜的发现可以愉快的输入中文了~~至此，数据库层面告一段落 Tomcat层面接下来我说的简略一些，如果URL请求采取GET方法，那么你的URL中可能会出现中文，所以需要在Tomcat配置文件里面设置编码方式。 修改Tomcat下的conf/server.xml文件，找到如下代码： 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 这段代码规定了Tomcat监听HTTP请求的端口号等信息。可以在这里添加一个属性：URIEncoding，将该属性值设置为UTF-8，即可让Tomcat（默认ISO-8859-1编码）以UTF-8的编码处理get请求。更改后的代码如下所示： 1234&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" URIEncoding="UTF-8" redirectPort="8443" /&gt; Web显示层面这里主要针对请求为POST方法的时候，你需要设置web.xml 文件，设置字符串过滤器 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 最后如果你要回显到页面上打印中文的话需要设置一下response如果你使用springMVC可以设置 1@RequestMapping(value = "/XX.do", produces="text/html;charset=UTF-8")]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之order]]></title>
    <url>%2Fmysql-question-1%2F</url>
    <content type="text"><![CDATA[刚测试查询订单controller时候遇到这个问题，sql语句莫名其妙的出错了 命令行实验一下操作Mysql的时候尴尬地遇到了一个问题，试了试其他表都好的，就是怎么都查询不了order表。 后来试了试改成orders表就好了，后来一想order是MySQL的一个关键字啊~ order by]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ssm框架——Mybatis版本问题解决方案（一）]]></title>
    <url>%2Fssm1%2F</url>
    <content type="text"><![CDATA[前几天搭建了ssm框架准备开发后端，今天写mapper时遇到个棘手的问题-写select语句时发现入参报错总是提示找不到username，而且错误信息里面有四个参数，而我的入参只有两个，贴出源代码和错误信息。123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; Mybatis参数问题 然后经过一番折腾在网上找到解决方案，将变量改成参数形式0，1或者加上jdbcType，代码如下 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;0&#125; and password = #&#123;1&#125; &lt;/select&gt; And 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;username, jdbcType=VARCHAR&#125; and password = #&#123;password, jdbcType=VARCHAR&#125; &lt;/select&gt; 报错同上。 此时就很难受了，看源码debug。。。偶然间查到了可能是版本问题，然后尝试了以下解决方案搞定 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; 最后贴上码云项目地址]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习]]></title>
    <url>%2Fdeeplearning%2F</url>
    <content type="text"><![CDATA[随便翻一翻在wikipedia搜索时发现这个顿时慌张起来，截图留念。这DeepLearning要学的真不是一点两点，数学没学好真的伤。]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[这才是爱情最好的样子（转载）]]></title>
    <url>%2Fhunying%2F</url>
    <content type="text"><![CDATA[和女儿一起在书店打发时间，她看书看得入迷，我在边上的小咖啡吧写稿子。天气太热，咖啡吧里人不多，有两个女士在一旁闲聊。 其中一个问：“怎么你的黑眼圈看着又大了一点啊？” 答：“这有什么办法，我老公出差了，听不到他的呼噜声我反而睡不着了。” “噗呲……”边上的那个人忍不住乐了，在边上听着的我也有点忍俊不禁。 “你不知道，我老公只要一感冒了，就会连带着他的鼻炎更严重，半夜呼噜声特别大，那个声音就是在隔壁房里睡都清晰得不得了。 但是他的呼噜声有点吓人，一声大的“呼……”上去，半天你没听到接下来的那声响动，你的心思就会随着他的声音七上八下的，担心他是不是睡厥过去了。” 这个说话的女人越说越大声：“哎呀，你都不知道，他还有呼吸骤停的毛病，医生说了最好要侧卧，不能仰卧，他那呼噜声一停，往往就是仰面朝上的睡势，我得赶紧把他推醒，叫他侧着睡。” “那这样你肯定睡不好的呀，难怪你的黑眼圈天天都那么大。” “是啊，但结婚这么多年了，你说怪不怪，他要出差不在家的时候，听不到他的呼噜声我反而更睡不着了。” 在感情的世界里兜兜转转的人大概都知道的一个定理是，这世上最牢固的感情不是“我爱你”，而是“我习惯了有你”。 世间的夫妻都大同小异，一口锅里吃饭，一张床上睡觉，周而复始的生活让原本毫不相干的人亲密地生活在一起。时间久了，居然连原本恼人的呼噜声都成了婚姻里必不可少让人心定的安全感。 我想，在生活的烟熏火燎里仍然不离不弃的两个人应该就是爱情最好的样子。 这个世上并没有什么教科书似的完美爱情，有这么一对夫妻： 他向她求婚时，只说了三个字：相信我； 她为他生下第一个女儿的时候，他对她说：辛苦了； 女儿出嫁异地那天，他搂着她的肩说：还有我； 他收到她病危通知的那天，重复地对她说：我在这； 她要走的那一刻，他亲吻她的额头轻声说：你等我。 这一生，他没对她说过一次“我爱你”，但爱，从未离开过。 从没有多余的言语，也不是甜言蜜语制造的恩爱假象。只是平凡的生活中每个细节和眼神里透露出的体贴、关心。 我想，平淡而踏实地携手走完一生的两个人应该就是好的爱情该有的样子。 他是个搞设计的工程师，她是中学毕业班的班任老师，两人都错过了恋爱的最佳季节，后来经人介绍而相识。 没有惊天动地的过程，平平淡淡地相处，自自然然地结婚。 婚后第三天，他就跑到单位加班，为了赶设计，他甚至可以彻夜拼命，连续几天几夜不回家。她忙于毕业班的管理，经常晚归。 为了各自的事业，他们就像两个陀螺，在各自的轨道上高速旋转着。 送走了毕业班，清闲了的她开始重新审视自己的生活，审视自己的婚姻，她开始迷茫，不知道自己在他心里有多重，她似乎不记得他说过爱她。 一天，她问他是不是爱她，他说当然爱，不然怎么会结婚，她问他怎么不说爱，他说不知道怎么说。 她拿出写好的离婚协议，他愣了，说，那我们去旅游吧，结婚的蜜月我都没陪你，我亏欠你太多。 他们去了奇峰异石的张家界。飘雨的天气和他们阴郁的心情一样，走在盘旋的山道上，她发现他总是走在外侧，她问他为什么，他说路太滑，他怕外侧的栅栏不牢，怕她万一不小心跌倒。 她的心忽然感到了温暖，回家就把那份离婚协议撕掉了。 很多时候，爱是埋在心底的，尤其是婚姻进行中的爱，平平淡淡，说不出来，但是真实存在。 最好的爱情是陪伴，最靠谱的感觉是温暖，我想，这应该也是爱情最好的样子。 1942年底，杨绛创作了话剧《称心如意》。在金都大戏院上演后，一鸣惊人，迅速走红。杨绛的蹿红，使大才子钱钟书坐不住了。 一天，他对杨绛说：“我想写一部长篇小说，你支持吗？”杨绛大为高兴，催他赶紧写。 杨绛让他减少授课时间，为了节省开支，她还把家里的女佣辞退了，自己包揽了所有的家务活，劈材生火做饭样样都来，经常被烟火熏得满眼是泪，也会不小心切破手指。 可是杨绛并未抱怨过，她心甘情愿地做灶下婢，只盼着钟书的大作早日问世。 看着昔日娇生惯养的富家小姐，如今修炼成任劳任怨的贤内助，钱钟书心里虽有惭愧，但更多的是对爱妻的感激与珍爱。 两年后，《围城》成功问世。钱钟书在《围城》序中说：“这本书整整写了两年。两年里忧世伤生，屡想中止。由于杨绛女士不断的督促，替我挡了许多事，省出时间来，得以锱铢积累地写完。照例这本书该献给她。” 最深的爱无需诺言，总是相依相伴中把体贴展现；最纯的情无需语言，总是默默无声里守候身边。人生的路上风雨兼程，劳碌的生活嘘寒问暖。 婚后有一回，当杨绛在看英国传记作家描述最理想的婚姻：“在见到她之前，我从来没有想过要结婚，娶了她几十年，从来没有后悔娶她，也没有想过要娶别的女人。” 当杨绛读到这里，觉得甚好，于是把它念给在一旁的钱钟书听，钱钟书听完说：“我和他一样。” 杨绛随即回答：“我也是。” 好的爱情，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。 我想，三观一致的两个人应该就是爱情里最好的样子。 张小娴说，爱情的样子就是每天跟自己喜欢的人一起，通电话，旅行，重复一个承诺和梦想，听他第二十八次提起童年往事，每年的同一天和他庆祝生日，每年的情人节、圣诞节、除夕，也和他共度。甚至连吵架也是重复的，为了一些琐事吵架，然后冷战，疯狂思念对方，最后和好。 作家十二说，爱情中最让人愉悦的样子就是“你高兴，我随意”。 那到底什么才是爱情最好的样子？ “先睡吧，明天再吵。” 听说转载要注明出处，所以]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bible of a man —— 《教父》]]></title>
    <url>%2Fjiaofu%2F</url>
    <content type="text"><![CDATA[Bible of a man 一个真正的男人必须要花出时间和家人在一起，不照顾家人的男人，根本算不上是个男人。 要学会小心，女人和小孩能够粗心大意，但男人不行]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用shadowsocks和阿里云服务器搭建从国外到国内的vpn]]></title>
    <url>%2Fvpn%2F</url>
    <content type="text"><![CDATA[刚开始看完教程感觉，哇，好简单。然而配置服务端shadowsocks文件的时候出了点小问题​ 建议把 SS 的配置文件放置在当前用户主目录下的 ss 文件夹内，对于 root 用户而言，则是：/root/ss 目录。其余用户一般则是：/home/用户名 目录。 因为服务器预装centOS 7,然后发现自己找不到root目录，更别说ss，于是，Google大法好，然而并没有找到正解。暂时告一段落，择明日再战。 之后换了个思路，先往下看呗，忽然发现这一步1nohup ssserver -c /root/ss/ssserver.json -d start &amp; 惊觉路径没关系，之后换一个就好。随后就解决了。 感谢大佬教程的帮助]]></content>
      <categories>
        <category>vpn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psychology]]></title>
    <url>%2Fpsychology%2F</url>
    <content type="text"><![CDATA[以下是看有土鳖psychology相关内容记下的笔记(纯手打) 人会在无意识的情况下模仿自己喜欢的人的动作，因为这会让她更有安全感。 多巴胺即“想要”，是生存发展的动力。 人的脑子一次只能专注于一件事情。 一个人如果开心，会更想尝试新事物；反之，希望做熟悉的事。 女生左右脑连接比男生紧密的多，左脑控制语言，右脑控制情绪，女生善用语言来表达情绪，且女生在小时候分泌雌性激素大约两年，而男生小时候大约分泌雄性激素只有八个月，所以初中之前女生语言表达理解能力会比男生强得多。 人的大脑有N1到N5的区域，男生大脑N5区域更发达，与距离、方向相关，女生N4区域更发达，与颜色、地标相关，这就能解释男女对路线描述的差异性，同时解释了为什么女生的方向感较弱。 男生的血清素分泌比女生快52%，血清素是能让人心情愉悦的物质，这就是为什么夫妻吵架，妻子气的半死而丈夫却呼呼大睡了。 男生平均一天讲七千个字，而女生一天讲两万个字。 女生比男生对表情的变化的辨识度快千分之二十秒，女生更能够发现别人表情的变化。]]></content>
      <categories>
        <category>心理学</category>
      </categories>
      <tags>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I'll always love you]]></title>
    <url>%2Falways%2F</url>
    <content type="text"><![CDATA[小爽子我爱你 by——小可可]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[create]]></title>
    <url>%2FpostName%2F</url>
    <content type="text"><![CDATA[create a blog using hexoToday,i have made this blog.And i will write essays or articles on it.]]></content>
  </entry>
</search>