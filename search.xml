<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1081. Rational Sum (20)]]></title>
    <url>%2FPAT-1081%2F</url>
    <content type="text"><![CDATA[1081. Rational Sum (20)Given N rational numbers in the form â€œnumerator/denominatorâ€, you are supposed to calculate their sum. Input Specification: Each input file contains one test case. Each case starts with a positive integer N (&lt;=100), followed in the next line N rational numbers â€œa1/b1 a2/b2 â€¦â€ where all the numerators and denominators are in the range of â€œlong intâ€. If there is a negative number, then the sign must appear in front of the numerator. Output Specification: For each test case, output the sum in the simplest form â€œinteger numerator/denominatorâ€ where â€œintegerâ€ is the integer part of the sum, â€œnumeratorâ€ &lt; â€œdenominatorâ€, and the numerator and the denominator have no common factor. You must output only the fractional part if the integer part is 0. Sample Input 1: 1252/5 4/15 1/30 -2/60 8/3 Sample Output 1: 13 1/3 Sample Input 2: 1224/3 2/3 Sample Output 2: 12 Sample Input 3: 1231/3 -1/6 1/8 Sample Output 3: 17/24 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;struct fraction &#123; long long up,down;&#125;frac[101];/* æ±‚æœ€å¤§å…¬çº¦æ•° */long long gcd(long long a,long long b) &#123; if (b==0) &#123; return a; &#125; else &#123; return gcd(b, a%b); &#125;&#125;/* åŒ–ç®€ */void simplify(long long &amp;up,long long &amp;down) &#123; if (down&lt;0) &#123; down=-down; up=-up; &#125; if (up==0) &#123; down=1; &#125; else &#123; long long d=gcd(abs(up), abs(down)); up/=d; down/=d; &#125;&#125;/* åˆ†æ•°ç›¸åŠ  */void add(fraction a,fraction &amp;temp) &#123; long long up=a.up*temp.down+temp.up*a.down; long long down=a.down*temp.down; simplify(up, down); temp.up=up; temp.down=down;&#125;int main() &#123; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%lld/%lld",&amp;frac[i].up,&amp;frac[i].down); simplify(frac[i].up, frac[i].down); &#125; fraction temp; temp.up=0;temp.down=1; for (int i=0; i&lt;n; i++) &#123; add(frac[i], temp); &#125; if (temp.down==1) &#123; printf("%lld",temp.up/temp.down); &#125; else if (abs(temp.up)&gt;temp.down) &#123; printf("%lld %lld/%lld",temp.up/temp.down,abs(temp.up)%temp.down,temp.down); &#125; else &#123; printf("%lld/%lld",temp.up,temp.down); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1104. Sum of Number Segments (20)]]></title>
    <url>%2FPAT-1104%2F</url>
    <content type="text"><![CDATA[1104. Sum of Number Segments (20)Given a sequence of positive numbers, a segment is defined to be a consecutive subsequence. For example, given the sequence {0.1, 0.2, 0.3, 0.4}, we have 10 segments: (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4). Now given a sequence, you are supposed to find the sum of all the numbers in all the segments. For the previous example, the sum of all the 10 segments is 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N, the size of the sequence which is no more than 105. The next line contains N positive numbers in the sequence, each no more than 1.0, separated by a space. Output Specification: For each test case, print in one line the sum of all the numbers in all the segments, accurate up to 2 decimal places. Sample Input: 1240.1 0.2 0.3 0.4 Sample Output: 15.00 ç›®å‰æœ€çŸ­çš„ä»£ç ã€‚ä¸æ¸…æ¥šint*doubleä¸Ždouble*intæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œsum+=m*(n-i+1)*i;è¿™è¡¨è¾¾å¼é‡Œä¸ºå•¥må¿…é¡»ä¸èƒ½æ”¾æœ€åŽ.. 123456789101112131415#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n;double m,sum=0;int main() &#123; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; scanf("%lf",&amp;m); sum+=m*(n-i+1)*i; &#125; printf("%.2lf",sum); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1069. The Black Hole of Numbers (20)]]></title>
    <url>%2FPAT-1069%2F</url>
    <content type="text"><![CDATA[1069. The Black Hole of Numbers (20)For any 4-digit integer except the ones with all the digits being the same, if we sort the digits in non-increasing order first, and then in non-decreasing order, a new number can be obtained by taking the second number from the first one. Repeat in this manner we will soon end up at the number 6174 â€“ the â€œblack holeâ€ of 4-digit numbers. This number is named Kaprekar Constant. For example, start from 6767, weâ€™ll get: 7766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174â€¦ â€¦ Given any 4-digit number, you are supposed to illustrate the way it gets into the black hole. Input Specification: Each input file contains one test case which gives a positive integer N in the range (0, 10000). Output Specification: If all the 4 digits of N are the same, print in one line the equation â€œN - N = 0000â€. Else print each step of calculation in a line until 6174 comes out as the difference. All the numbers must be printed as 4-digit numbers. Sample Input 1: 16767 Sample Output 1: 12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 Sample Input 2: 12222 Sample Output 2: 12222 - 2222 = 0000 ä¸€å¼€å§‹æ²¡è€ƒè™‘åˆ°a=6174çš„æƒ…å†µï¼Œä¸èƒ½ç”¨whileè€Œè¦ç”¨doâ€¦whileâ€¦ 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool cmp1(int a,int b) &#123; return a&gt;b;&#125;bool cmp2(int a,int b) &#123; return a&lt;b;&#125;int toNumber(int a[]) &#123; return a[0]*1000+a[1]*100+a[2]*10+a[3];&#125;void toArray(int a,int *b) &#123; for (int i=0; i&lt;4; i++) &#123; b[i]=a%10; a/=10; &#125;&#125;int a,x,y;int main() &#123; scanf("%d",&amp;a); int b[4]; do &#123; toArray(a, b); sort(b, b+4, cmp1); x=toNumber(b); sort(b, b+4, cmp2); y=toNumber(b); printf("%04d - %04d = %04d\n",x,y,x-y); a=x-y; &#125; while (a!=6174&amp;&amp;a!=0); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1101. Quick Sort (25)]]></title>
    <url>%2FPAT-1101%2F</url>
    <content type="text"><![CDATA[1101. Quick Sort (25)There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N = 5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it; 3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well; 2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well; Hence in total there are 3 pivot candidates. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;= 105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces. Output Specification: For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input: 1251 3 2 4 5 Sample Output: 1231 4 5 ä¸çŸ¥é“ä¸ºå•¥è¿™é¢˜å½“ä¸»å…ƒä¸ºé›¶çš„æ—¶å€™è¦è¾“å‡ºä¿©ç©ºæ ¼ï¼Œéš¾é“æ˜¯å› ä¸ºè¦å‡è£…ç¬¬äºŒè¡Œæœ‰è¾“å‡ºï¼Ÿ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int a[100010],leftMax[100010];vector&lt;int&gt; b;int main() &#123; int n; cin&gt;&gt;n; scanf("%d",&amp;a[0]); for (int i=1; i&lt;n; i++) &#123; scanf("%d",&amp;a[i]); leftMax[i]=max(leftMax[i-1], a[i-1]); &#125; int rightMin=999999999; if (leftMax[n-1]&lt;=a[n-1]) &#123; b.push_back(a[n-1]); &#125; for (int i=n-2; i&gt;=0; i--) &#123; rightMin=min(rightMin, a[i+1]); if (leftMax[i]&lt;=a[i]&amp;&amp;a[i]&lt;=rightMin) &#123; b.push_back(a[i]); &#125; &#125; printf("%ld\n",b.size()); if (b.size()==0) &#123; return 0; &#125; sort(b.begin(), b.end()); for (long i=0; i&lt;b.size(); i++) &#123; printf("%d",b[i]); if (i!=b.size()-1) &#123; printf(" "); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1093. Count PAT's (25)]]></title>
    <url>%2FPAT-1093%2F</url>
    <content type="text"><![CDATA[1093. Count PATâ€™s (25)The string APPAPT contains two PATâ€˜s as substrings. The first one is formed by the 2nd, the 4th, and the 6th characters, and the second one is formed by the 3rd, the 4th, and the 6th characters. Now given any string, you are supposed to tell the number of PATâ€˜s contained in the string. Input Specification: Each input file contains one test case. For each case, there is only one line giving a string of no more than 105 characters containing only P, A, or T. Output Specification: For each test case, print in one line the number of PATâ€˜s contained in the string. Since the result may be a huge number, you only have to output the result moded by 1000000007. Sample Input: 1APPAPT Sample Output: 12 æ¯ä¸€ä¸ªä½ç½®éƒ½ä¿å­˜å‰é¢æœ‰å‡ ä¸ªPåŽé¢æœ‰å‡ ä¸ªTã€‚å¯¹äºŽæ¯ä¸€ä¸ªAï¼Œå°†å‰é¢Pçš„ä¸ªæ•°ä¸ŽåŽé¢Qçš„ä¸ªæ•°ç›¸ä¹˜ï¼Œéƒ½åŠ èµ·æ¥å–æ¨¡å°±å¾—åˆ°ä¸ªæ•°äº†ã€‚ 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string str;int leftP[100001],rightT[100001];long long cnt=0;int main() &#123; getline(cin,str); for (int i=1; i&lt;str.size(); i++) &#123; if (str[i-1]=='P') &#123; leftP[i]=leftP[i-1]+1; &#125; else &#123; leftP[i]=leftP[i-1]; &#125; &#125; for (int i=str.size()-2; i&gt;=0; i--) &#123; if (str[i+1]=='T') &#123; rightT[i]=rightT[i+1]+1; &#125; else &#123; rightT[i]=rightT[i+1]; &#125; if (str[i]=='A') &#123; cnt=(cnt+rightT[i]*leftP[i])%1000000007; &#125; &#125; printf("%lld",cnt); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1029. Median (25)]]></title>
    <url>%2FPAT-1029%2F</url>
    <content type="text"><![CDATA[1029. Median (25)Given an increasing sequence S of N integers, the median is the number at the middle position. For example, the median of S1={11, 12, 13, 14} is 12, and the median of S2={9, 10, 15, 16, 17} is 15. The median of two sequences is defined to be the median of the nondecreasing sequence which contains all the elements of both sequences. For example, the median of S1 and S2 is 13. Given two increasing sequences of integers, you are asked to find their median. Input Each input file contains one test case. Each case occupies 2 lines, each gives the information of a sequence. For each sequence, the first positive integer N (&lt;=1000000) is the size of that sequence. Then N integers follow, separated by a space. It is guaranteed that all the integers are in the range of long int. Output For each test case you should output the median of the two given sequences in a line. Sample Input 124 11 12 13 145 9 10 15 16 17 Sample Output 113 è¯•è¯•æ²¡æƒ³åˆ°ç›´æŽ¥ä¸€ä¸ªsortå‡½æ•°å°±æžå®šäº†ðŸ˜‚ 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long a[2000010];int main() &#123; int n,m; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%ld",&amp;a[i]); &#125; cin&gt;&gt;m; for (int i=n; i&lt;n+m; i++) &#123; scanf("%ld",&amp;a[i]); &#125; sort(a, a+m+n); printf("%ld",*(a+(m+n-1)/2)); return 0;&#125; ç„¶åŽåˆå†™äº†ä¸€éåºåˆ—åˆå¹¶ï¼š 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long a[1000010],b[1000010],c[2000010];int main() &#123; int n,m; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%ld",&amp;a[i]); &#125; cin&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; scanf("%ld",&amp;b[i]); &#125; int l1=0,l2=0,index=0; while (l1&lt;n&amp;&amp;l2&lt;m) &#123; if (a[l1]&lt;=b[l2]) &#123; c[index++]=a[l1++]; &#125; else &#123; c[index++]=b[l2++]; &#125; &#125; while (l1&lt;n) &#123; c[index++]=a[l1++]; &#125; while (l2&lt;m) &#123; c[index++]=b[l2++]; &#125; printf("%ld",*(c+(m+n-1)/2)); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1089. Insert or Merge (25)]]></title>
    <url>%2FPAT-1089%2F</url>
    <content type="text"><![CDATA[1089. Insert or Merge (25)Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain. Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining. Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using? Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=100). Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space. Output Specification: For each test case, print in the first line either â€œInsertion Sortâ€ or â€œMerge Sortâ€ to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input 1: 123103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0 Sample Output 1: 12Insertion Sort1 2 3 5 7 8 9 4 6 0 Sample Input 2: 123103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6 Sample Output 2: 12Merge Sort1 2 3 8 4 5 7 9 0 6 æ’æŽ’è¿˜æ˜¯å½’å¹¶~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,init[101],mid[101];void insertSort(int a[], int pos) &#123; int temp=a[pos],i=pos; while (i&gt;0&amp;&amp;temp&lt;a[i-1]) &#123; a[i]=a[i-1]; i--; &#125; a[i]=temp;&#125;bool isSame(int a[], int b[]) &#123; for (int i=0; i&lt;n; i++) &#123; if (a[i]!=b[i]) &#123; return false; &#125; &#125; return true;&#125;void mergeSort(int a[]) &#123; int flag=0; for (int step=2; step&lt;=n; step*=2) &#123; for (int i=0; i&lt;n; i+=step) &#123; sort(a+i,min(a+i+step,a+n)); &#125; if (flag==1) &#123; for (int i=0; i&lt;n; i++) &#123; printf("%d",a[i]); if (i!=n-1) &#123; printf(" "); &#125; &#125; return; &#125; if (isSame(a, mid)) &#123; flag=1; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;init[i]); &#125; for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;mid[i]); &#125; int temp=0,i; for (i=0; i&lt;n; i++) &#123; if (mid[i]&lt;=mid[i+1]) &#123; continue; &#125; else &#123; temp=i+1; break; &#125; &#125; int flag=0; while (temp&lt;n) &#123; if (init[temp]==mid[temp]) &#123; temp++; continue; &#125; flag=1; break; &#125; if (flag==0) &#123; printf("Insertion Sort\n"); insertSort(mid,i+1); for (int i=0; i&lt;n; i++) &#123; printf("%d",mid[i]); if (i!=n-1) &#123; printf(" "); &#125; &#125; return 0; &#125; printf("Merge Sort\n"); mergeSort(init); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1048. Find Coins (25)]]></title>
    <url>%2FPAT-1048%2F</url>
    <content type="text"><![CDATA[1048. Find Coins (25)Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 105 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (&lt;=105, the total number of coins) and M(&lt;=103, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification: For each test case, print in one line the two face values V1 and V2 (separated by a space) such that V1 + V2 = M and V1 &lt;= V2. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output â€œNo Solutionâ€ instead. Sample Input 1: 128 151 2 8 7 2 4 11 15 Sample Output 1: 14 11 Sample Input 2: 127 141 8 7 2 4 11 15 Sample Output 2: 1No Solution è‡ªå®šä¹‰çš„æ–¹æ³•å…¨è¿‡ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,v1,v2;vector&lt;int&gt; coin;int binarySearch(int i) &#123; int left=i+1,right=n-1,mid; while (left&lt;right) &#123; mid=(left+right)/2; if (coin[mid]+coin[i]==m) &#123; return mid; &#125; else if (coin[mid]+coin[i]&gt;m) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return right;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; coin.resize(n); for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;coin[i]); &#125; sort(coin.begin(), coin.end()); for (int i=0; i&lt;n; i++) &#123; int j=binarySearch(i); if (coin[i]+coin[j]==m) &#123; printf("%d %d",coin[i],coin[j]); return 0; &#125; &#125; printf("No Solution"); return 0;&#125; upper_boundæ–¹æ³•é”™ä¸€å¤„ï¼š 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n,m,v1,v2;vector&lt;int&gt; coin;int main() &#123; cin&gt;&gt;n&gt;&gt;m; coin.resize(n); for (int i=0; i&lt;n; i++) &#123; scanf("%d",&amp;coin[i]); &#125; sort(coin.begin(), coin.end()); for (int i=0; i&lt;n; i++) &#123; vector&lt;int&gt;::iterator j=lower_bound(coin.begin()+i+1, coin.end(), m-coin[i]); if (coin[i]+*j==m&amp;&amp;j!=coin.begin()+i) &#123; printf("%d %d",coin[i],*j); return 0; &#125; &#125; printf("No Solution"); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1044. Shopping in Mars (25)]]></title>
    <url>%2FPAT-1044%2F</url>
    <content type="text"><![CDATA[1044. Shopping in Mars (25)Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options: \1. Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).\2. Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).\3. Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15). Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer. If it is impossible to pay the exact amount, you must suggest solutions with minimum lost. Input Specification: Each input file contains one test case. For each case, the first line contains 2 numbers: N (&lt;=105), the total number of diamonds on the chain, and M (&lt;=108), the amount that the customer has to pay. Then the next line contains N positive numbers D1 â€¦ DN (Di&lt;=103 for all i=1, â€¦, N) which are the values of the diamonds. All the numbers in a line are separated by a space. Output Specification: For each test case, print â€œi-jâ€ in a line for each pair of i &lt;= j such that Di + â€¦ + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i. If there is no solution, output â€œi-jâ€ for pairs of i &lt;= j such that Di + â€¦ + Dj &gt; M with (Di + â€¦ + Dj - M) minimized. Again all the solutions must be printed in increasing order of i. It is guaranteed that the total value of diamonds is sufficient to pay the given amount. Sample Input 1: 1216 153 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13 Sample Output 1: 12341-54-67-811-11 Sample Input 2: 125 132 4 5 7 9 Sample Output 2: 122-44-5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int sum[100010],n,m;vector&lt;int&gt; solution;int binarySearch(int i) &#123; int left=i,right=n,mid; while (left&lt;right) &#123; mid=(left+right)/2; int s=sum[mid]-sum[i-1]; if (s&gt;=m) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return left;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;m; sum[0]=0; for (int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;sum[i]); sum[i]+=sum[i-1]; &#125; int mins=sum[n]; for (int i=1; i&lt;=n; i++) &#123; int j,tempsum; j=binarySearch(i); tempsum=sum[j]-sum[i-1]; if (tempsum&gt;mins) &#123; continue; &#125; if (tempsum&gt;=m) &#123; if (tempsum&lt;mins) &#123; solution.clear(); mins=tempsum; &#125; solution.push_back(i); solution.push_back(j); &#125; &#125; for (int i=0; i&lt;solution.size(); i+=2) &#123; printf("%d-%d\n",solution[i],solution[i+1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1085. Perfect Sequence (25)]]></title>
    <url>%2FPAT-1085%2F</url>
    <content type="text"><![CDATA[1085. Perfect Sequence (25)Given a sequence of positive integers and another positive integer p. The sequence is said to be a â€œperfect sequenceâ€ if M &lt;= m * p where M and m are the maximum and minimum numbers in the sequence, respectively. Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence. Input Specification: Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (&lt;= 105) is the number of integers in the sequence, and p (&lt;= 109) is the parameter. In the second line there are N positive integers, each is no greater than 109. Output Specification: For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence. Sample Input: 1210 82 3 20 4 5 1 6 7 8 9 Sample Output: 18 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;long long a[100010],n,p;long long binarySearch(long long i, long long x) &#123; if (a[n-1]&lt;=x) &#123; return n; &#125; long long left=i+1,right=n-1; while (left&lt;right) &#123; long long mid=(left+right)/2; if (a[mid]&gt;x) &#123; right=mid; &#125; else &#123; left=mid+1; &#125; &#125; return left;&#125;int main() &#123; long long maxnum=0; cin&gt;&gt;n&gt;&gt;p; for (long long i=0; i&lt;n; i++) &#123; scanf("%lld",&amp;a[i]); &#125; sort(a, a+n); for (long long i=0; i&lt;n; i++) &#123; long long x=binarySearch(i, a[i]*p); maxnum=max(maxnum, x-i); &#125; cout&lt;&lt;maxnum; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1067. Sort with Swap(0,*) (25)]]></title>
    <url>%2FPAT-1067%2F</url>
    <content type="text"><![CDATA[1067. Sort with Swap(0,*) (25)Given any permutation of the numbers {0, 1, 2,â€¦, N-1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4} Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification: Each input file contains one test case, which gives a positive N (&lt;=105) followed by a permutation sequence of {0, 1, â€¦, N-1}. All the numbers in a line are separated by a space. Output Specification: For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input: 110 3 5 7 2 6 4 9 0 8 1 Sample Output: 19 ä¸¤ä¸ªæ˜“é”™ç‚¹ï¼Œæˆ‘ä¸€å¼€å§‹éƒ½é”™äº†~ å¤šæ¬¡æ¶‰åŠåˆ°æƒ³è¦çŸ¥é“æŸä¸ªæ•°æ‰€åœ¨çš„ä½ç½®ï¼Œæ¯æ¬¡éƒ½éåŽ†æ•°ç»„å¤ªéº»çƒ¦äº†ï¼Œå¹²è„†åœ¨ä¿å­˜çš„æ—¶å€™å°±ä¿å­˜æ¯ä¸ªæ•°å­—æ‰€åœ¨çš„ä½ç½®ï¼Œå³pos[i] = jè¡¨ç¤ºiæ•°å­—åœ¨jä½ç½®ï¼Œæ‰€ä»¥æ¯æ¬¡äº¤æ¢iå’Œ0åªéœ€è¦äº¤æ¢pos[i]å’Œpos[0]å°±å¥½äº† å¾ˆå®¹æ˜“è¶…æ—¶~å¦‚æžœä¸å¤„ç†ä¼šäº§ç”Ÿä¸¤ä¸ªæµ‹è¯•ç‚¹è¶…æ—¶ï¼šå½“0åœ¨0ä½æ—¶ï¼Œæ‰¾å¯»ç¬¬ä¸€ä¸ªä¸åœ¨æœ¬ä½çš„æ•°çš„æ—¶å€™ï¼Œå¦‚æžœæ¯æ¬¡éƒ½forå¾ªçŽ¯ä»Žå¤´å¼€å§‹æ‰¾ï¼Œé‚£ä¹ˆæ—¶é—´å¤æ‚åº¦ä¼šå¾ˆé«˜ï¼Œä½†æ˜¯ï¼Œæ‰¾çš„æ—¶å€™æ‰¾çš„æ˜¯ç¬¬ä¸€ä¸ªä¸åœ¨æœ¬ä½çš„æ•°ï¼Œé‚£ä¹ˆindexæ¯å‰è¿›ä¸€æ­¥éƒ½è¯´æ˜Žå‰é¢çš„æ•°å­—éƒ½æ˜¯åœ¨æœ¬ä½ä¸Šçš„ï¼Œè€Œä¸”åœ¨æœ¬ä½ä¸Šçš„æ•°æ˜¯ä¸å¯èƒ½å†äº¤æ¢å˜åŒ–çš„ï¼Œæ‰€ä»¥ç›´æŽ¥è®¾ç½®ä¸€ä¸ªindexçš„å˜é‡ï¼Œæ¯æ¬¡æ‰¾ç¬¬ä¸€ä¸ªæ•°çš„æ—¶å€™å°±å¯ä»¥ç›´æŽ¥ä»Žä¸Šä¸€æ¬¡indexå¼€å§‹æŸ¥æ‰¾ï¼Œé¿å…äº†æ¯æ¬¡éƒ½ä»Žå¤´æ‰¾ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int pos[100010]/*pos[i]=jè¡¨ç¤ºæ•°å­—iåœ¨jä½ç½®*/, n;int main() &#123; int num=0, index=1 /*ä¿å­˜ç¬¬ä¸€ä¸ªä¸åœ¨æœ¬ä½çš„æ•°å­—*/, left /*å‰©ä¸‹leftä¸ªä¸åœ¨æœ¬ä½çš„æ•°å­—*/; cin&gt;&gt;n; left=n; for (int i=0; i&lt;n; i++) &#123; int x; scanf("%d",&amp;x); pos[x]=i; if (pos[x]==x&amp;&amp;x!=0) &#123; left--; &#125; &#125; while (left&gt;0) &#123; if (pos[0]==0) &#123; left--; for (int i=index; i&lt;n; i++) &#123; if (pos[i]!=i) &#123; index=i; swap(pos[0],pos[i]); left++; num++; index=i; break; &#125; &#125; &#125; while (pos[0]!=0) &#123; swap(pos[0], pos[pos[0]]); num++; left--; break; &#125; &#125; printf("%d",num); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1070. Mooncake (25)]]></title>
    <url>%2FPAT-1070%2F</url>
    <content type="text"><![CDATA[1070. Mooncake (25)Mooncake is a Chinese bakery product traditionally eaten during the Mid-Autumn Festival. Many types of fillings and crusts can be found in traditional mooncakes according to the regionâ€™s culture. Now given the inventory amounts and the prices of all kinds of the mooncakes, together with the maximum total demand of the market, you are supposed to tell the maximum profit that can be made. Note: partial inventory storage can be taken. The sample shows the following situation: given three kinds of mooncakes with inventory amounts being 180, 150, and 100 thousand tons, and the prices being 7.5, 7.2, and 4.5 billion yuans. If the market demand can be at most 200 thousand tons, the best we can do is to sell 150 thousand tons of the second kind of mooncake, and 50 thousand tons of the third kind. Hence the total profit is 7.2 + 4.5/2 = 9.45 (billion yuans). Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers N (&lt;=1000), the number of different kinds of mooncakes, and D (&lt;=500 thousand tons), the maximum total demand of the market. Then the second line gives the positive inventory amounts (in thousand tons), and the third line gives the positive prices (in billion yuans) of N kinds of mooncakes. All the numbers in a line are separated by a space. Output Specification: For each test case, print the maximum profit (in billion yuans) in one line, accurate up to 2 decimal places. Sample Input: 1233 200180 150 1007.5 7.2 4.5 Sample Output: 19.45 è¿™é¢˜è¶…é˜´é™©çš„ï¼Œå¾ˆå®¹æ˜“æ²¡æƒ³åˆ°çš„ä¸€ç‚¹å°±æ˜¯éœ€æ±‚é‡å¯èƒ½ä¼šå¤§äºŽæ€»åº“å­˜ï¼Œçœ‹æ ·ä¾‹çš„æ—¶å€™å¾ˆå®¹æ˜“é»˜è®¤éœ€æ±‚é‡ä¼šå°ç‚¹ï¼Œå¯¼è‡´ä¸€ä¸ªç‚¹æ®µé”™è¯¯(æ•°ç»„è¶Šç•Œ). 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct cake &#123; double amount; double price,profit;&#125;c[1010];bool cmp(cake a,cake b) &#123; return a.profit&gt;b.profit;&#125;int main() &#123; int n; double d; cin&gt;&gt;n&gt;&gt;d; for (int i=0; i&lt;n; i++) &#123; scanf("%lf",&amp;c[i].amount); &#125; for (int i=0; i&lt;n; i++) &#123; scanf("%lf",&amp;c[i].price); c[i].profit=c[i].price/c[i].amount; &#125; sort(c, c+n, cmp); int i=0; double profits=0; while (d-c[i].amount&gt;0&amp;&amp;i&lt;n-1) &#123; d-=c[i].amount; profits+=c[i].price; i++; &#125; /* è€ƒè™‘éœ€æ±‚é‡è¶…å¤§çš„æƒ…å†µï¼Œå¤§äºŽæ€»åº“å­˜ */ if (d&gt;c[i].amount) &#123; profits+=c[i].price; printf("%.2lf",profits); return 0; &#125; profits+=d*c[i].profit; printf("%.2lf",profits); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1092. To Buy or Not to Buy (20)]]></title>
    <url>%2FPAT-1092%2F</url>
    <content type="text"><![CDATA[1092. To Buy or Not to Buy (20)Eva would like to make a string of beads with her favorite colors so she went to a small shop to buy some beads. There were many colorful strings of beads. However the owner of the shop would only sell the strings in whole pieces. Hence Eva must check whether a string in the shop contains all the beads she needs. She now comes to you for help: if the answer is â€œYesâ€, please tell her the number of extra beads she has to buy; or if the answer is â€œNoâ€, please tell her the number of beads missing from the string. For the sake of simplicity, letâ€™s use the characters in the ranges [0-9], [a-z], and [A-Z] to represent the colors. For example, the 3rd string in Figure 1 is the one that Eva would like to make. Then the 1st string is okay since it contains all the necessary beads with 8 extra ones; yet the 2nd one is not since there is no black bead and one less red bead. Figure 1 Input Specification: Each input file contains one test case. Each case gives in two lines the strings of no more than 1000 beads which belong to the shop owner and Eva, respectively. Output Specification: For each test case, print your answer in one line. If the answer is â€œYesâ€, then also output the number of extra beads Eva has to buy; or if the answer is â€œNoâ€, then also output the number of beads missing from the string. There must be exactly 1 space between the answer and the number. Sample Input 1: 12ppRYYGrrYBR2258YrR8RrY Sample Output 1: 1Yes 8 Sample Input 2: 12ppRYYGrrYB225YrR8RrY Sample Output 1: 1No 2 hashæ•£åˆ— 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;bool hashtable[1001]=&#123;false&#125;;int main() &#123; int havein=0,less=0; string a,b; cin&gt;&gt;a&gt;&gt;b; for (int i=0; i&lt;b.size(); i++) &#123; int flag=0; for (int j=0; j&lt;a.size(); j++) &#123; if (a[j]==b[i]&amp;&amp;!hashtable[j]) &#123; flag=1; hashtable[j]=true; havein++; break; &#125; &#125; if (flag==0) &#123; less++; &#125; &#125; if (less==0) &#123; printf("Yes %d",a.size()-havein); &#125; else &#123; printf("No %d",less); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1084. Broken Keyboard (20)]]></title>
    <url>%2FPAT-1084%2F</url>
    <content type="text"><![CDATA[1084. Broken Keyboard (20)On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen. Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out. Input Specification: Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or â€œ_â€ (representing the space). It is guaranteed that both strings are non-empty. Output Specification: For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key. Sample Input: 127_This_is_a_test_hs_s_a_es Sample Output: 17TI hashæ•£åˆ— 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=37;int hasOutput[maxn];int hash1(char a) &#123; if (a&lt;='9'&amp;&amp;a&gt;='0') &#123; return a-'0'; &#125; else if (a&gt;='A'&amp;&amp;a&lt;='Z') &#123; return a-'A'+10; &#125; else &#123; return 36; &#125;&#125;int main() &#123; int dec='a'-'A'; string b; cin&gt;&gt;b; for (int i=0; i&lt;b.size(); i++) &#123; if (b[i]&gt;='a'&amp;&amp;b[i]&lt;='z') &#123; b[i]-=dec; &#125; &#125; string op; cin&gt;&gt;op; for (int i=0; i&lt;op.size(); i++) &#123; if (op[i]&gt;='a'&amp;&amp;op[i]&lt;='z') &#123; op[i]-=dec; &#125; &#125; int value; for (int i=0; i&lt;b.size(); i++) &#123; value=hash1(b[i]); if (op.find(b[i])==-1&amp;&amp;hasOutput[value]==0) &#123; printf("%c",b[i]); hasOutput[value]=1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1028. List Sorting (25)]]></title>
    <url>%2FPAT-1028%2F</url>
    <content type="text"><![CDATA[1028. List Sorting (25)Excel can sort records according to any column. Now you are supposed to imitate this function. Input Each input file contains one test case. For each case, the first line contains two integers N (&lt;=100000) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A studentâ€™s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive). Output For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to IDâ€™s; if C = 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their IDâ€™s in increasing order. Sample Input 1 12343 1000007 James 85000010 Amy 90000001 Zoe 60 Sample Output 1 123000001 Zoe 60000007 James 85000010 Amy 90 Sample Input 2 123454 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 98 Sample Output 2 1234000010 Amy 90000002 James 98000007 James 85000001 Zoe 60 Sample Input 3 123454 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 90 Sample Output 3 1234000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct record &#123; char name[10],id[8]; int grade;&#125;r[100010];bool cmp1(record r1,record r2) &#123; return strcmp(r1.id, r2.id)&lt;0;&#125;bool cmp2(record r1,record r2) &#123; if (strcmp(r1.name, r2.name)!=0) &#123; return strcmp(r1.name, r2.name)&lt;0; &#125; return strcmp(r1.id, r2.id)&lt;0;&#125;bool cmp3(record r1,record r2) &#123; if (r1.grade!=r2.grade) &#123; return r1.grade&lt;r2.grade; &#125; return strcmp(r1.id, r2.id)&lt;0;&#125;int main() &#123; int n,c; cin&gt;&gt;n&gt;&gt;c; for (int i=0; i&lt;n; i++) &#123; scanf("%s%s%d",r[i].id,r[i].name,&amp;r[i].grade); &#125; switch (c) &#123; case 1: sort(r, r+n, cmp1); break; case 2: sort(r, r+n, cmp2); break; case 3: sort(r, r+n, cmp3); break; default: break; &#125; for (int i=0; i&lt;n; i++) &#123; printf("%s %s %d\n",r[i].id,r[i].name,r[i].grade); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1016. Phone Bills (25)]]></title>
    <url>%2FPAT-1016%2F</url>
    <content type="text"><![CDATA[1016. Phone Bills (25)A long-distance telephone company charges its customers by the following rules: Making a long-distance call costs a certain amount per minute, depending on the time of day when the call is made. When a customer starts connecting a long-distance call, the time will be recorded, and so will be the time when the customer hangs up the phone. Every calendar month, a bill is sent to the customer for each minute called (at a rate determined by the time of day). Your job is to prepare the bills for each month, given a set of phone call records. Input Specification: Each input file contains one test case. Each case has two parts: the rate structure, and the phone call records. The rate structure consists of a line with 24 non-negative integers denoting the toll (cents/minute) from 00:00 - 01:00, the toll from 01:00 - 02:00, and so on for each hour in the day. The next line contains a positive number N (&lt;= 1000), followed by N lines of records. Each phone call record consists of the name of the customer (string of up to 20 characters without space), the time and date (mm:dd:hh:mm), and the word â€œon-lineâ€ or â€œoff-lineâ€. For each test case, all dates will be within a single month. Each â€œon-lineâ€ record is paired with the chronologically next record for the same customer provided it is an â€œoff-lineâ€ record. Any â€œon-lineâ€ records that are not paired with an â€œoff-lineâ€ record are ignored, as are â€œoff-lineâ€ records not paired with an â€œon-lineâ€ record. It is guaranteed that at least one call is well paired in the input. You may assume that no two records for the same customer have the same time. Times are recorded using a 24-hour clock. Output Specification: For each test case, you must print a phone bill for each customer. Bills must be printed in alphabetical order of customersâ€™ names. For each customer, first print in a line the name of the customer and the month of the bill in the format shown by the sample. Then for each time period of a call, print in one line the beginning and ending time and date (dd:hh:mm), the lasting time (in minute) and the charge of the call. The calls must be listed in chronological order. Finally, print the total charge for the month in the format shown by the sample. Sample Input: 12345678910111210 10 10 10 10 10 20 20 20 15 15 15 15 15 15 15 20 30 20 15 15 10 10 1010CYLL 01:01:06:01 on-lineCYLL 01:28:16:05 off-lineCYJJ 01:01:07:00 off-lineCYLL 01:01:08:03 off-lineCYJJ 01:01:05:59 on-lineaaa 01:01:01:03 on-lineaaa 01:02:00:01 on-lineCYLL 01:28:15:41 on-lineaaa 01:05:02:24 on-lineaaa 01:04:23:59 off-line Sample Output: 12345678910CYJJ 0101:05:59 01:07:00 61 $12.10Total amount: $12.10CYLL 0101:06:01 01:08:03 122 $24.4028:15:41 28:16:05 24 $3.85Total amount: $28.25aaa 0102:00:01 04:23:59 4318 $638.80Total amount: $638.80 åšäº†åŠå¤©çš„é¢˜å‘Šè¯‰æˆ‘åªå¯¹äº†æ ·ä¾‹ï¼Œå…¶ä»–æ˜¯æ®µé”™è¯¯ï¼Ÿï¼Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct record &#123; char name[25]; int month,date,hour,min; int state; //0ä¸‹çº¿ 1ä¸Šçº¿&#125;r[1010];int cost[25]; //æ¯ä¸ªæ—¶é—´æ®µç”µè¯è´¹çŽ‡bool cmp(record a,record b) &#123; if (strcmp(a.name, b.name)!=0) &#123; return strcmp(a.name, b.name)&lt;0; &#125; else if (a.month!=b.month) &#123; return a.month&lt;b.month; &#125; else if (a.date!=b.date) &#123; return a.date&lt;b.date; &#125; else if (a.hour!=b.hour) &#123; return a.hour&lt;b.hour; &#125; else &#123; return a.min&lt;b.min; &#125;&#125;/* è®¡ç®—ä¸€å¤©å†…ä¸¤ä¸ªæ—¶é—´ç‚¹ä¹‹é—´èŠ±çš„é’± */double costFromHourToHour(record r1,record r2) &#123; double amount=0; int h=r1.hour; amount=(60-r1.min)*cost[h]; while (++h != r2.hour) &#123; amount+=60*cost[h]; &#125; amount+=r2.min*cost[h]; amount/=100; return amount;&#125;int main() &#123; double costAday=0; for (int i=0; i&lt;24; i++) &#123; scanf("%d",&amp;cost[i]); costAday+=60*cost[i]/100; &#125; int n; scanf("%d",&amp;n); for (int i=0; i&lt;n; i++) &#123; char s[10]; scanf("%s%d:%d:%d:%d%s",r[i].name,&amp;r[i].month,&amp;r[i].date,&amp;r[i].hour,&amp;r[i].min,s); if (strcmp(s, "on-line")==0) &#123; r[i].state=1; &#125; else &#123; r[i].state=0; &#125; &#125; sort(r, r+n, cmp); char name1[25]; //æš‚å­˜å½“å‰ç”¨æˆ·å strcpy(name1, r[0].name); int flag=0, /*flagå‰åŽä¸º1 0çš„è¯å°±è¯´æ˜Žè¿™ä¸¤æ¡è®°å½•å¯è®¡ç®—è¯è´¹*/ hasPrintName=0; double totalAmount=0; //å½“å‰ç”¨æˆ·æ€»è¯è´¹ for (int i=0; i&lt;n; i++) &#123; if (strcmp(name1, r[i].name)==0) &#123; if (hasPrintName==0) &#123; //æ²¡è¾“å‡ºè¿‡å½“å‰ç”¨æˆ·åå°±è¾“å‡º printf("%s %02d\n",r[i].name,r[i].month); hasPrintName=1; &#125; if (r[i].state==1) &#123; flag=1; &#125; else if (r[i].state==0&amp;&amp;flag==1) &#123; printf("%02d:%02d:%02d",r[i-1].date,r[i-1].hour,r[i-1].min); printf(" %02d:%02d:%02d",r[i].date,r[i].hour,r[i].min); int totalmin=((r[i].date-r[i-1].date)*24+r[i].hour-r[i-1].hour)*60+r[i].min-r[i-1].min; printf(" %d",totalmin); double amount=0.0; //å½“å‰æ—¶é—´æ®µçš„è¯è´¹ if (r[i].date!=r[i-1].date) &#123; int d=r[i-1].date; record rec; rec.hour=23;rec.min=60; amount+=costFromHourToHour(r[i-1],rec); while (++d != r[i].date) &#123; amount+=costAday; &#125; rec.hour=0;rec.min=0; amount+=costFromHourToHour(rec,r[i]); &#125; else &#123; amount=costFromHourToHour(r[i-1],r[i]); &#125; printf(" $%.2lf\n",amount); totalAmount+=amount; flag=0; &#125; &#125; else &#123; strcpy(name1, r[i].name); hasPrintName=0; if (r[i].state==1) &#123; flag=1; &#125; if (totalAmount!=0) &#123; printf("Total amount: $%.2lf\n",totalAmount); &#125; totalAmount=0; &#125; &#125; if (totalAmount!=0) &#123; printf("Total amount: $%.2lf\n",totalAmount); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1062. Talent and Virtue (25)]]></title>
    <url>%2FPAT-1062%2F</url>
    <content type="text"><![CDATA[1062. Talent and Virtue (25)About 900 years ago, a Chinese philosopher Sima Guang wrote a history book in which he talked about peopleâ€™s talent and virtue. According to his theory, a man being outstanding in both talent and virtue must be a â€œsageï¼ˆåœ£äººï¼‰â€; being less excellent but with oneâ€™s virtue outweighs talent can be called a â€œnoblemanï¼ˆå›å­ï¼‰â€; being good in neither is a â€œfool manï¼ˆæ„šäººï¼‰â€; yet a fool man is better than a â€œsmall manï¼ˆå°äººï¼‰â€ who prefers talent than virtue. Now given the grades of talent and virtue of a group of people, you are supposed to rank them according to Sima Guangâ€™s theory. Input Specification: Each input file contains one test case. Each case first gives 3 positive integers in a line: N (&lt;=105), the total number of people to be ranked; L (&gt;=60), the lower bound of the qualified grades â€“ that is, only the ones whose grades of talent and virtue are both not below this line will be ranked; and H (&lt;100), the higher line of qualification â€“ that is, those with both grades not below this line are considered as the â€œsagesâ€, and will be ranked in non-increasing order according to their total grades. Those with talent grades below H but virtue grades not are cosidered as the â€œnoblemenâ€, and are also ranked in non-increasing order according to their total grades, but they are listed after the â€œsagesâ€. Those with both grades below H, but with virtue not lower than talent are considered as the â€œfool menâ€. They are ranked in the same way but after the â€œnoblemenâ€. The rest of people whose grades both pass the L line are ranked after the â€œfool menâ€. Then N lines follow, each gives the information of a person in the format: 1ID_Number Virtue_Grade Talent_Grade Output Specification: The first line of output must give M (&lt;=N), the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output in increasing order of their IDâ€™s. Sample Input: 12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 Sample Output: 123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 ç»“æž„ä½“æŽ’åº 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;struct people &#123; int id; int v_grade,t_grade,totalgrade; int flag; int rank;&#125;p[100010];bool cmp(people a,people b) &#123; if (a.rank!=b.rank) &#123; return a.rank&lt;b.rank; &#125; else if (a.totalgrade!=b.totalgrade) &#123; return a.totalgrade&gt;b.totalgrade; &#125; else if (a.v_grade!=b.v_grade) &#123; return a.v_grade&gt;b.v_grade; &#125; return a.id&lt;b.id;&#125;int main() &#123; int n,l,h,num=0; cin&gt;&gt;n&gt;&gt;l&gt;&gt;h; for (int i=0; i&lt;n; i++) &#123; scanf("%d%d%d",&amp;p[i].id,&amp;p[i].v_grade,&amp;p[i].t_grade); p[i].totalgrade=p[i].v_grade+p[i].t_grade; if (p[i].v_grade&lt;l||p[i].t_grade&lt;l) &#123; p[i].flag=1; //ä¸ä¼šè¢«æŽ’å continue; &#125; if (p[i].v_grade&gt;=h&amp;&amp;p[i].t_grade&gt;=h) &#123; p[i].rank=1; //åœ£äºº &#125; else if (p[i].v_grade&gt;=h&amp;&amp;p[i].t_grade&lt;h) &#123; p[i].rank=2; //å›å­ &#125; else if (p[i].v_grade&gt;=p[i].t_grade&amp;&amp;p[i].v_grade&lt;h&amp;&amp;p[i].t_grade&lt;h) &#123; p[i].rank=3; //æ„šäºº &#125; else &#123; p[i].rank=4; //å‰©ä¸‹çš„äºº &#125; num++; &#125; cout&lt;&lt;num&lt;&lt;endl; sort(p, p+n, cmp); for (int i=0; i&lt;n; i++) &#123; if (p[i].flag==0) &#123; printf("%d %d %d\n",p[i].id,p[i].v_grade,p[i].t_grade); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1025. PAT Ranking (25)]]></title>
    <url>%2FPAT-1025%2F</url>
    <content type="text"><![CDATA[1025. PAT Ranking (25)Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification: Each input file contains one test case. For each case, the first line contains a positive number N (&lt;=100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (&lt;=300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification: For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: registration_number final_rank location_number local_rank The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input: 123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 Sample Output: 1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 ä¼°è®¡æ˜¯é¢å‘çŽ„å­¦ç¼–ç¨‹ï¼Œæœ€åŽä¸€ä¸ªç‚¹æ€Žä¹ˆä¼šè¿‡ä¸äº†å‘¢ï¼Œæ•°å­—å¾ˆå¤§çš„æƒ…å†µä¹Ÿéƒ½è€ƒè™‘äº†å‘€â€¦ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; long long int id; int grade,locationNum,localrank,finalrank;&#125;stu[30001];bool cmp(student a,student b) &#123; if (a.grade!=b.grade) &#123; return a.grade&gt;b.grade; &#125; return a.id&lt;b.id;&#125;int main() &#123; int n,k,num=0; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;k; for (int j=num; j&lt;num+k; j++) &#123; scanf("%lld%d",&amp;stu[j].id,&amp;stu[j].grade); stu[j].locationNum=i; &#125; sort(stu+num, stu+num+k, cmp); stu[num].localrank=1; for (int j=1; j&lt;=k-1; j++) &#123; if (stu[num+j].grade==stu[num+j-1].grade) &#123; stu[num+j].localrank=stu[num+j-1].localrank; &#125; else &#123; stu[num+j].localrank=j+1; &#125; &#125; num+=k; &#125; printf("%d\n",num); sort(stu, stu+num, cmp); if (num!=0) &#123; stu[0].finalrank=1; printf("%lld %d %d %d\n",stu[0].id,stu[0].finalrank,stu[0].locationNum,stu[0].localrank); &#125; for (int j=1; j&lt;num; j++) &#123; if (stu[j].grade==stu[j-1].grade) &#123; stu[j].finalrank=stu[j-1].finalrank; &#125; else &#123; stu[j].finalrank=j+1; &#125; printf("%013lld %d %d %d\n",stu[j].id,stu[j].finalrank,stu[j].locationNum,stu[j].localrank); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1082. Read Number in Chinese (25)]]></title>
    <url>%2FPAT-1082%2F</url>
    <content type="text"><![CDATA[1082. Read Number in Chinese (25)Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output â€œFuâ€ first if it is negative. For example, -123456789 is read as â€œFu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiuâ€. Note: zero (â€œlingâ€) must be handled correctly according to the Chinese tradition. For example, 100800 is â€œyi Shi Wan ling ba Baiâ€. Input Specification: Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification: For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1: 1-123456789 Sample Output 1: 1Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2: 1100800 Sample Output 2: 1yi Shi Wan ling ba Bai è¿™ä¸ªé¢˜ç›®çœŸå¿ƒéº»çƒ¦ï¼ŒæŒºå˜æ€çš„ã€‚ä¸€å¼€å§‹éƒ½æƒ³ä»Žlength=1åˆ°9åˆ†ç±»æžšä¸¾ç®—äº†ï¼Œæœºåˆ¶å¿’å¤æ‚~ä¸»è¦è¿˜æ˜¯å› ä¸ºæˆ‘å¤§ä¸­åŽæ–‡å­—åšå¤§ç²¾æ·±ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char num[10][5]=&#123;"ling","yi","er","san","si","wu","liu","qi","ba","jiu"&#125;;char wei[5][5]=&#123;"Shi","Bai","Qian","Wan","Yi"&#125;;int main() &#123; char a[11]; scanf("%s",a); int len,left=0,right; len=strlen(a); if (a[0]=='-') &#123; printf("Fu"); left++; &#125; right=len-1; while (right-4&gt;=left) &#123; right-=4; &#125; int flag,hasPrint; while (len-1-right&gt;=0) &#123; flag=0; //å½“flag=1æ—¶è¯´æ˜Žå‰é¢æœ‰ä¸€ä¸ªç´¯ç§¯çš„é›¶ hasPrint=0; //æ­¤å››ä½æ˜¯å¦æœ‰è¾“å‡ºè¿‡æ•°å­— while (left&lt;=right) &#123; if (left&gt;0 /*ç‰¹æ®Šè¾“å…¥ä¸ºé›¶æ—¶*/ &amp;&amp;a[left]=='0') &#123; flag=1; &#125; else &#123; if (flag==1) &#123; printf(" ling"); flag=0; &#125; if (left&gt;0) &#123; printf(" "); &#125; printf("%s",num[a[left]-'0']); hasPrint=1; if (left!=right) &#123; printf(" %s",wei[right-left-1]); &#125; &#125; left++; &#125; if (hasPrint==1&amp;&amp;right!=len-1) &#123; printf(" %s",wei[(len-1-right)/4+2]); &#125; right+=4; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1077. Kuchiguse (20)]]></title>
    <url>%2FPAT-1077%2F</url>
    <content type="text"><![CDATA[1077. Kuchiguse (20)The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speakerâ€™s personality. Such a preference is called â€œKuchiguseâ€ and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle â€œnyan~â€ is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification: Each input file contains one test case. For each case, the first line is an integer N (2&lt;=N&lt;=100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a characterâ€™s spoken line. The spoken lines are case sensitive. Output Specification: For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write â€œnaiâ€. Sample Input 1: 12343Itai nyan~Ninjin wa iyadanyan~uhhh nyan~ Sample Output 1: 1nyan~ Sample Input 2: 12343Itai!Ninjinnwaiyada T_TT_T Sample Output 2: 1nai 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct line &#123; char l[260]; int len;&#125;line[101];int main() &#123; int n,min=270; cin&gt;&gt;n; cin.get(); //æŽ¥æ”¶å›žè½¦æ¢è¡Œç¬¦ for (int i=0; i&lt;n; i++) &#123; cin.getline(line[i].l, 260); line[i].len=strlen(line[i].l); if (line[i].len&lt;min) &#123; min=line[i].len; &#125; &#125; int j=1,flag=0; while (j &lt;= min) &#123; for (int i=0; i&lt;n-1; i++) &#123; if (line[i].l[line[i].len-j]==line[i+1].l[line[i+1].len-j]) &#123; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; break; &#125; j++; &#125; if (j==1) &#123; cout&lt;&lt;"nai"; return 0; &#125; for (int i=line[0].len-j+1; i&lt;line[0].len; i++) &#123; cout&lt;&lt;line[0].l[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1035. Password (20)]]></title>
    <url>%2FPAT-1035%2F</url>
    <content type="text"><![CDATA[1035. Password (20)To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1 (one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords. Input Specification: Each input file contains one test case. Each case contains a positive integer N (&lt;= 1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space. Output Specification: For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line â€œThere are N accounts and no account is modifiedâ€ where N is the total number of accounts. However, if N is one, you must print â€œThere is 1 account and no account is modifiedâ€ instead. Sample Input 1: 12343Team000002 Rlsp0dfaTeam000003 perfectpwdTeam000001 R1spOdfa Sample Output 1: 1232Team000002 RLsp%dfaTeam000001 R@spodfa Sample Input 2: 121team110 abcdefg332 Sample Output 2: 1There is 1 account and no account is modified Sample Input 3: 1232team110 abcdefg222team220 abcdefg333 Sample Output 3: 1There are 2 accounts and no account is modified 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct user &#123; char name[11],password[11];&#125;user[1001];int main() &#123; int n,num=0; cin&gt;&gt;n; vector&lt;int&gt; id; for (int i=0; i&lt;n; i++) &#123; scanf("%s%s", user[i].name, user[i].password); int len=strlen(user[i].password),flag=0; char *pass=user[i].password; for (int j=0; j&lt;len; j++) &#123; if (pass[j]=='1') &#123; pass[j]='@'; flag=1; &#125; else if (pass[j]=='0') &#123; pass[j]='%'; flag=1; &#125; else if (pass[j]=='l') &#123; pass[j]='L'; flag=1; &#125; else if (pass[j]=='O') &#123; pass[j]='o'; flag=1; &#125; &#125; if (flag==1) &#123; num++; id.push_back(i); &#125; &#125; if (num==0) &#123; if (n==1) &#123; printf("There is 1 account and no account is modified"); &#125; else &#123; printf("There are %d accounts and no account is modified",n); &#125; return 0; &#125; cout&lt;&lt;num&lt;&lt;endl; for (int i=0; i&lt;num; i++) &#123; printf("%s %s",user[id[i]].name,user[id[i]].password); if (i!=num-1) &#123; printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1073. Scientific Notation (20)]]></title>
    <url>%2FPAT-1073%2F</url>
    <content type="text"><![CDATA[1073. Scientific Notation (20)Scientific notation is the way that scientists easily handle very large numbers or very small numbers. The notation matches the regular expression [+-][1-9]â€.â€[0-9]+E[+-][0-9]+ which means that the integer portion has exactly one digit, there is at least one digit in the fractional portion, and the number and its exponentâ€™s signs are always provided even when they are positive. Now given a real number A in scientific notation, you are supposed to print A in the conventional notation while keeping all the significant figures. Input Specification: Each input file contains one test case. For each case, there is one line containing the real number A in scientific notation. The number is no more than 9999 bytes in length and the exponentâ€™s absolute value is no more than 9999. Output Specification: For each test case, print in one line the input number A in the conventional notation, with all the significant figures kept, including trailing zeros, Sample Input 1: 1+1.23400E-03 Sample Output 1: 10.00123400 Sample Input 2: 1-1.2E+10 Sample Output 2: 1-12000000000 æ­¤ä»£ç è¿˜æœ‰ä¸€ä¸ªä¸€åˆ†çš„å°ç‚¹æ²¡è¿‡ï¼Œæš‚æ—¶æ²¡æ‰¾å‡ºé—®é¢˜â€¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; char a[10000]; scanf("%s",a); char x[10000]="\0",y[10000]="\0"; sscanf(a, "%[+-0-9]E%[+-0-9]", x, y); if (x[0]=='-') &#123; printf("%c",x[0]); &#125; int k; k=abs(stoi(y)); /* ç‰¹æ®Šæƒ…å†µ æŒ‡æ•°ä¸ºé›¶ */ if (k==0) &#123; for (int i=1; x[i]!='\0'; i++) &#123; cout&lt;&lt;x[i]; &#125; return 0; &#125; /* ç‰¹æ®Šæƒ…å†µ åº•æ•°ä¸ºé›¶ */ if (abs(stoi(x))==0) &#123; for (int i=1; x[i]!='\0'; i++) &#123; cout&lt;&lt;x[i]; &#125; return 0; &#125; /* æŒ‡æ•°ä¸ºæ­£ */ if (y[0]=='+') &#123; k=stoi(y); cout&lt;&lt;x[1]; int i; for (i=3; i&lt;3+k; i++) &#123; if (x[i]=='\0') &#123; cout&lt;&lt;'0'; &#125; else &#123; cout&lt;&lt;x[i]; &#125; &#125; if (x[i]!='\0') &#123; cout&lt;&lt;"."; &#125; for (int j=i; x[j]!='\0'; j++) &#123; cout&lt;&lt;x[j]; &#125; &#125; /* æŒ‡æ•°ä¸ºè´Ÿ */ else if (y[0]=='-') &#123; k=abs(stoi(y)); cout&lt;&lt;"0."; for (int i=0; i&lt;k-1; i++) &#123; cout&lt;&lt;'0'; &#125; cout&lt;&lt;x[1]; for (int i=3; x[i]!='\0'; i++) &#123; cout&lt;&lt;a[i]; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1061. Dating (20)]]></title>
    <url>%2FPAT-1061%2F</url>
    <content type="text"><![CDATA[1061. Dating (20)Sherlock Holmes received a note with some strange strings: â€œLetâ€™s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnmâ€. It took him only a minute to figure out that those strange strings are actually referring to the coded time â€œThursday 14:04â€ â€“ since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter â€˜Dâ€™, representing the 4th day in a week; the second common character is the 5th capital letter â€˜Eâ€™, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is â€˜sâ€™ at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification: Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification: For each test case, print the decoded time in one line, in the format â€œDAY HH:MMâ€, where â€œDAYâ€ is a 3-character abbreviation for the days in a week â€“ that is, â€œMONâ€ for Monday, â€œTUEâ€ for Tuesday, â€œWEDâ€ for Wednesday, â€œTHUâ€ for Thursday, â€œFRIâ€ for Friday, â€œSATâ€ for Saturday, and â€œSUNâ€ for Sunday. It is guaranteed that the result is unique for each case. Sample Input: 12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm Sample Output: 1THU 14:04 è¿™é¢˜ç›®æ„æ€æœ‰ç‚¹éš¾çœ‹æ‡‚ï¼Œæ˜ŸæœŸå¯¹åº”{A-G}ä¸ƒä¸ªå­—æ¯ï¼Œå°æ—¶å¯¹åº”{0-9 A-N} 24ä¸ªæ•°å­—ï¼Œåˆ†é’Ÿå¯¹åº”{A-Z a-z} 52ä¸ªè‹±æ–‡å­—æ¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; string a[7]=&#123;"MON","TUE","WED","THU","FRI","SAT","SUN"&#125;; char b[122],c[61],d[122],e[61]; cin&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e; int i; for (i=0; b[i]!='\0'&amp;&amp;c[i]!='\0'; i++) &#123; if (b[i]==c[i]&amp;&amp;b[i]-'A'&gt;=0&amp;&amp;b[i]-'A'&lt;=6) &#123; int j=b[i]-'A'; cout&lt;&lt;a[j]&lt;&lt;" "; break; &#125; &#125; for (int j=i+1; b[j]!='\0'&amp;&amp;c[j]!='\0'; j++) &#123; if (b[j]==c[j]) &#123; int x; if (b[j]-'0'&gt;=0&amp;&amp;b[j]-'0'&lt;=9) &#123; x=b[j]-'0'; printf("0%d",x); break; &#125; else if (b[j]-'A'&gt;=0&amp;&amp;b[j]-'A'&lt;=14) &#123; x=b[j]-'A'+10; printf("%d",x); break; &#125; &#125; &#125; printf(":"); for (i=0; d[i]!='\0'&amp;&amp;e[i]!='\0'; i++) &#123; if (d[i]==e[i]) &#123; if ((d[i]-'A'&gt;=0&amp;&amp;d[i]-'A'&lt;=25)||(d[i]-'a'&gt;=0&amp;&amp;d[i]-'a'&lt;=25)) &#123; printf("%02d",i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1058. A+B in Hogwarts (20)]]></title>
    <url>%2FPAT-1058%2F</url>
    <content type="text"><![CDATA[1058. A+B in Hogwarts (20)If you are a fan of Harry Potter, you would know the world of magic has its own currency system â€“ as Hagrid explained it to Harry, â€œSeventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, itâ€™s easy enough.â€ Your job is to write a program to compute A+B where A and B are given in the standard form of â€œGalleon.Sickle.Knutâ€ (Galleon is an integer in [0, 107], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)). Input Specification: Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space. Output Specification: For each test case you should output the sum of A and B in one line, with the same format as the input. Sample Input: 13.2.1 10.16.27 Sample Output: 114.1.28 å””ï¼Œè¿™é‡Œa2ä¸éœ€è¦å–ä½™ï¼ˆ10^7+1ï¼‰ï¼Œé¢˜ç›®æ²¡è¯´ä¼šè¿›ä½ï¼Œä¸€å¼€å§‹æˆ‘ç»™é»˜è®¤äº†â€¦ 1234567891011121314#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b,c,a1,b1,c1,a2,b2,c2; scanf("%d.%d.%d",&amp;a,&amp;b,&amp;c); scanf("%d.%d.%d",&amp;a1,&amp;b1,&amp;c1); c2 = (c+c1)%29; b2 = (b+b1+(c+c1)/29)%17; a2 = a+a1+(b+b1+(c+c1)/29)/17; printf("%d.%d.%d",a2,b2,c2); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1027. Colors in Mars (20)]]></title>
    <url>%2FPAT-1027%2F</url>
    <content type="text"><![CDATA[1027. Colors in Mars (20)People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Each input file contains one test case which occupies a line containing the three decimal color values. Output For each test case you should output the Mars RGB value in the following format: first output â€œ#â€, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a â€œ0â€ to the left. Sample Input 115 43 71 Sample Output 1#123456 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; char x[13]=&#123;'0','1','2','3','4','5','6','7','8','9','A','B','C'&#125;; cout&lt;&lt;"#"; char m,n; m=x[a%13]; a/=13; n=x[a%13]; printf("%c%c",n,m); m=x[b%13]; b/=13; n=x[b%13]; printf("%c%c",n,m); m=x[c%13]; c/=13; n=x[c%13]; printf("%c%c",n,m); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019. General Palindromic Number (20)]]></title>
    <url>%2FPAT-1019%2F</url>
    <content type="text"><![CDATA[1019. General Palindromic Number (20)A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N &gt; 0 in base b &gt;= 2, where it is written in standard notation with k+1 digits ai as the sum of (aibi) for i from 0 to k. Here, as usual, 0 &lt;= ai &lt; b for all i and ak is non-zero. Then N is palindromic if and only if ai = ak-i for all i. Zero is written 0 in any base and is also palindromic by definition. Given any non-negative decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b. Input Specification: Each input file contains one test case. Each case consists of two non-negative numbers N and b, where 0 &lt;= N &lt;= 109 is the decimal number and 2 &lt;= b &lt;= 109 is the base. The numbers are separated by a space. Output Specification: For each test case, first print in one line â€œYesâ€ if N is a palindromic number in base b, or â€œNoâ€ if not. Then in the next line, print N as the number in base b in the form â€œak ak-1 â€¦ a0â€. Notice that there must be no extra space at the end of output. Sample Input 1: 127 2 Sample Output 1: 12Yes1 1 0 1 1 Sample Input 2: 1121 5 Sample Output 2: 12No4 4 1 å®¹æ˜“é—æ¼çš„ä¸€ä¸ªç‰¹æ®Šæƒ…å†µï¼Œé‚£å°±æ˜¯å½“N=0çš„æ—¶å€™ï¼Œéœ€è¦è¾“å‡ºä¸€ä¸ªé›¶ï¼Œæ‰€ä»¥å°†å¾ªçŽ¯æ”¹æˆäº†doâ€¦while 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; a;int main() &#123; int n,b; cin&gt;&gt;n&gt;&gt;b; do &#123; a.push_back(n%b); n=n/b; &#125; while (n!=0); int flag=0; for (int i=a.size()-1; i&gt;=0; i--) &#123; if (a[i]!=a[a.size()-i-1]) &#123; flag=1; break; &#125; &#125; if (flag==0) &#123; cout&lt;&lt;"Yes"&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;"No"&lt;&lt;endl; &#125; for (int i=a.size()-1; i&gt;=0; i--) &#123; cout&lt;&lt;a[i]; if (i!=0) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031. Hello World for U (20)]]></title>
    <url>%2FPAT-1031%2F</url>
    <content type="text"><![CDATA[1031. Hello World for U (20)Given any string of N (&gt;=5) characters, you are asked to form the characters into the shape of U. For example, â€œhelloworldâ€ can be printed as: 1234h de ll rlowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1 characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible â€“ that is, it must be satisfied that n1 = n3 = max { k| k &lt;= n2 for all 3 &lt;= n2 &lt;= N } with n1 + n2 + n3 - 2 = N. Input Specification: Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification: For each test case, print the input string in the shape of U as specified in the description. Sample Input: 1helloworld! Sample Output: 1234h !e dl llowor æ¨¡æ‹Ÿæ‰“å°ä¸€ä¸ªå°½å¯èƒ½æŽ¥è¿‘æ­£æ–¹å½¢çš„Uåž‹~ 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string a; cin&gt;&gt;a; int len=a.length(); //æ€»é•¿åº¦ int x,y; //xä¸ºå·¦ä¸Šå’Œå³ä¸Šä¸¤ç«–çš„é•¿åº¦ï¼Œyä¸ºåº•è¾¹çš„é•¿åº¦ y=len/3+1; if ((len-y)%2==0) &#123; x=(len-y)/2; //å¦‚æžœå‰©ä½™ä¸ºå¶æ•°ç›´æŽ¥é™¤äºŒå¾—åˆ°x &#125; else &#123; y++; x=(len-y)/2; //å¦‚æžœå‰©ä½™ä¸ºå¥‡æ•°å…ˆå‡ä¸€å†é™¤äºŒå¾—åˆ°x &#125; for (int i=0; i&lt;x; i++) &#123; int space=y-2; cout&lt;&lt;a[i]; while (space-- &gt; 0) &#123; cout&lt;&lt;" "; &#125; cout&lt;&lt;a[len-i-1]&lt;&lt;endl; &#125; for (int i=0; i&lt;y; i++) &#123; cout&lt;&lt;a[i+x]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1036. Boys vs Girls (25)]]></title>
    <url>%2FPAT-1036%2F</url>
    <content type="text"><![CDATA[1036. Boys vs Girls (25)This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a studentâ€™s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and grade is an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification: For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference gradeF-gradeM. If one such kind of student is missing, output â€œAbsentâ€ in the corresponding line, and output â€œNAâ€ in the third line instead. Sample Input 1: 12343Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95 Sample Output 1: 123Mary EE990830Joe Math9901126 Sample Input 2: 121Jean M AA980920 60 Sample Output 2: 123AbsentJean AA980920NA ç‰¹åˆ«æ³¨æ„ä¸€ä¸ªç‚¹ï¼šscanfé‡Œé¢çš„%cæ˜¯å¯ä»¥æŽ¥å—ç©ºæ ¼å­—ç¬¦çš„ï¼Œæ‰€ä»¥â€%câ€å‰è¦åŠ ä¸Šä¸€ä¸ªç©ºæ ¼å³â€ %câ€ï¼Œå¦‚ä¸‹ï¼š 1scanf("%s %c%s%d",stu[i].name,&amp;stu[i].sex,stu[i].id,&amp;stu[i].grade); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char name[15]; char sex; char id[15]; int grade;&#125;stu[100];int main() &#123; int n; scanf("%d",&amp;n); for (int i=0; i&lt;n; i++) &#123; scanf("%s %c%s%d",stu[i].name,&amp;stu[i].sex,stu[i].id,&amp;stu[i].grade); &#125; int female=-1,male=-1,femalescore=-1,malescore=101; for (int i=0; i&lt;n; i++) &#123; if (stu[i].sex=='F') &#123; if (stu[i].grade&gt;femalescore) &#123; female=i; femalescore=stu[i].grade; &#125; &#125; else if (stu[i].sex=='M') &#123; if (stu[i].grade&lt;malescore) &#123; male=i; malescore=stu[i].grade; &#125; &#125; &#125; if (female!=-1) &#123; printf("%s %s\n",stu[female].name,stu[female].id); &#125; else &#123; printf("Absent\n"); &#125; if (male!=-1) &#123; printf("%s %s\n",stu[male].name,stu[male].id); &#125; else &#123; printf("Absent\n"); &#125; if (femalescore!=-1&amp;&amp;malescore!=101) &#123; printf("%d",femalescore-malescore); &#125; else &#123; printf("NA"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1046. Shortest Distance (20)]]></title>
    <url>%2FPAT-1046%2F</url>
    <content type="text"><![CDATA[1046. Shortest Distance (20)The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification: Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 â€¦ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification: For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input: 123455 1 2 4 14 931 32 54 1 Sample Output: 1233107 ç®€å•æ¨¡æ‹Ÿï¼Œæ•°æ®é‡æ¯”è¾ƒå¤§ï¼Œå®¹æ˜“è¶…æ—¶ã€‚æ‰€ä»¥é€‰æ‹©é‡‡ç”¨dis[i]ä¿å­˜ä»ŽièŠ‚ç‚¹åˆ°1çš„è·ç¦»ï¼Œè¿™æ ·ä¸¤ç‚¹é—´çš„ä¸€ä¸ªè·ç¦»å°±æ˜¯abs(dis[x]-dis[y])ï¼Œå¦ä¸€ä¸ªç”¨sumä¸€å‡å°±å‡ºæ¥äº†ï¼Œæ—¶é—´å¤æ‚åº¦o(n). ç„¶åŽä¸çŸ¥é“æ˜¯çŽ„å­¦è¿˜æ˜¯ä»€ä¹ˆï¼Œåˆšå¼€å§‹ç›´æŽ¥è¾“å…¥ä¸€ä¸ªå°±ç›´æŽ¥è¾“å‡ºä¸€ä¸ªç»“æžœç­”æ¡ˆæ˜¯å¯ä»¥ï¼Œä½†æ˜¯ojå´wrong answerï¼Œé‚£æˆ‘ä¸å¾—ä¸ç”¨vectorä¿å­˜äº†ç»“æžœå†è¾“å‡ºï¼Œå¯æ˜¯å½“æˆ‘åˆç”¨åˆšæ‰ç›´æŽ¥è¾“å‡ºçš„ä»£ç è·‘ä¸€éå´è¿‡äº†ï¼ŒçœŸæ˜¯çŽ„å­¦~ 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int dis[100002];int main() &#123; int num,sum=0; scanf("%d",&amp;num); dis[1]=0; for (int i=2; i&lt;=num; i++) &#123; scanf("%d",&amp;dis[i]); dis[i]+=dis[i-1]; &#125; int end; scanf("%d",&amp;end); sum=dis[num]+end; int num1; cin&gt;&gt;num1; vector&lt;int&gt; result; for (int i=1; i&lt;=num1; i++) &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); int l1=0,l2=0; l1=abs(dis[y]-dis[x]); l2=sum-l1; result.push_back(min(l1, l2)); &#125; for (auto it=result.begin(); it!=result.end(); it++) &#123; printf("%d\n",*it); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042. Shuffling Machine (20)]]></title>
    <url>%2FPAT-1042%2F</url>
    <content type="text"><![CDATA[1042. Shuffling Machine (20)Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid â€œinside jobsâ€ where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, â€¦, S13, H1, H2, â€¦, H13, C1, C2, â€¦, C13, D1, D2, â€¦, D13, J1, J2 where â€œSâ€ stands for â€œSpadeâ€, â€œHâ€ for â€œHeartâ€, â€œCâ€ for â€œClubâ€, â€œDâ€ for â€œDiamondâ€, and â€œJâ€ for â€œJokerâ€. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification: For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input: 12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output: 1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H1 ç®€å•æ¨¡æ‹Ÿï¼Œé¢˜ç›®è¿˜æŒºé•¿ã€‚ã€‚ðŸ¤£ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string a[55];int main() &#123; for (int i=0; i&lt;13; i++) &#123; a[i+1]="S"+to_string(i+1); a[14+i]="H"+to_string(i+1); a[27+i]="C"+to_string(i+1); a[40+i]="D"+to_string(i+1); &#125; a[53]="J1";a[54]="J2"; string b[55]; //æš‚å­˜ int num; cin&gt;&gt;num; int order[55]; for (int i=1; i&lt;=54; i++) &#123; int temp; cin&gt;&gt;temp; order[i]=temp; &#125; while (num-- &gt; 0) &#123; for (int i=1; i&lt;=54; i++) &#123; b[order[i]]=a[i]; &#125; for (int i=1; i&lt;=54; i++) &#123; a[i]=b[i]; &#125; &#125; for (int i=1; i&lt;=54; i++) &#123; cout&lt;&lt;a[i]; if (i!=54) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1012. The Best Rank (25)]]></title>
    <url>%2FPAT-1012%2F</url>
    <content type="text"><![CDATA[1012. The Best Rank (25)To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algebra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks â€“ that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: 12345StudentID C M E A310101 98 85 88 90310102 70 95 88 84310103 82 87 94 88310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (&lt;=2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output â€œN/Aâ€. Sample Input 1234567891011125 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output 1234561 C1 M1 E1 A3 AN/A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student&#123; int sid,best; int score[4],rank[4];&#125;stu[2001];int exsit[1000001];int flag=0;bool cmp(student a,student b) &#123; return a.score[flag]&gt;b.score[flag];&#125;int main() &#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for (int i=0; i&lt;n; i++) &#123; scanf("%d%d%d%d",&amp;stu[i].sid,&amp;stu[i].score[1],&amp;stu[i].score[2],&amp;stu[i].score[3]); stu[i].score[0]=(stu[i].score[1]+stu[i].score[2]+stu[i].score[3])/3; &#125; for (flag=0; flag&lt;=3; flag++) &#123; sort(stu, stu+n, cmp); stu[0].rank[flag]=1; for (int i=1; i&lt;n; i++) &#123; stu[i].rank[flag]=i+1; if (stu[i].score[flag]==stu[i-1].score[flag]) &#123; stu[i].rank[flag]=stu[i-1].rank[flag]; &#125; &#125; &#125; for (int i=0; i&lt;n; i++) &#123; exsit[stu[i].sid]=i+1; stu[i].best=0; int min=stu[i].rank[0]; for (int j=1; j&lt;=3; j++) &#123; if (stu[i].rank[j]&lt;min) &#123; min=stu[i].rank[j]; stu[i].best=j; &#125; &#125; &#125; char a[5]=&#123;'A','C','M','E'&#125;; for (int i=0; i&lt;m; i++) &#123; int id; scanf("%d",&amp;id); if (exsit[id]==0) &#123; printf("N/A\n"); &#125; else &#123; int sid=exsit[id]-1; printf("%d %c\n",stu[sid].rank[stu[sid].best],a[stu[sid].best]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1011. World Cup Betting (20)]]></title>
    <url>%2FPAT-1011%2F</url>
    <content type="text"><![CDATA[1011. World Cup Betting (20)With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a â€œTriple Winningâ€ game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results â€“ namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winnerâ€™s odd would be the product of the three odds times 65%. For example, 3 gamesâ€™ odds are given as the following: 1234 W T L1.1 2.5 1.71.2 3.0 1.64.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.13.02.565%-1)2 = 37.98 yuans (accurate up to 2 decimal places). Input Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input 1231.1 2.5 1.71.2 3.0 1.64.1 1.2 1.1 Sample Output 1T T W 37.98 ç›®å‰ç¢°åˆ°æœ€ç®€å•çš„é¢˜äº†ðŸ˜† 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;map&lt;double,string&gt; m;int main() &#123; double a,b,c,maxNum,sum=1; for (int i=0; i&lt;3; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; m[a]="W"; m[b]="T"; m[c]="L"; maxNum=max(a, b); maxNum=max(maxNum,c); sum*=maxNum; cout&lt;&lt;m[maxNum]&lt;&lt;" "; &#125; double result=(sum*0.65-1)*2; printf("%.2lf",result); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1034. Head of a Gang (30)]]></title>
    <url>%2FPAT-1034%2F</url>
    <content type="text"><![CDATA[1034. Head of a Gang (30)One way that the police finds the head of a gang is to check peopleâ€™s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A â€œGangâ€ is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads. Input Specification: Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format: Name1 Name2 Time where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes. Output Specification: For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads. Sample Input 1: 1234567898 59AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 1: 1232AAA 3GGG 3 Sample Input 2: 1234567898 70AAA BBB 10BBB AAA 20AAA CCC 40DDD EEE 5EEE DDD 70FFF GGG 30GGG HHH 20HHH FFF 10 Sample Output 2: 10 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string,int&gt; a; //æ¯ä¸ªäººçš„åå­—å¯¹åº”ç¼–å·map&lt;int,string&gt; b; //æ¯ä¸ªç¼–å·å¯¹åº”äººåmap&lt;string,int&gt; result; //è¾“å‡ºç»“æžœint line[2001][2001] /*è¾¹æƒ*/, point[2001] /*ç‚¹æƒ*/, visit[2001] /*æ˜¯å¦å·²ç»éåŽ†è¿‡*/;int n,k; //nä¸ºæ€»ç”µè¯æ•°ï¼Œkä¸ºåˆ¤æ–­é˜ˆå€¼ int digitNo=1; //digitNo-1ä¸ºæ€»äººæ•°/* å°†äººåè½¬åŒ–ä¸ºç¼–å· */int stringToNum(string s) &#123; if (a[s]==0) &#123; a[s]=digitNo; b[digitNo]=s; return digitNo++; &#125; else &#123; return a[s]; &#125;&#125;/* DFSç»Ÿè®¡å½“å‰è¿žé€šåˆ†é‡ */void dfs(int now,int &amp;head,int &amp;memberNum,int &amp;totalWeight) &#123; visit[now]=1; memberNum++; if (point[now]&gt;point[head]) &#123; head=now; &#125; for (int i=1; i&lt;digitNo; i++) &#123; if (line[now][i]&gt;0) &#123; totalWeight+=line[now][i]; line[now][i]=line[i][now]=0; if (visit[i]==0) &#123; dfs(i, head, memberNum, totalWeight); &#125; &#125; &#125;&#125;void DFS() &#123; for (int i=1; i&lt;digitNo; i++) &#123; if (visit[i]==0) &#123; int head=i,memberNum=0,totalWeight=0; dfs(i,head,memberNum,totalWeight); /* æ¯å½“æ‰¾åˆ°ä¸€ä¸ªè¿žé€šåˆ†é‡åˆ™åˆ¤æ–­æ˜¯å¦ä¸ºçŠ¯ç½ªå›¢ä¼™ */ if (memberNum&gt;2&amp;&amp;totalWeight&gt;k) &#123; result[b[head]]=memberNum; &#125; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n&gt;&gt;k; for (int i=0; i&lt;n; i++) &#123; string x,y; int z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; int id1=stringToNum(x); int id2=stringToNum(y); point[id1]+=z; point[id2]+=z; line[id1][id2]+=z; line[id2][id1]+=z; &#125; DFS(); cout&lt;&lt;result.size()&lt;&lt;endl; /* autoä¸ºC++11æ–°ç‰¹æ€§-åŠ¨æ€ç±»åž‹ï¼Œè‡ªåŠ¨æŽ¨å¯¼ç±»åž‹ */ for (auto it=result.begin(); it!=result.end(); it++) &#123; /* itè¿­ä»£å™¨æŒ‡å‘çš„æ˜¯ä¸€ä¸ªä¸ªé”®å€¼å¯¹ï¼ˆpair&lt;string,int&gt;ï¼‰ï¼Œfirstç›¸å½“äºŽkeyï¼Œsecondç›¸å½“äºŽvalue */ cout&lt;&lt;it-&gt;first&lt;&lt;" "&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1045. Favorite Color Stripe (30)]]></title>
    <url>%2FPAT-1045%2F</url>
    <content type="text"><![CDATA[1045. Favorite Color Stripe (30)Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe. It is said that a normal human eye can distinguish about less than 200 different colors, so Evaâ€™s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result. Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Evaâ€™s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (&lt;=200) followed by M Evaâ€™s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (&lt;=10000) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line are separated by a space. Output Specification: For each test case, simply print in a line the maximum length of Evaâ€™s favorite stripe. Sample Input: 12365 2 3 1 5 612 2 2 4 1 5 5 6 3 1 1 5 6 Sample Output: 17 åŠ¨æ€è§„åˆ’ï¼Œæœ€å¤§ä¸Šå‡å­åˆ—é—®é¢˜ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int favor[201] /*å–œæ¬¢çš„é¢œè‰²*/, a[10001] /*ä¿å­˜è¾“å…¥å…ƒç´ åœ¨favorä¸­çš„æƒå€¼*/, dp[10001] /*ä¿å­˜å¯¹åº”aä¸­å½“å‰å…ƒç´ ä»¥å‰æœ€å¤§é€’å¢žå­åˆ—ï¼ˆLISï¼‰é•¿åº¦*/;int main() &#123; int n,m,l; cin&gt;&gt;n&gt;&gt;m; for (int i=1; i&lt;=m; i++) &#123; int temp; cin&gt;&gt;temp; favor[temp]=i; &#125; cin&gt;&gt;l; int num=0; for (int i=0; i&lt;l; i++) &#123; int temp; cin&gt;&gt;temp; if (favor[temp]&gt;=1) &#123; a[num++]=favor[temp]; &#125; &#125; for (int i=0; i&lt;num; i++) &#123; int maxLength=0; for (int j=0; j&lt;i; j++) &#123; if (a[i]&gt;=a[j]) &#123; maxLength=max(maxLength, dp[j]); //æ‰¾åˆ°æ¯ä¸ªä½ç½®ä¹‹å‰æœ€å¤§çš„dp[j] &#125; &#125; dp[i]=maxLength+1; &#125; int maxAll=0; for (int i=0; i&lt;num; i++) &#123; if (dp[i]&gt;maxAll) &#123; maxAll=dp[i]; &#125; &#125; cout&lt;&lt;maxAll; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1038. Recover the Smallest Number (30)]]></title>
    <url>%2FPAT-1038%2F</url>
    <content type="text"><![CDATA[1038. Recover the Smallest Number (30)Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87. Input Specification: Each input file contains one test case. Each case gives a positive integer N (&lt;=10000) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space. Output Specification: For each test case, print the smallest number in one line. Do not output leading zeros. Sample Input: 15 32 321 3214 0229 87 Sample Output: 122932132143287 cmpç«Ÿç„¶å¯ä»¥æœ‰a+b&lt;b+aè¿™ç§å­—ç¬¦ä¸²æ“ä½œâ€¦è®¤æ€‚â€¦ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;//bool cmp(string a, string b) &#123;// int i=0;// while (a[i]!='\0'&amp;&amp;b[i]!='\0') &#123;// if (a[i]==b[i]) &#123;// i++;// continue;// &#125; else &#123;// break;// &#125;// &#125;// return a[i]&lt;b[i];//&#125;bool cmp(string a,string b) &#123; return a+b &lt; b+a;&#125;int main() &#123; int n; cin&gt;&gt;n; vector&lt;string&gt; v(n); for (int i=0; i&lt;n; i++) &#123; string temp; cin&gt;&gt;temp; v[i]=temp; &#125; sort(v.begin(), v.end(), cmp); string s; for (int i=0; i&lt;n; i++) &#123; s+=v[i]; &#125;// for (int i=0; i&lt;s.size(); i++) &#123;// if (v[0][i]=='0') &#123;// continue;// &#125;// cout&lt;&lt;v[0][i];// &#125;// for (int i=1; i&lt;n; i++) &#123;// cout&lt;&lt;v[i];// &#125; while (s.length()&gt;0&amp;&amp;s[0]=='0') &#123; s.erase(s.begin()); &#125; if (s.length()==0) &#123; cout&lt;&lt;0; return 0; &#125; cout&lt;&lt;s; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1037. Magic Coupon (25)]]></title>
    <url>%2FPAT-1037%2F</url>
    <content type="text"><![CDATA[1037. Magic Coupon (25)The magic shop in Mars is offering some magic coupons. Each coupon has an integer N printed on it, meaning that when you use this coupon with a product, you may get N times the value of that product back! What is more, the shop also offers some bonus product for free. However, if you apply a coupon with a positive N to this bonus product, you will have to pay the shop N times the value of the bonus productâ€¦ but hey, magically, they have some coupons with negative Nâ€™s! For example, given a set of coupons {1 2 4 -1}, and a set of product values {7 6 -2 -3} (in Mars dollars M$) where a negative value corresponds to a bonus product. You can apply coupon 3 (with N being 4) to product 1 (with value M$7) to get M$28 back; coupon 2 to product 2 to get M$12 back; and coupon 4 to product 4 to get M$3 back. On the other hand, if you apply coupon 3 to product 4, you will have to pay M$12 to the shop. Each coupon and each product may be selected at most once. Your task is to get as much money back as possible. Input Specification: Each input file contains one test case. For each case, the first line contains the number of coupons NC, followed by a line with NC coupon integers. Then the next line contains the number of products NP, followed by a line with NP product values. Here 1&lt;= NC, NP &lt;= 105, and it is guaranteed that all the numbers will not exceed 230. Output Specification: For each test case, simply print in a line the maximum amount of money you can get back. Sample Input: 123441 2 4 -147 6 -2 -3 Sample Output: 143 é‡‡ç”¨è´ªå¿ƒç®—æ³•ï¼Œå´ä¸€æ³¢ä¸‰æŠ˜ã€‚æ€è·¯è½¬å˜äº†ä¸¤æ¬¡ã€‚æœ€å¼€å§‹æƒ³éšæœºç»„åˆæ±‚å½“å‰æœ€å¤§çš„ç§¯ï¼Œå¹¶ä¸”ç»´æŠ¤ä¸¤ä¸ªæ ‡è®°å‘é‡æ¥è¡¨ç¤ºæ˜¯å¦å·²ç»éåŽ†è¿‡ï¼Œæœ€ç¬¨çš„æ–¹æ³•æ—¶é—´å¤æ‚åº¦ä¸ºO(n^3)ã€‚è¿è¡Œè¶…æ—¶ä¸€ä¸ªä¹‹åŽæ”¹å˜æ€è·¯ï¼Œå°†ä¸¤ä¸ªå‘é‡æŽ’åºï¼Œæ¯æ¬¡å–ä¸¤ä¸ªå‘é‡æœ€å‰é¢çš„æ²¡æ ‡è®°çš„ä¸¤ä¸ªæ•°ä¸Žæœ€åŽä¸¤ä¸ªæ•°è¿›è¡Œå¤§å°æ¯”è¾ƒï¼Œå–å¤§çš„ç®—å…¥æ€»å’Œï¼Œå–è¿‡çš„æ‰“ä¸Šæ ‡è®°ã€‚å¯æ˜¯è¿™æ ·ä¾ç„¶è¶…æ—¶ï¼Œæƒ³äº†æƒ³æ—¶é—´å¤æ‚åº¦æ²¡å˜ï¼Œåªæ˜¯æ¯”åˆšæ‰å°‘äº†ä¸€éƒ¨åˆ†éåŽ†çš„æ“ä½œã€‚ æ¢ä¸€ç§æ€è·¯ï¼Œå…¶å®žå°†ä¸¤ä¸ªå‘é‡æŽ’åºä¹‹åŽåªéœ€è¦æŠŠç›¸å¯¹å‰é¢çš„è´Ÿæ•°ä¸Žè´Ÿæ•°ç›¸ä¹˜ï¼Œç›¸å¯¹åŽé¢çš„æ­£æ•°ä¸Žæ­£æ•°ç›¸ä¹˜ï¼Œå¹¶åŠ èµ·æ¥ï¼Œä¸€ç›´åˆ°æ²¡æœ‰ä¸ºæ­¢ã€‚å…¶å®žæœ€å¤šåªå¾ªçŽ¯äº†max(numc,nump)æ¬¡ï¼Œä¹Ÿå°±æ˜¯O(n)ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; nc;vector&lt;int&gt; np;int main() &#123; int numc,nump,temp; cin&gt;&gt;numc; for (int i=0; i&lt;numc; i++) &#123; cin&gt;&gt;temp; nc.push_back(temp); &#125; cin&gt;&gt;nump; for (int i=0; i&lt;nump; i++) &#123; cin&gt;&gt;temp; np.push_back(temp); &#125;// vector&lt;int&gt; c(numc);// vector&lt;int&gt; p(nump);// memset(c, 0, sizeof(c));// memset(p, 0, sizeof(p)); sort(nc.begin(), nc.end()); sort(np.begin(), np.end()); int total=0; for (int i=0,j=0; i&lt;numc&amp;&amp;j&lt;nump; i++,j++) &#123; if (nc[i]&lt;0&amp;&amp;np[j]&lt;0) &#123; total+=nc[i]*np[j]; &#125; else &#123; break; &#125; &#125; for (int i=numc-1,j=nump-1; i&gt;=0&amp;&amp;j&gt;=0; i--,j--) &#123; if (nc[i]&gt;0&amp;&amp;np[j]&gt;0) &#123; total+=nc[i]*np[j]; &#125; else &#123; break; &#125; &#125; cout&lt;&lt;total; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1033. To Fill or Not to Fill (25)]]></title>
    <url>%2FPAT-1033%2F</url>
    <content type="text"><![CDATA[1033. To Fill or Not to Fill (25)With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification: Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,â€¦N. All the numbers in a line are separated by a space. Output Specification: For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print â€œThe maximum travel distance = Xâ€ where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1: 12345678950 1300 12 86.00 12507.00 6007.00 1507.10 07.20 2007.50 4007.30 10006.85 300 Sample Output 1: 1749.17 Sample Input 2: 12350 1300 12 27.10 07.00 600 Sample Output 2: 1The maximum travel distance = 1200.00 æ­¤é¢˜é‡‡ç”¨è´ªå¿ƒç®—æ³•ï¼Œæ¯æ¬¡åœ¨å¯åˆ°è¾¾çš„ç‚¹ä¸­æŒ‘ä»·æ ¼æœ€å°çš„åŠ æ²¹ç«™åŽ»ã€‚å…¶ä¸­å¦‚æžœæœ‰æ¯”å½“å‰æ›´ä¾¿å®œçš„ç‚¹ï¼Œå°±åŠ æ²¹åˆ°åˆšå¥½åˆ°è¾¾ä¸‹ä¸ªç‚¹ç”¨å®Œï¼Œä¸ç„¶å°±åŠ æ»¡æ²¹ã€‚ æ„Ÿè§‰é¢˜ç›®æ¯”è¾ƒç¹ç~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct station &#123; double price,dis;&#125;;bool cmp(station a,station b) &#123; return a.dis&lt;b.dis;&#125;const int inf = 99999999;int main() &#123; double tank,fullDis,disPerFuel; int stationNum; cin&gt;&gt;tank&gt;&gt;fullDis&gt;&gt;disPerFuel&gt;&gt;stationNum; vector&lt;station&gt; list(stationNum+1); list[0]=&#123;0.0,fullDis&#125;; double tempPrice,tempDis; for (int i=1; i&lt;=stationNum; i++) &#123; cin&gt;&gt;tempPrice&gt;&gt;tempDis; list[i]=&#123;tempPrice,tempDis&#125;; &#125; sort(list.begin(), list.end(), cmp); double nowDis=0,leftDis=0,maxDis,nowPrice=list[0].price,totalPrice=0; if (list[0].dis!=0) &#123; cout&lt;&lt;"The maximum travel distance = 0.00"; return 0; &#125; while (nowDis&lt;fullDis) &#123; int flag=0; maxDis=disPerFuel*tank+nowDis; //æœ€è¿œèƒ½åˆ°è¾¾çš„è·ç¦» double minPrice=inf,minDis=inf; for (int i=1; i&lt;list.size(); i++) &#123; if (list[i].dis&lt;=maxDis&amp;&amp;list[i].dis&gt;nowDis) &#123; //minDis=list[i].dis-nowDis; if (list[i].price&lt;=nowPrice) &#123; totalPrice+=(list[i].dis-nowDis-leftDis)/disPerFuel*nowPrice; nowPrice=list[i].price; nowDis=list[i].dis; leftDis=0; flag=1; &#125; if (list[i].price&lt;minPrice) &#123; minPrice=list[i].price; minDis=list[i].dis; &#125; &#125; &#125; if (flag==0&amp;&amp;minDis!=inf) &#123; totalPrice+=(tank-leftDis/disPerFuel)*nowPrice; leftDis=tank*disPerFuel-(minDis-nowDis); nowDis=minDis; nowPrice=minPrice; &#125; if (flag==0&amp;&amp;minDis==inf) &#123; cout&lt;&lt;"The maximum travel distance = "; printf("%.2lf",maxDis); return 0; &#125; &#125; printf("%.2lf",totalPrice); return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1039. Course List for Student (25)]]></title>
    <url>%2FPAT-1039%2F</url>
    <content type="text"><![CDATA[1039. Course List for Student (25)Zhejiang University has 40000 students and provides 2500 courses. Now given the student name lists of all the courses, you are supposed to output the registered course list for each student who comes for a query. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (&lt;=40000), the number of students who look for their course lists, and K (&lt;=2500), the total number of courses. Then the student name lists are given for the courses (numbered from 1 to K) in the following format: for each course i, first the course index i and the number of registered students Ni (&lt;= 200) are given in a line. Then in the next line, Ni student names are given. A student name consists of 3 capital English letters plus a one-digit number. Finally the last line contains the N names of students who come for a query. All the names and numbers in a line are separated by a space. Output Specification: For each test case, print your results in N lines. Each line corresponds to one student, in the following format: first print the studentâ€™s name, then the total number of registered courses of that student, and finally the indices of the courses in increasing order. The query results must be printed in the same order as input. All the data in a line must be separated by a space, with no extra space at the end of the line. Sample Input: 12345678910111211 54 7BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE11 4ANN0 BOB5 JAY9 LOR62 7ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR63 1BOB55 9AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9 Sample Output: 1234567891011ZOE1 2 4 5ANN0 3 1 2 5BOB5 5 1 2 3 4 5JOE4 1 2JAY9 4 1 2 4 5FRA8 3 2 4 5DON2 2 4 5AMY7 1 5KAT3 3 2 4 5LOR6 4 1 2 4 5NON9 0 ä¸€ä¸ªç‚¹è¿è¡Œè¶…æ—¶ï¼Œå†™çš„æ—¶å€™å°±æƒ³åˆ°äº†å¯èƒ½ä¼šè¶…æ—¶ï¼Œè¿˜å¯ä»¥ä¼˜åŒ–~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; courseList[2510];vector&lt;int&gt; a;int main() &#123; int cNum,sNum; cin&gt;&gt;sNum&gt;&gt;cNum; int cNo,sNo; string stuName; for (int i=0; i&lt;cNum; i++) &#123; cin&gt;&gt;cNo&gt;&gt;sNo; for (int j=0; j&lt;sNo; j++) &#123; cin&gt;&gt;stuName; courseList[cNo].push_back(stuName); &#125; &#125; /* æ¯è¾“å…¥ä¸€ä¸ªå­¦ç”Ÿå§“åå°±è¾“å‡ºä¸€è¡Œ */ for (int i=1; i&lt;=sNum; i++) &#123; cin&gt;&gt;stuName; /* å¯¹äºŽæ¯ä¸€é—¨è¯¾è¿›è¡ŒéåŽ†åŒ¹é…è‡ªå·±çš„åå­—ï¼Œå¦‚æžœæœ‰å°±åŠ åˆ°å®¹å™¨aé‡Œ */ for (int j=cNum; j&gt;=1; j--) &#123; for (int k=0; k&lt;courseList[j].size(); k++) &#123; if (stuName==courseList[j][k]) &#123; a.push_back(j); break; &#125; &#125; &#125; /* è¾“å‡ºä¸€è¡Œ */ cout&lt;&lt;stuName&lt;&lt;" "; if (a.empty()) &#123; cout&lt;&lt;0&lt;&lt;endl; break; &#125; cout&lt;&lt;a.size(); while (!a.empty()) &#123; cout&lt;&lt;" "&lt;&lt;a.back(); a.pop_back(); &#125; cout&lt;&lt;endl; a.clear(); //æ¸…ç©ºå®¹å™¨a &#125; return 0;&#125; è€ƒè™‘stringæ“ä½œè€—æ—¶ï¼ŒäºŽæ˜¯ç”¨äº†hashå‡½æ•°ï¼Œå°†å­¦ç”Ÿåå­—çš„stringè½¬åŒ–ä¸ºintå­˜å‚¨ã€‚ç„¶è€Œè¿˜æ˜¯ä¸å¤Ÿï¼Œcin&gt;&gt;stringè¿˜æ˜¯è¶…æ—¶ï¼ŒäºŽæ˜¯å°†å…¶æ”¹æˆscanfï¼ŒAC 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=26*26*26*10;vector&lt;int&gt; studentList[maxn];int getId(char *name) &#123; int id=0; for (int i=0; i&lt;3; i++) &#123; id=id*26+name[i]-'A'; &#125; id=id*10+name[3]-'0'; return id;&#125;int main() &#123; int cNum,sNum; cin&gt;&gt;sNum&gt;&gt;cNum; int cNo,sNo; char stuName[5]; for (int i=0; i&lt;cNum; i++) &#123; cin&gt;&gt;cNo&gt;&gt;sNo; for (int j=0; j&lt;sNo; j++) &#123; scanf("%s",stuName); int id=getId(stuName); studentList[id].push_back(cNo); &#125; &#125; for (int i=0; i&lt;sNum; i++) &#123; scanf("%s",stuName); int id=getId(stuName); sort(studentList[id].begin(),studentList[id].end()); printf("%s %d",stuName,studentList[id].size()); for (int i=0; i&lt;studentList[id].size(); i++) &#123; cout&lt;&lt;" "&lt;&lt;studentList[id][i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1041. Be Unique (20)]]></title>
    <url>%2FPAT-1041%2F</url>
    <content type="text"><![CDATA[1041. Be Unique (20)Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1, 104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on 5 31 5 88 67 88 17, then the second one who bets on 31 wins. Input Specification: Each input file contains one test case. Each case contains a line which begins with a positive integer N (&lt;=105) and then followed by N bets. The numbers are separated by a space. Output Specification: For each test case, print the winning number in a line. If there is no winner, print â€œNoneâ€ instead. Sample Input 1: 17 5 31 5 88 67 88 17 Sample Output 1: 131 Sample Input 2: 15 888 666 666 888 888 Sample Output 2: 1None ç¬¬ä¸€æ¬¡è¿è¡Œè¶…æ—¶ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; u;int main() &#123; int num; cin&gt;&gt;num; int temp; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;temp; u.push_back(temp); &#125; int flag=0,hasOutput=0; for (int i=0; i&lt;num; i++) &#123; for (int j=0; j&lt;num; j++) &#123; if (u[i]==u[j]&amp;&amp;i!=j) &#123; flag=1; break; &#125; &#125; if (flag==0) &#123; cout&lt;&lt;u[i]; hasOutput=1; break; &#125; flag=0; &#125; if (hasOutput==0) &#123; cout&lt;&lt;"None"; &#125; return 0;&#125; ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œä»ŽO(n^2)å˜æˆO(n) 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int a[100001],m[100001];int main() &#123; int num; cin&gt;&gt;num; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;a[i]; m[a[i]]++; &#125; for (int i=0; i&lt;num; i++) &#123; if (m[a[i]]==1) &#123; cout&lt;&lt;a[i]; return 0; &#125; &#125; cout&lt;&lt;"None"; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1040. Longest Symmetric String (25)]]></title>
    <url>%2FPAT-1040%2F</url>
    <content type="text"><![CDATA[1040. Longest Symmetric String (25)Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given â€œIs PAT&amp;TAP symmetric?â€, the longest symmetric sub-string is â€œs PAT&amp;TAP sâ€, hence you must output 11. Input Specification: Each input file contains one test case which gives a non-empty string of length no more than 1000. Output Specification: For each test case, simply print the maximum length in a line. Sample Input: 1Is PAT&amp;TAP symmetric? Sample Output: 111 åˆšå¼€å§‹è€ƒè™‘çš„æ—¶å€™è§‰å¾—é¢˜ç›®æ˜¯è¦æ±‚ä»¥ä¸€ä¸ªå­—æ¯ä¸ºä¸­å¿ƒä¸¤ä¾§çš„å­—æ¯å¯¹ç§°çš„æœ€é•¿åºåˆ—é•¿åº¦ï¼Œå…¶å®žè¿™æ ·æˆ‘åªè€ƒè™‘äº†å•æ•°é•¿åº¦çš„æƒ…å†µï¼Œè¿˜æœ‰å¶æ•°çš„æ²¡è€ƒè™‘ï¼Œåˆ†å¼€è€ƒè™‘ä¹‹åŽè¿˜æ˜¯æœ‰ä¸€ä¸ªç‚¹å¤±è´¥ã€‚è¿™é‡Œçš„ç®—æ³•é‡‡ç”¨ä»Žå‰å¾€åŽæ¯ä¸€ä¸ªç‚¹å¾€ä¸¤ä¾§ä¸€æ ¼ä¸€æ ¼éåŽ†æˆåŠŸä¸€æ¬¡å°±é•¿åº¦åŠ äºŒï¼Œç†è®ºä¸Šå¯è¡Œï¼Œæ—¶é—´å¤æ‚åº¦o(n^2)ã€‚ è¿‡ä¸äº†äºŽæ˜¯æ¢æˆåŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œç»´æŠ¤ä¸€ä¸ªdpçš„äºŒç»´æ•°ç»„ï¼Œè¡¨ç¤ºä»Ža[i]åˆ°a[j]æ˜¯å¦æ˜¯å›žæ–‡ä¸²ï¼Œé€’å½’å­é—®é¢˜æ±‚è§£ã€‚ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1001][1001];int main() &#123; int max=1; string a; getline(cin, a); for (int i=0; i&lt;a.size(); i++) &#123; dp[i][i]=1; if (a[i]==a[i+1]&amp;&amp;i&lt;a.size()-1) &#123; dp[i][i+1]=1; max=2; &#125; &#125; for (int len=3; len&lt;=a.size(); len++) &#123; for (int i=0; i+len-1&lt;a.size(); i++) &#123; int j=i+len-1; if (a[i]==a[j]&amp;&amp;dp[i+1][j-1]==1) &#123; dp[i][j]=1; max=len; &#125; else &#123; dp[i][j]=0; &#125; &#125; &#125; cout&lt;&lt;max; return 0;&#125; åŽé¢æ˜¯ä¸€å¤„é”™è¯¯çš„ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;int main() &#123; string a; getline(cin, a); int max=1; for (int i=0; i&lt;a.length(); i++) &#123; int j=1,num=1; while (i-j&gt;=0&amp;&amp;i+j&lt;=a.size()-1) &#123; if (a[i-j]==a[i+j]) &#123; num+=2; j++; if (num&gt;max) &#123; max=num; &#125; &#125; else &#123; break; &#125; &#125; if (a[i]==a[i+1]) &#123; int j=1; num=2; while (i-j&gt;=0&amp;&amp;i+1+j&lt;=a.size()-1) &#123; if (a[i-j]==a[i+j]) &#123; num+=2; j++; if (num&gt;max) &#123; max=num; &#125; &#125; else &#123; break; &#125; &#125; &#125; &#125; cout&lt;&lt;max; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1065. A+B and C (64bit) (20)]]></title>
    <url>%2FPAT-1065%2F</url>
    <content type="text"><![CDATA[1065. A+B and C (64bit) (20)Given three integers A, B and C in [-263, 263], you are supposed to tell whether A+B &gt; C. Input Specification: The first line of the input gives the positive number of test cases, T (&lt;=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification: For each test case, output in one line â€œCase #X: trueâ€ if A+B&gt;C, or â€œCase #X: falseâ€ otherwise, where X is the case number (starting from 1). Sample Input: 123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output: 123Case #1: falseCase #2: trueCase #3: false ç®€å•é¢˜ï¼Œå¤§æ•°ç›¸åŠ è€ƒè™‘æº¢å‡ºçš„æƒ…å†µã€‚ 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main() &#123; int num; cin&gt;&gt;num; long long a,b,c,sum; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; sum=a+b; if (a&gt;0&amp;&amp;b&gt;0&amp;&amp;sum&lt;0) &#123; printf("Case #%d: true\n",i+1); &#125; else if (a&lt;0&amp;&amp;b&lt;0&amp;&amp;sum&gt;=0) &#123; printf("Case #%d: false\n",i+1); &#125; else if (sum&gt;c) &#123; printf("Case #%d: true\n",i+1); &#125; else &#123; printf("Case #%d: false\n",i+1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1064. Complete Binary Search Tree (30)]]></title>
    <url>%2FPAT-1064%2F</url>
    <content type="text"><![CDATA[1064. Complete Binary Search Tree (30)A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the nodeâ€™s key. The right subtree of a node contains only nodes with keys greater than or equal to the nodeâ€™s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification: For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input: 12101 2 3 4 5 6 7 8 9 0 Sample Output: 16 3 8 1 5 7 9 0 2 4 ä¸­åºéåŽ†å®Œå…¨äºŒå‰æœç´¢æ ‘ï¼ˆCBT+BSTï¼‰çš„ç»“æžœé¡ºåºä¸ºæ‰€æœ‰èŠ‚ç‚¹é€’å¢žæŽ’åº 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,num[1001],level[1001],coun=0;void inOrder(int i) &#123; if (i&gt;n) &#123; return; &#125; /* ä¸­åºéåŽ† å®Œå…¨äºŒå‰æ ‘ */ inOrder(2*i); level[i]=num[coun++]; inOrder(2*i+1);&#125;int main() &#123; int x; cin&gt;&gt;n; for (int i=0; i&lt;n; i++) &#123; cin&gt;&gt;x; num[i]=x; &#125; sort(num,num+n); inOrder(1); for (int i=1; i&lt;=n; i++) &#123; cout&lt;&lt;level[i]; if(i&lt;n) &#123; cout&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1066. Root of AVL Tree (25)]]></title>
    <url>%2FPAT-1066%2F</url>
    <content type="text"><![CDATA[1066. Root of AVL Tree (25)An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, print ythe root of the resulting AVL tree in one line. Sample Input 1: 12588 70 61 96 120 Sample Output 1: 170 Sample Input 2: 12788 70 61 96 120 90 65 Sample Output 2: 188 çªç„¶å…´èµ·æƒ³ç ”ç©¶AVLå¹³è¡¡æ ‘ï¼Œç»“æžœå°±æ˜¯èŠ±äº†ä¸¤å¤©ä»£ç è¿˜æ˜¯å‚è€ƒç½‘ä¸Šçš„ï¼Œä¸è¿‡æ€»ç®—æ˜¯ç†è§£äº†ã€‚å°±æ˜¯æ„Ÿè§‰è‡ªå·±å¯¹äºŽé€’å½’çš„ç†è§£è¿˜æ˜¯ä¸å¤Ÿé€å½»~ ä»£ç å‘½åå¾ˆæ¸…æ™°å°±ä¸å¤šåŠ æ³¨é‡Šäº†ã€‚ã€‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;using namespace std;struct node &#123; int val; struct node* left; struct node *right;&#125;;/* å·¦æ—‹ */node* rotateLeft(node* root) &#123; node* t=root-&gt;right; root-&gt;right=t-&gt;left; t-&gt;left=root; return t;&#125;/* å³æ—‹ */node* rotateRight(node* root) &#123; node* t=root-&gt;left; root-&gt;left=t-&gt;right; t-&gt;right=root; return t;&#125;/* å…ˆå·¦æ—‹åŽå³æ—‹ */node* rotateLeftRight(node* root) &#123; root-&gt;left=rotateLeft(root-&gt;left); return rotateRight(root);&#125;/* å…ˆå³æ—‹åŽå·¦æ—‹ */node* rotateRightLeft(node* root) &#123; root-&gt;right=rotateRight(root-&gt;right); return rotateLeft(root);&#125;int getHeight(node* root) &#123; if (root==NULL) &#123; return 0; &#125; else &#123; return max(getHeight(root-&gt;left), getHeight(root-&gt;right))+1; &#125;&#125;node* insert(node* root, int val) &#123; if (root==NULL) &#123; root=new node(); root-&gt;val=val; root-&gt;left=root-&gt;right=NULL; &#125; else if (val&lt;root-&gt;val) &#123; root-&gt;left=insert(root-&gt;left, val); if (getHeight(root-&gt;left)-getHeight(root-&gt;right)==2) &#123; return val&lt;root-&gt;left-&gt;val?rotateRight(root):rotateLeftRight(root); &#125; &#125; else &#123; root-&gt;right=insert(root-&gt;right, val); if (getHeight(root-&gt;left)-getHeight(root-&gt;right)==-2) &#123; return val&gt;root-&gt;right-&gt;val?rotateLeft(root):rotateRightLeft(root); &#125; &#125; return root;&#125;int main() &#123; int num; cin&gt;&gt;num; int val; node* root=NULL; for (int i=0; i&lt;num; i++) &#123; cin&gt;&gt;val; root=insert(root,val); &#125; cout&lt;&lt;root-&gt;val; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1014. Waiting in Line (30)]]></title>
    <url>%2FPAT-1014%2F</url>
    <content type="text"><![CDATA[1014. Waiting in Line (30)Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (NM+1)st one will have to wait in a line behind the yellow line. Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number. Customer[i] will take T[i] minutes to have his/her transaction processed. The first N customers are assumed to be served at 8:00am. Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer1 is served at window1 while customer2 is served at window2. Customer3 will wait in front of window1 and customer4 will wait in front of window2. Customer5 will wait behind the yellow line. At 08:01, customer1 is done and customer5 enters the line in front of window1 since that line seems shorter now. Customer2 will leave at 08:02, customer4 at 08:06, customer3 at 08:07, and finally customer5 at 08:10. Input Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (&lt;=20, number of windows), M (&lt;=10, the maximum capacity of each line inside the yellow line), K (&lt;=1000, number of customers), and Q (&lt;=1000, number of customer queries). The next line contains K positive integers, which are the processing time of the K customers. The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K. Output For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output â€œSorryâ€ instead. Sample Input 1232 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output 1234508:0708:0608:1017:00Sorry é¢˜æ„æ˜¯ä¸€å †äººæŽ’é˜ŸåŽ»é“¶è¡ŒåŠžä¸šåŠ¡ï¼Œç®—å…¶ä¸­å‡ ä¸ªäººä¸ªäººåŠžå¥½çš„æ—¶é—´ã€‚ ä½¿ç”¨é˜Ÿåˆ—queueè§£å†³ï¼Œå‚è€ƒæŸ³ç¥žçš„ç®—æ³•ï¼Œå¾ˆå¦™ã€‚ç›´æŽ¥ç”¨ä¸€ä¸ªç»“æž„ä½“è¡¨ç¤ºä¸€ä¸ªçª—å£çš„çŠ¶æ€ä¿¡æ¯ï¼Œå…¶ä¸­ç”¨poptimeè¡¨ç¤ºé˜Ÿé¦–çš„äººç¦»å¼€çš„æ—¶é—´ï¼Œç”¨endtimeè¡¨ç¤ºé˜Ÿå°¾ç»“æŸçš„æ—¶é—´ï¼ŒçœåŽ»äº†è®¸å¤šéº»çƒ¦ï¼Œæ¯”å¦‚å¯ä»¥ç›´æŽ¥åœ¨æ’å…¥ä¸€ä¸ªé¡¾å®¢çš„åŒæ—¶å¾—åˆ°ä»–ç¦»å¼€çš„æ—¶é—´result[index]å³å½“æ—¶çš„endtimeï¼Œåœ¨å½“å‰é˜Ÿåˆ—åŒæ­¥æ›´æ–°ç´¯åŠ poptimeä»Žè€Œé€‰åˆ°æœ€å°çš„poptimeè¿›è¡Œä¸‹ä¸€æ¬¡æ’å…¥ï¼Œç”¨sorryè¿™ä¸ªæ•°ç»„æ¥ç»™è¶…è¿‡ä¸‹ç­æ—¶é—´çš„é¡¾å®¢æ‰“ä¸Šæ ‡è®°ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int t[1001]=&#123;0&#125;;struct node &#123; int poptime; //é˜Ÿé¦–çš„äººç¦»å¼€çš„æ—¶é—´ int endtime; //é˜Ÿå°¾ç»“æŸçš„æ—¶é—´ queue&lt;int&gt; q;&#125;;int main() &#123; int n,m,k,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;q; for (int i=1; i&lt;=k; i++) &#123; cin&gt;&gt;t[i]; &#125; int index=1; //å½“å‰é¡¾å®¢ç¼–å· vector&lt;node&gt; window(n+1); vector&lt;bool&gt; sorry(k+1,false); vector&lt;int&gt; result(k+1); for (int i=1; i&lt;=m; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; if (index&lt;=k) &#123; window[j].q.push(t[index]); if (window[j].endtime&gt;=540) &#123; sorry[index]=true; &#125; window[j].endtime+=t[index]; if (i==1) &#123; window[j].poptime=t[index]; &#125; result[index]=window[j].endtime; index++; &#125; &#125; &#125; while (index&lt;=k) &#123; int tempmin=window[1].poptime,tempwindow=1; for (int i=1; i&lt;=n; i++) &#123; if (window[i].poptime&lt;tempmin) &#123; tempmin=window[i].poptime; tempwindow=i; &#125; &#125; window[tempwindow].q.pop(); window[tempwindow].q.push(t[index]); /* æœ€å…³é”®çš„ä¸€æ­¥ï¼ˆè®¡ç®—å½“å‰ç¬¬ä¸€ä¸ªé¡¾å®¢ç¦»å¼€è·ç¦»å…«ç‚¹çš„æ—¶é—´ï¼Œç”¨æ¥æ¯”è¾ƒé€‰æ‹©ï¼‰*/ window[tempwindow].poptime+=window[tempwindow].q.front(); if (window[tempwindow].endtime&gt;=540) &#123; sorry[index]=true; &#125; window[tempwindow].endtime+=t[index]; result[index]=window[tempwindow].endtime; index++; &#125; int query; for (int i=1; i&lt;=q; i++) &#123; cin&gt;&gt;query; if (sorry[query]==true) &#123; cout&lt;&lt;"Sorry"&lt;&lt;endl; &#125; else &#123; int minute=result[query]; printf("%02d:%02d\n",(minute+480)/60,(minute+480)%60); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1013. Battle Over Cities (25)]]></title>
    <url>%2FPAT-1013%2F</url>
    <content type="text"><![CDATA[1013. Battle Over Cities (25)It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly. For example, if we have 3 cities and 2 highways connecting city1-city2 and city1-city3. Then if city1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city2-city3. Input Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern. Output For each of the K cities, output in a line the number of highways need to be repaired if that city is lost. Sample Input 12343 2 31 21 31 2 3 Sample Output 123100 DFSæ·±åº¦ä¼˜å…ˆæœç´¢è®¡ç®—è¿žé€šåˆ†é‡çš„ä¸ªæ•°~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int v[1001][1001]; //ä¸¤åŸŽå¸‚ä¹‹é—´æ˜¯å¦è¿žé€šï¼Œ1ä¸ºè¿žé€šï¼Œ0ä¸è¿žé€šbool visit[1001]; //æ˜¯å¦è¢«è®¿é—®è¿‡int n; //åŸŽå¸‚ä¸ªæ•°/* DFSæ‰¾åˆ°ä¸€ä¸ªè¿žé€šåˆ†é‡å¹¶è¿”å›ž */void DFS(int node) &#123; visit[node]=true; for (int i=1; i&lt;=n; i++) &#123; if (visit[i]==false&amp;&amp;v[i][node]==1) &#123; DFS(i); &#125; &#125;&#125;int main() &#123; int m,k; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; int a,b; memset(v, 0, sizeof(v)); for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;a&gt;&gt;b; v[a][b]=v[b][a]=1; &#125; int city; for (int i=0; i&lt;k; i++) &#123; fill(visit, visit+1001, false); cin&gt;&gt;city; visit[city]=true; int count=0; for (int j=1; j&lt;=n; j++) &#123; if (visit[j]==false) &#123; DFS(j); count++; &#125; &#125; cout&lt;&lt;count-1&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1010. Radix (25)]]></title>
    <url>%2FPAT-1010%2F</url>
    <content type="text"><![CDATA[1010. Radix (25)Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is â€œyesâ€, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification: Each input file contains one test case. Each case occupies a line which contains 4 positive integers:N1 N2 tag radixHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number â€œradixâ€ is the radix of N1 if â€œtagâ€ is 1, or of N2 if â€œtagâ€ is 2. Output Specification: For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print â€œImpossibleâ€. If the solution is not unique, output the smallest possible radix. Sample Input 1: 16 110 1 10 Sample Output 1: 12 Sample Input 2: 11 ab 1 2 Sample Output 2: 1Impossible æˆ‘æ„Ÿè§‰è¿™æ˜¯æˆ‘ç›®å‰æŽ¥è§¦åˆ°æœ€éš¾ï¼Œæœ€æœ‰æŒ‘æˆ˜æ€§çš„é¢˜äº†ã€‚é¦–å…ˆç¬¬ä¸€éçœ‹å®Œé¢˜ç›®ï¼Œåªçœ‹äº†å¤§æ¦‚ï¼Œæ˜Žç™½è¿™é“é¢˜è®²çš„æ˜¯ä»€ä¹ˆï¼Œä½†æ˜¯å´æ²¡æœ‰ä»€ä¹ˆæ€è·¯ï¼Œæ€æ¥æƒ³åŽ»æ‘¸ä¸ç€å¤´è„‘ï¼ŒäºŽæ˜¯ä¹Žæ‰¾è§£ç­”ï¼Œæœ‰äº†ä¸ªå¤§æ¦‚çš„è§£é¢˜æ€è·¯ï¼Œåªæ˜¯æˆ‘ä¸€ç›´ä¸æ˜Žç™½ä¸ºä»€ä¹ˆï¼ˆæœªçŸ¥è¿›åˆ¶çš„ï¼‰é‚£ä¸ªæ•°çš„ä¸Šé™æ˜¯æ ¹æ®é‚£ä¸ªæ•°æœ¬èº«çš„å¤§å°æ¥å®šï¼Œå³æœ¬èº«å¤§å°ä¸Žä¸‹é™å–ä¸ªæœ€å¤§å€¼ä½œä¸ºä¸Šé™ã€‚ è§£é¢˜æ€è·¯æ˜¯è¿™æ ·çš„ï¼šé¦–å…ˆè¾“å…¥è¿™å››ä¸ªæ•°ï¼Œå°†å·²çŸ¥çš„é‚£ä¸ªæ•°(m)è½¬åŒ–ä¸ºåè¿›åˆ¶ï¼Œç„¶åŽç¡®å®šä¸Šä¸‹é™ï¼Œå³æ‰¾åˆ°æœªçŸ¥è¿›åˆ¶çš„é‚£ä¸ªæ•°(n)çš„æœ€å¤§ä¸€ä½ï¼Œå°†å…¶åŠ 1å¾—åˆ°ä¸‹é™lowï¼ŒæœªçŸ¥è¿›åˆ¶é‚£ä¸ªæ•°(n)æœ¬èº«å¤§å°ä¸Žä¸‹é™å–ä¸ªæœ€å¤§å€¼ä½œä¸ºä¸Šé™highã€‚å› ä¸º[low,high]æ˜¯ä¸ªå•è°ƒåŒºé—´ï¼ŒäºŽæ˜¯é‡‡ç”¨äºŒåˆ†æ³•è¿›è¡ŒæŸ¥æ‰¾ã€‚å…¶ä¸­ä¸€ä¸ªå‘æ˜¯æ•°æ®çš„ä½æ•°é—®é¢˜ï¼Œä¹‹å‰é‡‡ç”¨intæ¥å­˜é”™ä¸€åŠï¼Œç”¨long long æ¥å­˜èƒ½å¤šå¯¹å‡ ä¸ªï¼Œè¯´æ˜Žå­˜åœ¨å¾ˆå¤§çš„æ•°ï¼›å…¶æ¬¡ï¼ŒäºŒåˆ†æŸ¥æ‰¾æ—¶çš„ç”±midè¿›åˆ¶è½¬ä¸º10è¿›åˆ¶æ—¶ä¼šæº¢å‡ºï¼Œå³long long ä¼šæº¢å‡ºï¼Œç›´æŽ¥å¯¼è‡´num&lt;0ï¼Œæ‰€ä»¥è¦åŠ ä¸€ä¸ªåˆ¤æ–­æ¡ä»¶æ‰è¡Œï¼Œæœ€åŽå°±æ˜¯æˆ‘é‚£ä¸ªé—®é¢˜è¿˜æ˜¯ä¸æ‡‚ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int map[256];long long convertToTen(char a[], long long radix) &#123; long long len=strlen(a); long long ans=0; for (int i=0; i&lt;len; i++) &#123; ans=ans*radix+map[a[i]]; &#125; return ans;&#125;int findlowest(char n[]) &#123; int ans=0; long long len=strlen(n); for (int i=0; i&lt;len; i++) &#123; if (map[n[i]]&gt;ans) &#123; ans=map[n[i]]; &#125; &#125; return ans;&#125;long long binarySearch(long long left, long long right, char n[], long long t) &#123; while (left&lt;=right) &#123; long long mid=(left+right)/2; long long num=convertToTen(n, mid); if (num&gt;t||num&lt;0) &#123; right=mid-1; &#125; else if (num&lt;t) &#123; left=mid+1; &#125; else if (num==t) &#123; return mid; &#125; &#125; return -1;&#125;int main() &#123; char m[20],n[20]; int tag,radix; long long result=-1; cin&gt;&gt;m&gt;&gt;n&gt;&gt;tag&gt;&gt;radix; for (int i='0'; i&lt;='9'; i++) &#123; map[i]=i-'0'; &#125; for (int j='a'; j&lt;='z'; j++) &#123; map[j]=j-'a'+10; &#125; if (tag==2) &#123; swap(m, n); &#125; long long t=convertToTen(m,radix); long long low=findlowest(n); long long high=max(t,low)+1; result=binarySearch(low,high,n,t); if (result==-1) &#123; cout&lt;&lt;"Impossible"; &#125; else &#123; cout&lt;&lt;result; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1009. Product of Polynomials (25)]]></title>
    <url>%2FPAT-1009%2F</url>
    <content type="text"><![CDATA[1009. Product of Polynomials (25)This time, you are supposed to find A*B where A and B are two polynomials. Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 â€¦ NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, â€¦, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; â€¦ &lt; N2 &lt; N1 &lt;=1000. Output Specification: For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 13 3 3.6 2 6.0 1 1.6 åˆæ˜¯ä¸€é“å¤šé¡¹å¼çš„é¢˜ï¼Œä¸Šä¸€æ¬¡ç›¸åŠ ï¼Œè¿™ä¸€æ¬¡ç›¸ä¹˜ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main() &#123; double line[2001]=&#123;0.0&#125;; double m[1001]=&#123;0.0&#125;; int a,b; cin&gt;&gt;a; int key; double value; for (int i=0; i&lt;a; i++) &#123; cin&gt;&gt;key&gt;&gt;value; m[key]=value; &#125; cin&gt;&gt;b; for (int i=0; i&lt;b; i++) &#123; cin&gt;&gt;key&gt;&gt;value; for (int j=0; j&lt;1001; j++) &#123; line[j+key]+=m[j]*value; &#125; &#125; /* é¡¹æ•° */ int count=0; for (int i=0; i&lt;2001; i++) &#123; if (line[i]!=0) &#123; count++; &#125; &#125; cout&lt;&lt;count; for (int i=2000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; printf(" %d %.1lf",i,line[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1008. Elevator (20)]]></title>
    <url>%2FPAT-1008%2F</url>
    <content type="text"><![CDATA[1008. Elevator (20)The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop. For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled. Input Specification: Each input file contains one test case. Each case contains a positive integer N, followed by N positive numbers. All the numbers in the input are less than 100. Output Specification: For each test case, print the total time on a single line. Sample Input: 13 2 3 1 Sample Output: 141 ç®€å•çš„è®¡ç®—é¢˜ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b=0, now = 0, sum = 0; cin &gt;&gt; a; for(int i=0; i&lt;a; i++) &#123; cin&gt;&gt;b; if(b &gt; now) sum += 6 * (b - now); else sum += 4 * (now - b); now = b; sum += 5; &#125; cout &lt;&lt; sum; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1007. Maximum Subsequence Sum (25)]]></title>
    <url>%2FPAT-1007%2F</url>
    <content type="text"><![CDATA[1007. Maximum Subsequence Sum (25)Given a sequence of K integers { N1, N2, â€¦, NK }. A continuous subsequence is defined to be { Ni, Ni+1, â€¦, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification: Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space. Output Specification: For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input: 1210-10 1 2 3 4 -5 -23 3 7 -21 Sample Output: 110 1 4 åˆå§‹çš„æš´åŠ›æžšä¸¾æ³•o(n^3)æˆ‘æ„Ÿè§‰æ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯åªACäº†ä¸€ä¸ªç­”æ¡ˆï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=0,from=0,to=0; int num,tempsum=0; cin&gt;&gt;num; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; int mini1=0,i1=0,mink1=0,k1=0; for (int i=0; i&lt;num; i++/*ä»Žç¬¬iä¸ªå¼€å§‹*/) &#123; i1=i; for (int k=1; k&lt;=num-i; k++/*æœ‰kä¸ª*/) &#123; k1=k; for (int j=0; j&lt;k; j++) &#123; tempsum+=v[i+j]; &#125; if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=i1; to=i1+k1-1; mini1=i1; mink1=k1; &#125; else if (tempsum==maxsum) &#123; if (i1&lt;mini1) &#123; from=i1; to=i1+k1-1; &#125; &#125; tempsum=0; &#125; &#125; if (maxsum&lt;0) &#123; cout&lt;&lt;0&lt;&lt;" "&lt;&lt;0&lt;&lt;" "&lt;&lt;num-1; return 0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;from&lt;&lt;" "&lt;&lt;to; return 0;&#125; ç»ˆäºŽæ‰¾åˆ°äº†è¿™å‚»é€¼çš„é”™è¯¯åŽŸå› ï¼Œé¢˜æ„çœ‹é”™äº†ï¼Œè¦æ±‚è¾“å‡ºä¸€å‰ä¸€åŽä¿©æ•°å­—è€Œä¸æ˜¯ä¿©ä¸‹æ ‡ï¼Œä¹Ÿä¸çŸ¥é“æ˜¯å› ä¸ºæˆ‘çœ‹å¾—å¤ªå¿«è¿˜æ˜¯è‹±è¯­å¤ªçƒ‚ã€‚ã€‚ã€‚ ä¿®æ”¹å¦‚ä¸‹ï¼Œä½†è¿˜æ˜¯æœ‰é—®é¢˜ï¼Œé‚£å°±æ˜¯è¶…æ—¶~ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=0,from=0,to; int num,tempsum=0; cin&gt;&gt;num; to=num-1; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; int mini1=0,i1=0,mink1=0,k1=0; for (int i=0; i&lt;num; i++/*ä»Žç¬¬iä¸ªå¼€å§‹*/) &#123; i1=i; for (int k=1; k&lt;=num-i; k++/*æœ‰kä¸ª*/) &#123; k1=k; for (int j=0; j&lt;k; j++) &#123; tempsum+=v[i+j]; &#125; if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=i1; to=i1+k1-1; mini1=i1; mink1=k1; &#125; else if (tempsum==maxsum) &#123; if (i1&lt;mini1) &#123; from=i1; to=i1+k1-1; &#125; &#125; tempsum=0; &#125; &#125; if (maxsum&lt;0) &#123; cout&lt;&lt;0&lt;&lt;" "&lt;&lt;v[0]&lt;&lt;" "&lt;&lt;v[num-1]; return 0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;v[from]&lt;&lt;" "&lt;&lt;v[to]; return 0;&#125; ç„¶åŽä»Žç½‘ä¸Šæ‰¾åˆ°ä¸€ç§o(n)çš„æ–¹æ³•ï¼Œæ ¹æ®åˆ¤æ–­å‰é¢å­åˆ—å’Œæ˜¯å¦å°äºŽé›¶ï¼Œå¦‚å°äºŽé›¶åˆ™åªä¼šå¯¹åŽé¢çš„å’Œèµ·åä½œç”¨ï¼Œæ‰€ä»¥ç›´æŽ¥èˆå¼ƒã€‚ 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int maxsum=-1,tempsum=0,from=0,to; int num,tempindex=0; cin&gt;&gt;num; to=num-1; vector&lt;int&gt; v; for (int i=0; i&lt;num; i++) &#123; int t; cin&gt;&gt;t; v.push_back(t); &#125; for (int i=0; i&lt;num; i++) &#123; tempsum+=v[i]; if (tempsum&lt;0) &#123; tempsum=0; tempindex=i+1; &#125; else if (tempsum&gt;maxsum) &#123; maxsum=tempsum; from=tempindex; to=i; &#125; &#125; if (maxsum&lt;0) &#123; maxsum=0; &#125; cout&lt;&lt;maxsum&lt;&lt;" "&lt;&lt;v[from]&lt;&lt;" "&lt;&lt;v[to]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006. Sign In and Sign Out (25)]]></title>
    <url>%2FPAT-1006%2F</url>
    <content type="text"><![CDATA[1006. Sign In and Sign Out (25)At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing inâ€™s and outâ€™s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: 1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input: 12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output: 1SC3021234 CS301133 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int num; cin&gt;&gt;num; vector&lt;string&gt; id; //ç¼–å· vector&lt;string&gt; in; //è¿›åŽ»æ—¶é—´ vector&lt;string&gt; out; //å‡ºåŽ»æ—¶é—´ for (int i=0; i&lt;num; i++) &#123; string temp; cin&gt;&gt;temp; id.push_back(temp); cin&gt;&gt;temp; in.push_back(temp); cin&gt;&gt;temp; out.push_back(temp); &#125; int signin_id=0; int signout_id=0; int minhour=0,minmin=0,minsec=0; int maxhour=0,maxmin=0,maxsec=0;// int minsec=0;// int maxsec=0;// string maxtime="00:00:00"; /* å…ˆè®¾å®šç¬¬ä¸€æ¡æ•°æ®ä¸ºè¿›é—¨æœ€æ—©ï¼Œå¦åˆ™åˆå§‹åŒ–ä¸ºé›¶ä¼šå‡ºé”™ */ string temp=in[0]; minhour=(temp[0]-'0')*10+temp[1]-'0'; minmin=(temp[3]-'0')*10+temp[4]-'0'; minsec=(temp[6]-'0')*10+temp[7]-'0'; for (int i=0; i&lt;id.size(); i++) &#123; string temp=in[i]; int hour=(temp[0]-'0')*10+temp[1]-'0'; int min=(temp[3]-'0')*10+temp[4]-'0'; int sec=(temp[6]-'0')*10+temp[7]-'0';// int sumsec=hour*3600+min*60+sec; if (hour==minhour) &#123; if (min==minmin) &#123; if (sec&lt;minsec) &#123; minsec=sec; signin_id=i; &#125; &#125; else if (min&lt;minmin) &#123; minmin=min; signin_id=i; &#125; &#125; else if (hour&lt;minhour) &#123; minhour=hour; signin_id=i; &#125; temp=out[i]; hour=(temp[0]-'0')*10+temp[1]-'0'; min=(temp[3]-'0')*10+temp[4]-'0'; sec=(temp[6]-'0')*10+temp[7]-'0'; if (hour==maxhour) &#123; if (min==maxmin) &#123; if (sec&gt;maxsec) &#123; maxsec=sec; signout_id=i; &#125; &#125; else if (min&gt;maxmin) &#123; maxmin=min; signout_id=i; &#125; &#125; else if (hour&gt;maxhour) &#123; maxhour=hour; signout_id=i; &#125;// if (sumsec&lt;minsec) &#123;// minsec=sumsec;// signin_id=i;// &#125;// if (sumsec&gt;maxsec) &#123;// maxsec=sumsec;// signout_id=i;// &#125; &#125; cout&lt;&lt;id[signin_id]&lt;&lt;" "&lt;&lt;id[signout_id]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1005. Spell It Right (20)]]></title>
    <url>%2FPAT-1005%2F</url>
    <content type="text"><![CDATA[1005. Spell It Right (20)Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification: Each input file contains one test case. Each case occupies one line which contains an N (&lt;= 10100). Output Specification: For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input: 112345 Sample Output: 1one five ç®€å•é¢˜ï¼šå­—ç¬¦ä¸²å¤„ç† 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int sum=0; string a; cin&gt;&gt;a; for (int i=0; i&lt;a.length(); i++) &#123; /* ä¸€ä¸ªæ•°å­—å­—ç¬¦çš„ASCIIç å‡åŽ»å­—ç¬¦0çš„ASCIIç ç­‰äºŽè¯¥æ•°å­—çš„æ•°å€¼ */ sum+=a[i]-'0'; &#125; string s=to_string(sum); string chinese[10]=&#123;"zero","one","two","three","four","five","six","seven","eight","nine"&#125;; for (int j=0; j&lt;s.length()-1; j++) &#123; int temp=s[j]-'0'; cout&lt;&lt;chinese[temp]&lt;&lt;" "; &#125; cout&lt;&lt;chinese[s[s.length()-1]-'0']; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004. Counting Leaves (30)]]></title>
    <url>%2FPAT-1004%2F</url>
    <content type="text"><![CDATA[1004. Counting Leaves (30)Input Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: 1ID K ID[1] ID[2] ... ID[K] Output For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output â€œ0 1â€ in a line. Sample Input 122 101 1 02 Sample Output 10 1 BFS: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //äºŒç»´æ•°ç»„å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹int level[100]=&#123;0&#125;; //èŠ‚ç‚¹å¯¹åº”çš„å±‚æ¬¡int leafnum[100]=&#123;0&#125;; //å­˜å‚¨å¯¹åº”æ·±åº¦çš„å¶å­èŠ‚ç‚¹ä¸ªæ•°int maxlevel=0; //æœ€å¤§å±‚æ¬¡void BFS() &#123; queue&lt;int&gt; q; q.push(1); level[1]=0; while (!q.empty()) &#123; int index=q.front(); q.pop(); if (node[index].size()==0) &#123; //æ²¡æœ‰å¶å­èŠ‚ç‚¹ leafnum[level[index]]++; maxlevel=max(level[index], maxlevel); &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; q.push(node[index][i]); level[node[index][i]]=level[index]+1; &#125; &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; BFS(); for (int i=0; i&lt;maxlevel; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;" "; &#125; cout&lt;&lt;leafnum[maxlevel]; return 0;&#125; DFS: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;int&gt; node[100]; //äºŒç»´æ•°ç»„å­˜å‚¨æ‰€æœ‰èŠ‚ç‚¹//int level[100]=&#123;0&#125;;int leafnum[100]=&#123;0&#125;; //å­˜å‚¨å¯¹åº”æ·±åº¦çš„å¶å­èŠ‚ç‚¹ä¸ªæ•°//int maxlevel=0;int maxdepth=0; //æœ€å¤§æ·±åº¦//void BFS() &#123;// queue&lt;int&gt; q;// q.push(1);// level[1]=0;// while (!q.empty()) &#123;//// int index=q.front();// q.pop();//// if (node[index].size()==0) &#123;// //æ²¡æœ‰å¶å­èŠ‚ç‚¹// leafnum[level[index]]++;// maxlevel=max(level[index], maxlevel);// &#125;//// for (int i=0; i&lt;node[index].size(); i++) &#123;// q.push(node[index][i]);// level[node[index][i]]=level[index]+1;// &#125;// &#125;////&#125;void DFS(int index, int depth) &#123; maxdepth=max(depth, maxdepth); if (node[index].size()==0) &#123; leafnum[depth]++; return; &#125; for (int i=0; i&lt;node[index].size(); i++) &#123; DFS(node[index][i], depth+1); &#125; &#125;int main() &#123; int n,m,index,num,c; cin&gt;&gt;n&gt;&gt;m; for (int i=0; i&lt;m; i++) &#123; cin&gt;&gt;index&gt;&gt;num; for (int j=0; j&lt;num; j++) &#123; cin&gt;&gt;c; node[index].push_back(c); &#125; &#125; DFS(1,0); for (int i=0; i&lt;maxdepth; i++) &#123; cout&lt;&lt;leafnum[i]&lt;&lt;" "; &#125; cout&lt;&lt;leafnum[maxdepth]; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. Emergency (25)]]></title>
    <url>%2FPAT-1003%2F</url>
    <content type="text"><![CDATA[1003. Emergency (25)As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output 12 4 æ­¤é¢˜ç”¨dijastraç®—æ³•æžå®šï¼Œæžäº†ä¸¤å¤©ï¼Œå…ˆæžå®šdijastraç®—æ³•ï¼Œå†æ•´è¿™ä¸ªå˜ç§ï¼Œå‚è€ƒäº†ç½‘ä¸Šçš„åšå®¢å†™çš„ï¼Œè‡ªå·±ä¹‹å‰å†™çš„å¥½å¤šbugã€‚ æ­¤å¤„è®°ä¸€ä¸ªC++çŸ¥è¯†ç‚¹ï¼Œmemsetå‡½æ•°åˆå§‹åŒ–ä¸€ä¸ªé›†åˆã€‚ memset å‡½æ•°æ˜¯å†…å­˜èµ‹å€¼å‡½æ•°ï¼Œç”¨æ¥ç»™æŸä¸€å—å†…å­˜ç©ºé—´è¿›è¡Œèµ‹å€¼çš„ã€‚ å…¶åŽŸåž‹æ˜¯ï¼švoid memset(void _Dst, int _Val, size_t _Size) _Dstæ˜¯ç›®æ ‡èµ·å§‹åœ°å€ï¼Œ_Valæ˜¯è¦èµ‹çš„å€¼ï¼Œ_Sizeæ˜¯è¦èµ‹å€¼çš„å­—èŠ‚æ•°ã€‚ ä¾‹å¦‚ä»£ç ä¸­çš„ memset(mux, MAX, sizeof(mux)); ä¸å¤šè¯´ï¼Œè´´ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; const int MAX=1000000; const int CITY=501; int cityNum,roadNum,in,to; int rescue[CITY]; int mux[CITY][CITY]; int dis[CITY]; int amount[CITY]; int acount[CITY]; int v[MAX]; cin&gt;&gt;cityNum&gt;&gt;roadNum&gt;&gt;in&gt;&gt;to; for (int i=0; i&lt;cityNum; i++) &#123; cin&gt;&gt;rescue[i]; &#125; memset(mux, MAX, sizeof(mux)); memset(dis, MAX, sizeof(dis)); memset(v, 0, sizeof(v)); memset(amount, 0, sizeof(amount)); memset(acount, 0, sizeof(acount));// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=MAX;// for (int j=0; j&lt;cityNum; j++) &#123;// mux[i][j]=&#123;MAX&#125;;// if (i==j) &#123;// mux[i][j]=0;// &#125;// &#125;// &#125; for (int j=0; j&lt;roadNum; j++) &#123; int linka,linkb,dis; cin&gt;&gt;linka&gt;&gt;linkb&gt;&gt;dis; mux[linka][linkb]=mux[linkb][linka]=dis; &#125;// for (int i=0; i&lt;cityNum; i++) &#123;// dis[i]=mux[in][i];// v[i]=0;// &#125; dis[in]=0; acount[in]=1; amount[in]=rescue[in]; v[in]=1; for (int i=1; i&lt;cityNum; i++) &#123; int u=in,min=MAX; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0&amp;&amp;dis[i]&lt;min) &#123; min=dis[i]; u=i; &#125; &#125; // if (min==MAX||u==to) &#123;// break;// &#125; v[u]=1; for (int i=0; i&lt;cityNum; i++) &#123; if (v[i]==0) &#123; if (dis[i]&gt;dis[u]+mux[u][i]) &#123; dis[i]=dis[u]+mux[u][i]; amount[i]=amount[u]+rescue[i]; acount[i]=acount[u]; &#125; else if (dis[i]==dis[u]+mux[u][i]) &#123; acount[i]+=acount[u]; if (amount[i]&lt;amount[u]+rescue[i]) &#123; amount[i]=amount[u]+rescue[i]; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;acount[to]&lt;&lt;" "&lt;&lt;amount[to]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. A+B for Polynomials (25)]]></title>
    <url>%2FPAT-1002%2F</url>
    <content type="text"><![CDATA[1002. A+B for Polynomials (25)This time, you are supposed to find A+B where A and B are two polynomials. Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 â€¦ NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, â€¦, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10ï¼Œ0 &lt;= NK &lt; â€¦ &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output 13 2 1.5 1 2.9 0 3.2 ç¬¬äºŒé¢˜è¿˜ç®—æ˜¯ä¸ªç®€å•é¢˜ï¼Œå…³äºŽå¤šé¡¹å¼ï¼Œæ˜¯æ˜¨å¤©ACçš„ï¼Œä»Šå¤©æ¥è´´ä¸Šä»£ç ã€‚ é¦–å…ˆæ˜¯ç”¨Javaå†™çš„ï¼Œä»£ç æœ‰é—®é¢˜ï¼ŒåŽæ¥æ”¹ç”¨C++äº† ä¸å¤šè¯´ï¼Œè´´ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Map.Entry;import java.util.Scanner;import java.util.TreeMap;public class Sum1 &#123; /** * Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner=new Scanner(System.in); int num1=scanner.nextInt(); TreeMap&lt;Integer, Double&gt; map1 = new TreeMap&lt;Integer, Double&gt;(); TreeMap&lt;Integer, Double&gt; map2 = new TreeMap&lt;Integer, Double&gt;();// Map&lt;Integer, Double&gt; map1 = Collections.synchronizedMap(m1);// Map&lt;Integer, Double&gt; map2 = Collections.synchronizedMap(m2); for (int i = 0; i &lt; num1; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map1.put(key, value); &#125; int num2=scanner.nextInt(); for (int i = 0; i &lt; num2; i++) &#123; int key=scanner.nextInt(); double value=scanner.nextDouble(); map2.put(key, value); &#125; scanner.close();// synchronized (map1) &#123;// synchronized (map2) &#123;// for (int key1 : map1.keySet()) &#123;// for (int key2 : map2.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// &#125;// &#125;// &#125;// &#125;// // &#125; // for (int k2 : map2.keySet()) &#123;// for (int k1 : map1.keySet()) &#123;// if (k1==k2) &#123;// break;// &#125;// double value=map2.get(k2);// map1.put(k2, value);// &#125;// &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it1 = map1.entrySet().iterator(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; it2 = map2.entrySet().iterator(); int flag = 0; while (it2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry2 = it2.next(); while (it1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry1 = it1.next(); //System.out.println(entry2.getKey()+" "+entry1.getKey()); //System.out.println(entry1.getKey().toString().equals(entry2.getKey().toString())); if (entry1.getKey().equals(entry2.getKey())) &#123; map1.remove(entry1.getKey()); map1.put(entry1.getKey(), entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); System.out.println(entry1.getValue().doubleValue()+entry2.getValue().doubleValue()); flag=1; &#125; &#125; if (flag==0) &#123; map1.put(entry2.getKey(), entry2.getValue()); &#125; if (flag==1) &#123; flag=0; &#125; &#125; Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries1 = map1.entrySet().iterator(); while (entries1.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries1.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; System.out.println(); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries2 = map2.entrySet().iterator(); while (entries2.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries2.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; System.out.println();// for (int key1:map1.keySet()) &#123;// if (key1==key2) &#123;// map1.put(key1, map1.get(key1)+map2.get(key2));// break;// &#125;// map1.put(key2, map2.get(key2));// &#125; Map&lt;Integer, Double&gt; map=new TreeMap&lt;Integer, Double&gt;(Collections.reverseOrder()); map.putAll(map1); System.out.print(map.size() + " "); Iterator&lt;Map.Entry&lt;Integer, Double&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Double&gt; entry = entries.next(); System.out.print(entry.getKey()+" "+entry.getValue()+" "); &#125; &#125;&#125; è¿™ä¸ªæˆ‘æ˜¯ç”¨treemapæ¥å­˜å‚¨ï¼Œä½¿å¾—å…¶è‡ªåŠ¨æŽ’åºï¼ŒåŽé¢ç”¨åˆ°äº†Collections.reverseOrder() ã€‚ ä»¥ä¸‹æ˜¯C++ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main() &#123; // insert code here... float line[1001]=&#123;0&#125;; int count1,count2,m; int count=0; float n; cin&gt;&gt;count1; for (int i =0; i&lt;count1; i++) &#123; scanf("%d%f",&amp;m,&amp;n); line[m]+=n; &#125; cin&gt;&gt;count2; for (int i =0; i&lt;count2; i++) &#123; scanf("%d%f",&amp;m,&amp;n); line[m]+=n; &#125; for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; count++; &#125; &#125; printf("%d",count); for (int i=1000; i&gt;=0; i--) &#123; if (line[i]!=0) &#123; printf(" %d %.1f",i,line[i]); &#125; &#125; return 0;&#125; æ„Ÿè§‰ç”¨C++çš„æ•°ç»„å®žçŽ°ç®€å•å¾—å¤šå•Šã€‚]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001. A+B Format (20)]]></title>
    <url>%2FPAT-1001%2F</url>
    <content type="text"><![CDATA[1001. A+B Format (20)Calculate a + b and output the sum in standard format â€“ that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input 1-1000000 9 Sample Output 1-999,991 patç¬¬ä¸€é¢˜ç»ˆäºŽç¼–è¯‘é€šè¿‡äº†ï¼Œå¿…é¡»è¦class Mainæ‰è¡Œå•Š 1234567891011121314151617181920212223import java.util.Scanner;class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(); int b = scanner.nextInt(); String sum = String.valueOf(a+b); for (int i = 0; i &lt; sum.length(); i++) &#123; System.out.print(sum.charAt(i)); if (sum.charAt(i)=='-') &#123; continue; &#125; if ((i+1)%3==sum.length()%3 &amp;&amp; i!=(sum.length()-1)) &#123; System.out.print(','); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java_dynamicProxy]]></title>
    <url>%2Fjava-dynamicProxy%2F</url>
    <content type="text"><![CDATA[Springæœ‰ä¸¤å¤§æ€æƒ³ï¼Œä¸€ä¸ªæ˜¯Ioc,ä¸€ä¸ªæ˜¯AOP, AOPçš„åŽŸç†å°±æ˜¯javaçš„åŠ¨æ€ä»£ç†æœºåˆ¶ï¼Œæ‰€ä»¥æœ¬ç¯‡æ–‡ç« å°±æ˜¯å¯¹javaçš„åŠ¨æ€æœºåˆ¶çš„è§£é‡Šã€‚ åœ¨javaçš„åŠ¨æ€ä»£ç†æœºåˆ¶ä¸­ï¼Œæœ‰ä¸¤ä¸ªé‡è¦çš„ç±»æˆ–æŽ¥å£ï¼Œä¸€ä¸ªæ˜¯ InvocationHandler(Interface)ã€å¦ä¸€ä¸ªåˆ™æ˜¯ Proxy(Class)ï¼Œè¿™ä¸€ä¸ªç±»å’ŒæŽ¥å£æ˜¯å®žçŽ°æˆ‘ä»¬åŠ¨æ€ä»£ç†æ‰€å¿…é¡»ç”¨åˆ°çš„ã€‚ æ¯ä¸€ä¸ªåŠ¨æ€ä»£ç†ç±»éƒ½å¿…é¡»è¦å®žçŽ°InvocationHandlerè¿™ä¸ªæŽ¥å£ï¼Œå¹¶ä¸”æ¯ä¸ªä»£ç†ç±»çš„å®žä¾‹éƒ½å…³è”åˆ°äº†ä¸€ä¸ªhandlerï¼Œå½“æˆ‘ä»¬é€šè¿‡ä»£ç†å¯¹è±¡è°ƒç”¨ä¸€ä¸ªæ–¹æ³•çš„æ—¶å€™ï¼Œè¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨å°±ä¼šè¢«è½¬å‘ä¸ºç”±InvocationHandlerè¿™ä¸ªæŽ¥å£çš„ invoke æ–¹æ³•æ¥è¿›è¡Œè°ƒç”¨ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹InvocationHandlerè¿™ä¸ªæŽ¥å£çš„å”¯ä¸€ä¸€ä¸ªæ–¹æ³• invoke æ–¹æ³•ï¼š 12345Object invoke(Object proxy, Method method, Object[] args) throws Throwableproxy: æŒ‡ä»£æˆ‘ä»¬æ‰€ä»£ç†çš„é‚£ä¸ªçœŸå®žå¯¹è±¡method: æŒ‡ä»£çš„æ˜¯æˆ‘ä»¬æ‰€è¦è°ƒç”¨çœŸå®žå¯¹è±¡çš„æŸä¸ªæ–¹æ³•çš„Methodå¯¹è±¡args: æŒ‡ä»£çš„æ˜¯è°ƒç”¨çœŸå®žå¯¹è±¡æŸä¸ªæ–¹æ³•æ—¶æŽ¥å—çš„å‚æ•° Proxyè¿™ä¸ªç±»çš„ä½œç”¨å°±æ˜¯ç”¨æ¥åŠ¨æ€åˆ›å»ºä¸€ä¸ªä»£ç†å¯¹è±¡çš„ç±»ï¼Œå®ƒæä¾›äº†è®¸å¤šçš„æ–¹æ³•ï¼Œä½†æ˜¯æˆ‘ä»¬ç”¨çš„æœ€å¤šçš„å°±æ˜¯ newProxyInstance è¿™ä¸ªæ–¹æ³•ï¼š 1234567public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentExceptionloader: ä¸€ä¸ªClassLoaderå¯¹è±¡ï¼Œå®šä¹‰äº†ç”±å“ªä¸ªClassLoaderå¯¹è±¡æ¥å¯¹ç”Ÿæˆçš„ä»£ç†å¯¹è±¡è¿›è¡ŒåŠ è½½interfaces: ä¸€ä¸ªInterfaceå¯¹è±¡çš„æ•°ç»„ï¼Œè¡¨ç¤ºçš„æ˜¯æˆ‘å°†è¦ç»™æˆ‘éœ€è¦ä»£ç†çš„å¯¹è±¡æä¾›ä¸€ç»„ä»€ä¹ˆæŽ¥å£ï¼Œå¦‚æžœæˆ‘æä¾›äº†ä¸€ç»„æŽ¥å£ç»™å®ƒï¼Œé‚£ä¹ˆè¿™ä¸ªä»£ç†å¯¹è±¡å°±å®£ç§°å®žçŽ°äº†è¯¥æŽ¥å£(å¤šæ€)ï¼Œè¿™æ ·æˆ‘å°±èƒ½è°ƒç”¨è¿™ç»„æŽ¥å£ä¸­çš„æ–¹æ³•äº†h: ä¸€ä¸ªInvocationHandlerå¯¹è±¡ï¼Œè¡¨ç¤ºçš„æ˜¯å½“æˆ‘è¿™ä¸ªåŠ¨æ€ä»£ç†å¯¹è±¡åœ¨è°ƒç”¨æ–¹æ³•çš„æ—¶å€™ï¼Œä¼šå…³è”åˆ°å“ªä¸€ä¸ªInvocationHandlerå¯¹è±¡ä¸Š æˆ‘ä»¬æ¥é€šè¿‡ä¸€ä¸ªå®žä¾‹æ¥çœ‹çœ‹æˆ‘ä»¬çš„åŠ¨æ€ä»£ç†æ¨¡å¼æ˜¯ä»€ä¹ˆæ ·çš„ï¼š é¦–å…ˆæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªSubjectç±»åž‹çš„æŽ¥å£ï¼Œä¸ºå…¶å£°æ˜Žäº†ä¸¤ä¸ªæ–¹æ³•ï¼š 123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; æŽ¥ç€ï¼Œå®šä¹‰äº†ä¸€ä¸ªç±»æ¥å®žçŽ°è¿™ä¸ªæŽ¥å£ï¼Œè¿™ä¸ªç±»å°±æ˜¯æˆ‘ä»¬çš„çœŸå®žå¯¹è±¡ï¼ŒRealSubjectç±»ï¼š 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println("I want to rent my house"); &#125; @Override public void hello(String str) &#123; System.out.println("hello: " + str); &#125;&#125; ä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°±è¦å®šä¹‰ä¸€ä¸ªåŠ¨æ€ä»£ç†ç±»äº†ï¼Œå‰é¢è¯´ä¸ªï¼Œæ¯ä¸€ä¸ªåŠ¨æ€ä»£ç†ç±»éƒ½å¿…é¡»è¦å®žçŽ° InvocationHandler è¿™ä¸ªæŽ¥å£ï¼Œå› æ­¤æˆ‘ä»¬è¿™ä¸ªåŠ¨æ€ä»£ç†ç±»ä¹Ÿä¸ä¾‹å¤–ï¼š 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // è¿™ä¸ªå°±æ˜¯æˆ‘ä»¬è¦ä»£ç†çš„çœŸå®žå¯¹è±¡ private Object subject; // æž„é€ æ–¹æ³•ï¼Œç»™æˆ‘ä»¬è¦ä»£ç†çš„çœŸå®žå¯¹è±¡èµ‹åˆå€¼ public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // åœ¨ä»£ç†çœŸå®žå¯¹è±¡å‰æˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸€äº›è‡ªå·±çš„æ“ä½œ System.out.println("before rent house"); System.out.println("Method:" + method); // å½“ä»£ç†å¯¹è±¡è°ƒç”¨çœŸå®žå¯¹è±¡çš„æ–¹æ³•æ—¶ï¼Œå…¶ä¼šè‡ªåŠ¨çš„è·³è½¬åˆ°ä»£ç†å¯¹è±¡å…³è”çš„handlerå¯¹è±¡çš„invokeæ–¹æ³•æ¥è¿›è¡Œè°ƒç”¨ method.invoke(subject, args); // åœ¨ä»£ç†çœŸå®žå¯¹è±¡åŽæˆ‘ä»¬ä¹Ÿå¯ä»¥æ·»åŠ ä¸€äº›è‡ªå·±çš„æ“ä½œ System.out.println("after rent house"); return null; &#125;&#125; æœ€åŽï¼Œæ¥çœ‹çœ‹æˆ‘ä»¬çš„Clientç±»ï¼š 1234567891011121314151617181920212223public class Client&#123; public static void main(String[] args) &#123; // æˆ‘ä»¬è¦ä»£ç†çš„çœŸå®žå¯¹è±¡ Subject realSubject = new RealSubject(); // æˆ‘ä»¬è¦ä»£ç†å“ªä¸ªçœŸå®žå¯¹è±¡ï¼Œå°±å°†è¯¥å¯¹è±¡ä¼ è¿›åŽ»ï¼Œæœ€åŽæ˜¯é€šè¿‡è¯¥çœŸå®žå¯¹è±¡æ¥è°ƒç”¨å…¶æ–¹æ³•çš„ InvocationHandler handler = new DynamicProxy(realSubject); /* * é€šè¿‡Proxyçš„newProxyInstanceæ–¹æ³•æ¥åˆ›å»ºæˆ‘ä»¬çš„ä»£ç†å¯¹è±¡ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹å…¶ä¸‰ä¸ªå‚æ•° * ç¬¬ä¸€ä¸ªå‚æ•° handler.getClass().getClassLoader() ï¼Œæˆ‘ä»¬è¿™é‡Œä½¿ç”¨handlerè¿™ä¸ªç±»çš„ClassLoaderå¯¹è±¡æ¥åŠ è½½æˆ‘ä»¬çš„ä»£ç†å¯¹è±¡ * ç¬¬äºŒä¸ªå‚æ•°realSubject.getClass().getInterfaces()ï¼Œæˆ‘ä»¬è¿™é‡Œä¸ºä»£ç†å¯¹è±¡æä¾›çš„æŽ¥å£æ˜¯çœŸå®žå¯¹è±¡æ‰€å®žè¡Œçš„æŽ¥å£ï¼Œè¡¨ç¤ºæˆ‘è¦ä»£ç†çš„æ˜¯è¯¥çœŸå®žå¯¹è±¡ï¼Œè¿™æ ·æˆ‘å°±èƒ½è°ƒç”¨è¿™ç»„æŽ¥å£ä¸­çš„æ–¹æ³•äº† * ç¬¬ä¸‰ä¸ªå‚æ•°handlerï¼Œ æˆ‘ä»¬è¿™é‡Œå°†è¿™ä¸ªä»£ç†å¯¹è±¡å…³è”åˆ°äº†ä¸Šæ–¹çš„ InvocationHandler è¿™ä¸ªå¯¹è±¡ä¸Š */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello("world"); &#125;&#125; æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹æŽ§åˆ¶å°çš„è¾“å‡ºï¼š 1234567891011$Proxy0before rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()I want to rent my houseafter rent housebefore rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)hello: worldafter rent house æˆ‘ä»¬é¦–å…ˆæ¥çœ‹çœ‹ $Proxy0 è¿™ä¸œè¥¿ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œè¿™ä¸ªä¸œè¥¿æ˜¯ç”± System.out.println(subject.getClass().getName()); è¿™æ¡è¯­å¥æ‰“å°å‡ºæ¥çš„ï¼Œé‚£ä¹ˆä¸ºä»€ä¹ˆæˆ‘ä»¬è¿”å›žçš„è¿™ä¸ªä»£ç†å¯¹è±¡çš„ç±»åæ˜¯è¿™æ ·çš„å‘¢ï¼Ÿ 1Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); å¯èƒ½æˆ‘ä»¥ä¸ºè¿”å›žçš„è¿™ä¸ªä»£ç†å¯¹è±¡ä¼šæ˜¯Subjectç±»åž‹çš„å¯¹è±¡ï¼Œæˆ–è€…æ˜¯InvocationHandlerçš„å¯¹è±¡ï¼Œç»“æžœå´ä¸æ˜¯ï¼Œé¦–å…ˆæˆ‘ä»¬è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆæˆ‘ä»¬è¿™é‡Œå¯ä»¥å°†å…¶è½¬åŒ–ä¸ºSubjectç±»åž‹çš„å¯¹è±¡ï¼ŸåŽŸå› å°±æ˜¯åœ¨newProxyInstanceè¿™ä¸ªæ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°ä¸Šï¼Œæˆ‘ä»¬ç»™è¿™ä¸ªä»£ç†å¯¹è±¡æä¾›äº†ä¸€ç»„ä»€ä¹ˆæŽ¥å£ï¼Œé‚£ä¹ˆæˆ‘è¿™ä¸ªä»£ç†å¯¹è±¡å°±ä¼šå®žçŽ°äº†è¿™ç»„æŽ¥å£ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å½“ç„¶å¯ä»¥å°†è¿™ä¸ªä»£ç†å¯¹è±¡å¼ºåˆ¶ç±»åž‹è½¬åŒ–ä¸ºè¿™ç»„æŽ¥å£ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œå› ä¸ºè¿™é‡Œçš„æŽ¥å£æ˜¯Subjectç±»åž‹ï¼Œæ‰€ä»¥å°±å¯ä»¥å°†å…¶è½¬åŒ–ä¸ºSubjectç±»åž‹äº†ã€‚ åŒæ—¶æˆ‘ä»¬ä¸€å®šè¦è®°ä½ï¼Œé€šè¿‡ Proxy.newProxyInstance åˆ›å»ºçš„ä»£ç†å¯¹è±¡æ˜¯åœ¨jvmè¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆçš„ä¸€ä¸ªå¯¹è±¡ï¼Œå®ƒå¹¶ä¸æ˜¯æˆ‘ä»¬çš„InvocationHandlerç±»åž‹ï¼Œä¹Ÿä¸æ˜¯æˆ‘ä»¬å®šä¹‰çš„é‚£ç»„æŽ¥å£çš„ç±»åž‹ï¼Œè€Œæ˜¯åœ¨è¿è¡Œæ˜¯åŠ¨æ€ç”Ÿæˆçš„ä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä¸”å‘½åæ–¹å¼éƒ½æ˜¯è¿™æ ·çš„å½¢å¼ï¼Œä»¥$å¼€å¤´ï¼Œproxyä¸ºä¸­ï¼Œæœ€åŽä¸€ä¸ªæ•°å­—è¡¨ç¤ºå¯¹è±¡çš„æ ‡å·ã€‚ è¿™é‡Œæ˜¯é€šè¿‡ä»£ç†å¯¹è±¡æ¥è°ƒç”¨å®žçŽ°çš„é‚£ç§æŽ¥å£ä¸­çš„æ–¹æ³•ï¼Œè¿™ä¸ªæ—¶å€™ç¨‹åºå°±ä¼šè·³è½¬åˆ°ç”±è¿™ä¸ªä»£ç†å¯¹è±¡å…³è”åˆ°çš„ handler ä¸­çš„invokeæ–¹æ³•åŽ»æ‰§è¡Œï¼Œè€Œæˆ‘ä»¬çš„è¿™ä¸ª handler å¯¹è±¡åˆæŽ¥å—äº†ä¸€ä¸ª RealSubjectç±»åž‹çš„å‚æ•°ï¼Œè¡¨ç¤ºæˆ‘è¦ä»£ç†çš„å°±æ˜¯è¿™ä¸ªçœŸå®žå¯¹è±¡ï¼Œæ‰€ä»¥æ­¤æ—¶å°±ä¼šè°ƒç”¨ handler ä¸­çš„invokeæ–¹æ³•åŽ»æ‰§è¡Œï¼š 12345678910111213141516public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // åœ¨ä»£ç†çœŸå®žå¯¹è±¡å‰æˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸€äº›è‡ªå·±çš„æ“ä½œ System.out.println("before rent house"); System.out.println("Method:" + method); // å½“ä»£ç†å¯¹è±¡è°ƒç”¨çœŸå®žå¯¹è±¡çš„æ–¹æ³•æ—¶ï¼Œå…¶ä¼šè‡ªåŠ¨çš„è·³è½¬åˆ°ä»£ç†å¯¹è±¡å…³è”çš„handlerå¯¹è±¡çš„invokeæ–¹æ³•æ¥è¿›è¡Œè°ƒç”¨ method.invoke(subject, args); // åœ¨ä»£ç†çœŸå®žå¯¹è±¡åŽæˆ‘ä»¬ä¹Ÿå¯ä»¥æ·»åŠ ä¸€äº›è‡ªå·±çš„æ“ä½œ System.out.println("after rent house"); return null; &#125; æˆ‘ä»¬çœ‹åˆ°ï¼Œåœ¨çœŸæ­£é€šè¿‡ä»£ç†å¯¹è±¡æ¥è°ƒç”¨çœŸå®žå¯¹è±¡çš„æ–¹æ³•çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¯¥æ–¹æ³•å‰åŽæ·»åŠ è‡ªå·±çš„ä¸€äº›æ“ä½œï¼ŒåŒæ—¶æˆ‘ä»¬çœ‹åˆ°æˆ‘ä»¬çš„è¿™ä¸ª method å¯¹è±¡æ˜¯è¿™æ ·çš„ï¼š 123public abstract void com.xiaoluo.dynamicproxy.Subject.rent()public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String) æ­£å¥½å°±æ˜¯æˆ‘ä»¬çš„SubjectæŽ¥å£ä¸­çš„ä¸¤ä¸ªæ–¹æ³•ï¼Œè¿™ä¹Ÿå°±è¯æ˜Žäº†å½“æˆ‘é€šè¿‡ä»£ç†å¯¹è±¡æ¥è°ƒç”¨æ–¹æ³•çš„æ—¶å€™ï¼Œèµ·å®žé™…å°±æ˜¯å§”æ‰˜ç”±å…¶å…³è”åˆ°çš„ handler å¯¹è±¡çš„invokeæ–¹æ³•ä¸­æ¥è°ƒç”¨ï¼Œå¹¶ä¸æ˜¯è‡ªå·±æ¥çœŸå®žè°ƒç”¨ï¼Œè€Œæ˜¯é€šè¿‡ä»£ç†çš„æ–¹å¼æ¥è°ƒç”¨çš„ã€‚]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åœ¨hexo newä¹‹åŽç«‹å³æ‰“å¼€Markdownæ–‡ç¨¿]]></title>
    <url>%2Fhexo-openPostQuick%2F</url>
    <content type="text"><![CDATA[ç”±äºŽæ¯æ¬¡ä½¿ç”¨hexo newæ–°å»ºä¹‹åŽéƒ½è¦åˆ°æ–‡ä»¶å¤¹é‡Œè‡ªå·±åŽ»æ‰¾å‡ºæ–‡ä»¶å†æ‰“å¼€ï¼Œå½“æ–‡ä»¶å¤šèµ·æ¥æ›´æ˜¯ä»¶éº»çƒ¦äº‹ã€‚åŸºäºŽæ­¤ï¼Œåœ¨ç½‘ä¸Šå‘çŽ°æœ‰ç›´æŽ¥èƒ½åœ¨æ–°å»ºå®ŒåŽè‡ªåŠ¨æ‰“å¼€markdownæ–‡æ¡£çš„jsè„šæœ¬ï¼Œæ€€ç€è¯•ä¸€è¯•çš„å¿ƒæ€æŒ‰ç€æ­¥éª¤èµ°ï¼Œæœ€åŽæˆåŠŸäº†ã€‚ é¦–å…ˆå®‰è£… shelljsæ¨¡å—ï¼Œå®žçŽ°è‡ªåŠ¨éƒ¨ç½²åŠ è½½JSè„šæœ¬ï¼Œé”®å…¥ä»¥ä¸‹å‘½ä»¤ï¼š 1npm install --save shelljs åœ¨ Hexo æ ¹ç›®å½•çš„ scriptsæ–‡ä»¶å¤¹ä¸‹æ–°å»ºä¸€ä¸ª jsæ–‡ä»¶ã€‚æ­¤å¤„jsè„šæœ¬æ ¹æ®hexoç‰ˆæœ¬è€Œå®šã€‚æˆ‘çš„æ˜¯hexo-cli:1.0.3 ç¨å¾®ä¿®æ”¹åŽç”¨è¿™ä¸ªè„šæœ¬æˆåŠŸï¼š 12345var exec = require('child_process').exec; hexo.on('new', function(data)&#123; exec('open -a "/Applications/Typora.app" ' + [data.path]);&#125;); æœ€åŽä¸€è¡Œé‡Œé¢æ‰§è¡Œçš„æ˜¯ç³»ç»Ÿå‘½ä»¤open -a â€œ/Applications/Typora.appâ€ path,ç›´æŽ¥å°±å¯ä»¥åœ¨ç»ˆç«¯ç”¨å‘½ä»¤æ‰“å¼€ï¼Œæ˜¯ OS X ä¸‹çš„openã€‚æ¢åˆ°Windowsä¸­,å¯èƒ½éœ€è¦æ”¹ä¸ºstartã€‚]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Classç±»åŠ è½½æœºåˆ¶]]></title>
    <url>%2Fjvm-leijiazai%2F</url>
    <content type="text"><![CDATA[ç±»åŠ è½½è¿‡ç¨‹Javaç±»ä»Žè¢«åŠ è½½åˆ°è™šæ‹Ÿæœºå†…å­˜ä¸­å¼€å§‹ï¼Œåˆ°å¸è½½å‡ºå†…å­˜ä¸ºæ­¢ï¼Œå®ƒçš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸåŒ…æ‹¬ï¼šåŠ è½½ã€éªŒè¯ã€å‡†å¤‡ã€è§£æžã€åˆå§‹åŒ–ã€ä½¿ç”¨å’Œå¸è½½ä¸ƒä¸ªé˜¶æ®µã€‚å®ƒä»¬å¼€å§‹çš„é¡ºåºå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å…¶ä¸­ç±»åŠ è½½çš„è¿‡ç¨‹åŒ…æ‹¬äº†åŠ è½½ã€éªŒè¯ã€å‡†å¤‡ã€è§£æžã€åˆå§‹åŒ–äº”ä¸ªé˜¶æ®µã€‚åœ¨è¿™äº”ä¸ªé˜¶æ®µä¸­ï¼ŒåŠ è½½ã€éªŒè¯ã€å‡†å¤‡å’Œåˆå§‹åŒ–è¿™å››ä¸ªé˜¶æ®µå‘ç”Ÿçš„é¡ºåºæ˜¯ç¡®å®šçš„ï¼Œè€Œè§£æžé˜¶æ®µåˆ™ä¸ä¸€å®šï¼Œå®ƒåœ¨æŸäº›æƒ…å†µä¸‹å¯ä»¥åœ¨åˆå§‹åŒ–é˜¶æ®µä¹‹åŽå¼€å§‹ï¼Œè¿™æ˜¯ä¸ºäº†æ”¯æŒJavaè¯­è¨€çš„è¿è¡Œæ—¶ç»‘å®šï¼ˆä¹Ÿæˆä¸ºåŠ¨æ€ç»‘å®šæˆ–æ™šæœŸç»‘å®šï¼‰ã€‚å¦å¤–æ³¨æ„è¿™é‡Œçš„å‡ ä¸ªé˜¶æ®µæ˜¯æŒ‰é¡ºåºå¼€å§‹ï¼Œè€Œä¸æ˜¯æŒ‰é¡ºåºè¿›è¡Œæˆ–å®Œæˆï¼Œå› ä¸ºè¿™äº›é˜¶æ®µé€šå¸¸éƒ½æ˜¯äº’ç›¸äº¤å‰åœ°æ··åˆè¿›è¡Œçš„ï¼Œé€šå¸¸åœ¨ä¸€ä¸ªé˜¶æ®µæ‰§è¡Œçš„è¿‡ç¨‹ä¸­è°ƒç”¨æˆ–æ¿€æ´»å¦ä¸€ä¸ªé˜¶æ®µã€‚ â€‹ è¿™é‡Œç®€è¦è¯´æ˜Žä¸‹Javaä¸­çš„ç»‘å®šï¼šç»‘å®šæŒ‡çš„æ˜¯æŠŠä¸€ä¸ªæ–¹æ³•çš„è°ƒç”¨ä¸Žæ–¹æ³•æ‰€åœ¨çš„ç±»(æ–¹æ³•ä¸»ä½“)å…³è”èµ·æ¥ï¼Œå¯¹javaæ¥è¯´ï¼Œç»‘å®šåˆ†ä¸ºé™æ€ç»‘å®šå’ŒåŠ¨æ€ç»‘å®šï¼š é™æ€ç»‘å®šï¼šå³å‰æœŸç»‘å®šã€‚åœ¨ç¨‹åºæ‰§è¡Œå‰æ–¹æ³•å·²ç»è¢«ç»‘å®šï¼Œæ­¤æ—¶ç”±ç¼–è¯‘å™¨æˆ–å…¶å®ƒè¿žæŽ¥ç¨‹åºå®žçŽ°ã€‚é’ˆå¯¹javaï¼Œç®€å•çš„å¯ä»¥ç†è§£ä¸ºç¨‹åºç¼–è¯‘æœŸçš„ç»‘å®šã€‚javaå½“ä¸­çš„æ–¹æ³•åªæœ‰finalï¼Œstaticï¼Œprivateå’Œæž„é€ æ–¹æ³•æ˜¯å‰æœŸç»‘å®šçš„ã€‚ åŠ¨æ€ç»‘å®šï¼šå³æ™šæœŸç»‘å®šï¼Œä¹Ÿå«è¿è¡Œæ—¶ç»‘å®šã€‚åœ¨è¿è¡Œæ—¶æ ¹æ®å…·ä½“å¯¹è±¡çš„ç±»åž‹è¿›è¡Œç»‘å®šã€‚åœ¨javaä¸­ï¼Œå‡ ä¹Žæ‰€æœ‰çš„æ–¹æ³•éƒ½æ˜¯åŽæœŸç»‘å®šçš„ã€‚ â€‹ ä¸‹é¢è¯¦ç»†è®²è¿°ç±»åŠ è½½è¿‡ç¨‹ä¸­æ¯ä¸ªé˜¶æ®µæ‰€åšçš„å·¥ä½œã€‚ åŠ è½½â€‹ åŠ è½½æ—¶ç±»åŠ è½½è¿‡ç¨‹çš„ç¬¬ä¸€ä¸ªé˜¶æ®µï¼Œåœ¨åŠ è½½é˜¶æ®µï¼Œè™šæ‹Ÿæœºéœ€è¦å®Œæˆä»¥ä¸‹ä¸‰ä»¶äº‹æƒ…ï¼š â€‹ 1ã€é€šè¿‡ä¸€ä¸ªç±»çš„å…¨é™å®šåæ¥èŽ·å–å…¶å®šä¹‰çš„äºŒè¿›åˆ¶å­—èŠ‚æµã€‚ â€‹ 2ã€å°†è¿™ä¸ªå­—èŠ‚æµæ‰€ä»£è¡¨çš„é™æ€å­˜å‚¨ç»“æž„è½¬åŒ–ä¸ºæ–¹æ³•åŒºçš„è¿è¡Œæ—¶æ•°æ®ç»“æž„ã€‚ â€‹ 3ã€åœ¨Javaå †ä¸­ç”Ÿæˆä¸€ä¸ªä»£è¡¨è¿™ä¸ªç±»çš„java.lang.Classå¯¹è±¡ï¼Œä½œä¸ºå¯¹æ–¹æ³•åŒºä¸­è¿™äº›æ•°æ®çš„è®¿é—®å…¥å£ã€‚ â€‹ æ³¨æ„ï¼Œè¿™é‡Œç¬¬1æ¡ä¸­çš„äºŒè¿›åˆ¶å­—èŠ‚æµå¹¶ä¸åªæ˜¯å•çº¯åœ°ä»ŽClassæ–‡ä»¶ä¸­èŽ·å–ï¼Œæ¯”å¦‚å®ƒè¿˜å¯ä»¥ä»ŽJaråŒ…ä¸­èŽ·å–ã€ä»Žç½‘ç»œä¸­èŽ·å–ï¼ˆæœ€å…¸åž‹çš„åº”ç”¨ä¾¿æ˜¯Appletï¼‰ã€ç”±å…¶ä»–æ–‡ä»¶ç”Ÿæˆï¼ˆJSPåº”ç”¨ï¼‰ç­‰ã€‚ â€‹ ç›¸å¯¹äºŽç±»åŠ è½½çš„å…¶ä»–é˜¶æ®µè€Œè¨€ï¼ŒåŠ è½½é˜¶æ®µï¼ˆå‡†ç¡®åœ°è¯´ï¼Œæ˜¯åŠ è½½é˜¶æ®µèŽ·å–ç±»çš„äºŒè¿›åˆ¶å­—èŠ‚æµçš„åŠ¨ä½œï¼‰æ˜¯å¯æŽ§æ€§æœ€å¼ºçš„é˜¶æ®µï¼Œå› ä¸ºå¼€å‘äººå‘˜æ—¢å¯ä»¥ä½¿ç”¨ç³»ç»Ÿæä¾›çš„ç±»åŠ è½½å™¨æ¥å®ŒæˆåŠ è½½ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰è‡ªå·±çš„ç±»åŠ è½½å™¨æ¥å®ŒæˆåŠ è½½ã€‚ â€‹ åŠ è½½é˜¶æ®µå®ŒæˆåŽï¼Œè™šæ‹Ÿæœºå¤–éƒ¨çš„ äºŒè¿›åˆ¶å­—èŠ‚æµå°±æŒ‰ç…§è™šæ‹Ÿæœºæ‰€éœ€çš„æ ¼å¼å­˜å‚¨åœ¨æ–¹æ³•åŒºä¹‹ä¸­ï¼Œè€Œä¸”åœ¨Javaå †ä¸­ä¹Ÿåˆ›å»ºä¸€ä¸ªjava.lang.Classç±»çš„å¯¹è±¡ï¼Œè¿™æ ·ä¾¿å¯ä»¥é€šè¿‡è¯¥å¯¹è±¡è®¿é—®æ–¹æ³•åŒºä¸­çš„è¿™äº›æ•°æ®ã€‚ â€‹ è¯´åˆ°åŠ è½½ï¼Œä¸å¾—ä¸æåˆ°ç±»åŠ è½½å™¨ï¼Œä¸‹é¢å°±å…·ä½“è®²è¿°ä¸‹ç±»åŠ è½½å™¨ã€‚ â€‹ ç±»åŠ è½½å™¨è™½ç„¶åªç”¨äºŽå®žçŽ°ç±»çš„åŠ è½½åŠ¨ä½œï¼Œä½†å®ƒåœ¨Javaç¨‹åºä¸­èµ·åˆ°çš„ä½œç”¨å´è¿œè¿œä¸é™äºŽç±»çš„åŠ è½½é˜¶æ®µã€‚å¯¹äºŽä»»æ„ä¸€ä¸ªç±»ï¼Œéƒ½éœ€è¦ç”±å®ƒçš„ç±»åŠ è½½å™¨å’Œè¿™ä¸ªç±»æœ¬èº«ä¸€åŒç¡®å®šå…¶åœ¨å°±Javaè™šæ‹Ÿæœºä¸­çš„å”¯ä¸€æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå³ä½¿ä¸¤ä¸ªç±»æ¥æºäºŽåŒä¸€ä¸ªClassæ–‡ä»¶ï¼Œåªè¦åŠ è½½å®ƒä»¬çš„ç±»åŠ è½½å™¨ä¸åŒï¼Œé‚£è¿™ä¸¤ä¸ªç±»å°±å¿…å®šä¸ç›¸ç­‰ã€‚è¿™é‡Œçš„â€œç›¸ç­‰â€åŒ…æ‹¬äº†ä»£è¡¨ç±»çš„Classå¯¹è±¡çš„equalsï¼ˆï¼‰ã€isAssignableFromï¼ˆï¼‰ã€isInstanceï¼ˆï¼‰ç­‰æ–¹æ³•çš„è¿”å›žç»“æžœï¼Œä¹ŸåŒ…æ‹¬äº†ä½¿ç”¨instanceofå…³é”®å­—å¯¹å¯¹è±¡æ‰€å±žå…³ç³»çš„åˆ¤å®šç»“æžœã€‚ â€‹ ç«™åœ¨Javaè™šæ‹Ÿæœºçš„è§’åº¦æ¥è®²ï¼Œåªå­˜åœ¨ä¸¤ç§ä¸åŒçš„ç±»åŠ è½½å™¨ï¼š å¯åŠ¨ç±»åŠ è½½å™¨ï¼šå®ƒä½¿ç”¨C++å®žçŽ°ï¼ˆè¿™é‡Œä»…é™äºŽHotspotï¼Œä¹Ÿå°±æ˜¯JDK1.5ä¹‹åŽé»˜è®¤çš„è™šæ‹Ÿæœºï¼Œæœ‰å¾ˆå¤šå…¶ä»–çš„è™šæ‹Ÿæœºæ˜¯ç”¨Javaè¯­è¨€å®žçŽ°çš„ï¼‰,æ˜¯è™šæ‹Ÿæœºè‡ªèº«çš„ä¸€éƒ¨åˆ†ã€‚ æ‰€æœ‰å…¶ä»–çš„ç±»åŠ è½½å™¨ï¼šè¿™äº›ç±»åŠ è½½å™¨éƒ½ç”±Javaè¯­è¨€å®žçŽ°ï¼Œç‹¬ç«‹äºŽè™šæ‹Ÿæœºä¹‹å¤–ï¼Œå¹¶ä¸”å…¨éƒ¨ç»§æ‰¿è‡ªæŠ½è±¡ç±»java.lang.ClassLoaderï¼Œè¿™äº›ç±»åŠ è½½å™¨éœ€è¦ç”±å¯åŠ¨ç±»åŠ è½½å™¨åŠ è½½åˆ°å†…å­˜ä¸­ä¹‹åŽæ‰èƒ½åŽ»åŠ è½½å…¶ä»–çš„ç±»ã€‚ â€‹ ç«™åœ¨Javaå¼€å‘äººå‘˜çš„è§’åº¦æ¥çœ‹ï¼Œç±»åŠ è½½å™¨å¯ä»¥å¤§è‡´åˆ’åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»ï¼š å¯åŠ¨ç±»åŠ è½½å™¨ï¼šBootstrap ClassLoaderï¼Œè·Ÿä¸Šé¢ç›¸åŒã€‚å®ƒè´Ÿè´£åŠ è½½å­˜æ”¾åœ¨JDK\jre\lib(JDKä»£è¡¨JDKçš„å®‰è£…ç›®å½•ï¼Œä¸‹åŒ)ä¸‹ï¼Œæˆ–è¢«-Xbootclasspathå‚æ•°æŒ‡å®šçš„è·¯å¾„ä¸­çš„ï¼Œå¹¶ä¸”èƒ½è¢«è™šæ‹Ÿæœºè¯†åˆ«çš„ç±»åº“ï¼ˆå¦‚rt.jarï¼Œæ‰€æœ‰çš„java.*å¼€å¤´çš„ç±»å‡è¢«Bootstrap ClassLoaderåŠ è½½ï¼‰ã€‚å¯åŠ¨ç±»åŠ è½½å™¨æ˜¯æ— æ³•è¢«Javaç¨‹åºç›´æŽ¥å¼•ç”¨çš„ã€‚ æ‰©å±•ç±»åŠ è½½å™¨ï¼šExtension ClassLoaderï¼Œè¯¥åŠ è½½å™¨ç”±sun.misc.Launcher$ExtClassLoaderå®žçŽ°ï¼Œå®ƒè´Ÿè´£åŠ è½½JDK\jre\lib\extç›®å½•ä¸­ï¼Œæˆ–è€…ç”±java.ext.dirsç³»ç»Ÿå˜é‡æŒ‡å®šçš„è·¯å¾„ä¸­çš„æ‰€æœ‰ç±»åº“ï¼ˆå¦‚javax.*å¼€å¤´çš„ç±»ï¼‰,å¼€å‘è€…å¯ä»¥ç›´æŽ¥ä½¿ç”¨æ‰©å±•ç±»åŠ è½½å™¨ã€‚ åº”ç”¨ç¨‹åºç±»åŠ è½½å™¨ï¼šApplication ClassLoaderï¼Œè¯¥ç±»åŠ è½½å™¨ç”±sun.misc.Launcher$AppClassLoaderæ¥å®žçŽ°ï¼Œå®ƒè´Ÿè´£åŠ è½½ç”¨æˆ·ç±»è·¯å¾„ï¼ˆClassPathï¼‰æ‰€æŒ‡å®šçš„ç±»ï¼Œå¼€å‘è€…å¯ä»¥ç›´æŽ¥ä½¿ç”¨è¯¥ç±»åŠ è½½å™¨ï¼Œå¦‚æžœåº”ç”¨ç¨‹åºä¸­æ²¡æœ‰è‡ªå®šä¹‰è¿‡è‡ªå·±çš„ç±»åŠ è½½å™¨ï¼Œä¸€èˆ¬æƒ…å†µä¸‹è¿™ä¸ªå°±æ˜¯ç¨‹åºä¸­é»˜è®¤çš„ç±»åŠ è½½å™¨ã€‚ â€‹ åº”ç”¨ç¨‹åºéƒ½æ˜¯ç”±è¿™ä¸‰ç§ç±»åŠ è½½å™¨äº’ç›¸é…åˆè¿›è¡ŒåŠ è½½çš„ï¼Œå¦‚æžœæœ‰å¿…è¦ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åŠ å…¥è‡ªå®šä¹‰çš„ç±»åŠ è½½å™¨ã€‚å› ä¸ºJVMè‡ªå¸¦çš„ClassLoaderåªæ˜¯æ‡‚å¾—ä»Žæœ¬åœ°æ–‡ä»¶ç³»ç»ŸåŠ è½½æ ‡å‡†çš„java classæ–‡ä»¶ï¼Œå› æ­¤å¦‚æžœç¼–å†™äº†è‡ªå·±çš„ClassLoaderï¼Œä¾¿å¯ä»¥åšåˆ°å¦‚ä¸‹å‡ ç‚¹ï¼š 1ï¼‰åœ¨æ‰§è¡Œéžç½®ä¿¡ä»£ç ä¹‹å‰ï¼Œè‡ªåŠ¨éªŒè¯æ•°å­—ç­¾åã€‚ 2ï¼‰åŠ¨æ€åœ°åˆ›å»ºç¬¦åˆç”¨æˆ·ç‰¹å®šéœ€è¦çš„å®šåˆ¶åŒ–æž„å»ºç±»ã€‚ 3ï¼‰ä»Žç‰¹å®šçš„åœºæ‰€å–å¾—java classï¼Œä¾‹å¦‚æ•°æ®åº“ä¸­å’Œç½‘ç»œä¸­ã€‚ äº‹å®žä¸Šå½“ä½¿ç”¨Appletçš„æ—¶å€™ï¼Œå°±ç”¨åˆ°äº†ç‰¹å®šçš„ClassLoaderï¼Œå› ä¸ºè¿™æ—¶éœ€è¦ä»Žç½‘ç»œä¸ŠåŠ è½½java classï¼Œå¹¶ä¸”è¦æ£€æŸ¥ç›¸å…³çš„å®‰å…¨ä¿¡æ¯ï¼Œåº”ç”¨æœåŠ¡å™¨ä¹Ÿå¤§éƒ½ä½¿ç”¨äº†è‡ªå®šä¹‰çš„ClassLoaderæŠ€æœ¯ã€‚ â€‹ è¿™å‡ ç§ç±»åŠ è½½å™¨çš„å±‚æ¬¡å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š â€‹ è¿™ç§å±‚æ¬¡å…³ç³»ç§°ä¸ºç±»åŠ è½½å™¨çš„åŒäº²å§”æ´¾æ¨¡åž‹ã€‚æˆ‘ä»¬æŠŠæ¯ä¸€å±‚ä¸Šé¢çš„ç±»åŠ è½½å™¨å«åšå½“å‰å±‚ç±»åŠ è½½å™¨çš„çˆ¶åŠ è½½å™¨ï¼Œå½“ç„¶ï¼Œå®ƒä»¬ä¹‹é—´çš„çˆ¶å­å…³ç³»å¹¶ä¸æ˜¯é€šè¿‡ç»§æ‰¿å…³ç³»æ¥å®žçŽ°çš„ï¼Œè€Œæ˜¯ä½¿ç”¨ç»„åˆå…³ç³»æ¥å¤ç”¨çˆ¶åŠ è½½å™¨ä¸­çš„ä»£ç ã€‚è¯¥æ¨¡åž‹åœ¨JDK1.2æœŸé—´è¢«å¼•å…¥å¹¶å¹¿æ³›åº”ç”¨äºŽä¹‹åŽå‡ ä¹Žæ‰€æœ‰çš„Javaç¨‹åºä¸­ï¼Œä½†å®ƒå¹¶ä¸æ˜¯ä¸€ä¸ªå¼ºåˆ¶æ€§çš„çº¦æŸæ¨¡åž‹ï¼Œè€Œæ˜¯Javaè®¾è®¡è€…ä»¬æŽ¨èç»™å¼€å‘è€…çš„ä¸€ç§ç±»çš„åŠ è½½å™¨å®žçŽ°æ–¹å¼ã€‚ â€‹ åŒäº²å§”æ´¾æ¨¡åž‹çš„å·¥ä½œæµç¨‹æ˜¯ï¼šå¦‚æžœä¸€ä¸ªç±»åŠ è½½å™¨æ”¶åˆ°äº†ç±»åŠ è½½çš„è¯·æ±‚ï¼Œå®ƒé¦–å…ˆä¸ä¼šè‡ªå·±åŽ»å°è¯•åŠ è½½è¿™ä¸ªç±»ï¼Œè€Œæ˜¯æŠŠè¯·æ±‚å§”æ‰˜ç»™çˆ¶åŠ è½½å™¨åŽ»å®Œæˆï¼Œä¾æ¬¡å‘ä¸Šï¼Œå› æ­¤ï¼Œæ‰€æœ‰çš„ç±»åŠ è½½è¯·æ±‚æœ€ç»ˆéƒ½åº”è¯¥è¢«ä¼ é€’åˆ°é¡¶å±‚çš„å¯åŠ¨ç±»åŠ è½½å™¨ä¸­ï¼Œåªæœ‰å½“çˆ¶åŠ è½½å™¨åœ¨å®ƒçš„æœç´¢èŒƒå›´ä¸­æ²¡æœ‰æ‰¾åˆ°æ‰€éœ€çš„ç±»æ—¶ï¼Œå³æ— æ³•å®Œæˆè¯¥åŠ è½½ï¼Œå­åŠ è½½å™¨æ‰ä¼šå°è¯•è‡ªå·±åŽ»åŠ è½½è¯¥ç±»ã€‚ â€‹ ä½¿ç”¨åŒäº²å§”æ´¾æ¨¡åž‹æ¥ç»„ç»‡ç±»åŠ è½½å™¨ä¹‹é—´çš„å…³ç³»ï¼Œæœ‰ä¸€ä¸ªå¾ˆæ˜Žæ˜¾çš„å¥½å¤„ï¼Œå°±æ˜¯Javaç±»éšç€å®ƒçš„ç±»åŠ è½½å™¨ï¼ˆè¯´ç™½äº†ï¼Œå°±æ˜¯å®ƒæ‰€åœ¨çš„ç›®å½•ï¼‰ä¸€èµ·å…·å¤‡äº†ä¸€ç§å¸¦æœ‰ä¼˜å…ˆçº§çš„å±‚æ¬¡å…³ç³»ï¼Œè¿™å¯¹äºŽä¿è¯Javaç¨‹åºçš„ç¨³å®šè¿ä½œå¾ˆé‡è¦ã€‚ä¾‹å¦‚ï¼Œç±»java.lang.Objectç±»å­˜æ”¾åœ¨JDK\jre\libä¸‹çš„rt.jarä¹‹ä¸­ï¼Œå› æ­¤æ— è®ºæ˜¯å“ªä¸ªç±»åŠ è½½å™¨è¦åŠ è½½æ­¤ç±»ï¼Œæœ€ç»ˆéƒ½ä¼šå§”æ´¾ç»™å¯åŠ¨ç±»åŠ è½½å™¨è¿›è¡ŒåŠ è½½ï¼Œè¿™è¾¹ä¿è¯äº†Objectç±»åœ¨ç¨‹åºä¸­çš„å„ç§ç±»åŠ è½½å™¨ä¸­éƒ½æ˜¯åŒä¸€ä¸ªç±»ã€‚ éªŒè¯â€‹ éªŒè¯çš„ç›®çš„æ˜¯ä¸ºäº†ç¡®ä¿Classæ–‡ä»¶ä¸­çš„å­—èŠ‚æµåŒ…å«çš„ä¿¡æ¯ç¬¦åˆå½“å‰è™šæ‹Ÿæœºçš„è¦æ±‚ï¼Œè€Œä¸”ä¸ä¼šå±å®³è™šæ‹Ÿæœºè‡ªèº«çš„å®‰å…¨ã€‚ä¸åŒçš„è™šæ‹Ÿæœºå¯¹ç±»éªŒè¯çš„å®žçŽ°å¯èƒ½ä¼šæœ‰æ‰€ä¸åŒï¼Œä½†å¤§è‡´éƒ½ä¼šå®Œæˆä»¥ä¸‹å››ä¸ªé˜¶æ®µçš„éªŒè¯ï¼šæ–‡ä»¶æ ¼å¼çš„éªŒè¯ã€å…ƒæ•°æ®çš„éªŒè¯ã€å­—èŠ‚ç éªŒè¯å’Œç¬¦å·å¼•ç”¨éªŒè¯ã€‚ æ–‡ä»¶æ ¼å¼çš„éªŒè¯ï¼šéªŒè¯å­—èŠ‚æµæ˜¯å¦ç¬¦åˆClassæ–‡ä»¶æ ¼å¼çš„è§„èŒƒï¼Œå¹¶ä¸”èƒ½è¢«å½“å‰ç‰ˆæœ¬çš„è™šæ‹Ÿæœºå¤„ç†ï¼Œè¯¥éªŒè¯çš„ä¸»è¦ç›®çš„æ˜¯ä¿è¯è¾“å…¥çš„å­—èŠ‚æµèƒ½æ­£ç¡®åœ°è§£æžå¹¶å­˜å‚¨äºŽæ–¹æ³•åŒºä¹‹å†…ã€‚ç»è¿‡è¯¥é˜¶æ®µçš„éªŒè¯åŽï¼Œå­—èŠ‚æµæ‰ä¼šè¿›å…¥å†…å­˜çš„æ–¹æ³•åŒºä¸­è¿›è¡Œå­˜å‚¨ï¼ŒåŽé¢çš„ä¸‰ä¸ªéªŒè¯éƒ½æ˜¯åŸºäºŽæ–¹æ³•åŒºçš„å­˜å‚¨ç»“æž„è¿›è¡Œçš„ã€‚ å…ƒæ•°æ®éªŒè¯ï¼šå¯¹ç±»çš„å…ƒæ•°æ®ä¿¡æ¯è¿›è¡Œè¯­ä¹‰æ ¡éªŒï¼ˆå…¶å®žå°±æ˜¯å¯¹ç±»ä¸­çš„å„æ•°æ®ç±»åž‹è¿›è¡Œè¯­æ³•æ ¡éªŒï¼‰,ä¿è¯ä¸å­˜åœ¨ä¸ç¬¦åˆJavaè¯­æ³•è§„èŒƒçš„å…ƒæ•°æ®ä¿¡æ¯ã€‚ å­—èŠ‚ç éªŒè¯ï¼šè¯¥é˜¶æ®µéªŒè¯çš„ä¸»è¦å·¥ä½œæ˜¯è¿›è¡Œæ•°æ®æµå’ŒæŽ§åˆ¶æµåˆ†æžï¼Œå¯¹ç±»çš„æ–¹æ³•ä½“è¿›è¡Œæ ¡éªŒåˆ†æžï¼Œä»¥ä¿è¯è¢«æ ¡éªŒçš„ç±»çš„æ–¹æ³•åœ¨è¿è¡Œæ—¶ä¸ä¼šåšå‡ºå±å®³è™šæ‹Ÿæœºå®‰å…¨çš„è¡Œä¸ºã€‚ ç¬¦å·å¼•ç”¨éªŒè¯ï¼šè¿™æ˜¯æœ€åŽä¸€ä¸ªé˜¶æ®µçš„éªŒè¯ï¼Œå®ƒå‘ç”Ÿåœ¨è™šæ‹Ÿæœºå°†ç¬¦å·å¼•ç”¨è½¬åŒ–ä¸ºç›´æŽ¥å¼•ç”¨çš„æ—¶å€™ï¼ˆè§£æžé˜¶æ®µä¸­å‘ç”Ÿè¯¥è½¬åŒ–ï¼ŒåŽé¢ä¼šæœ‰è®²è§£ï¼‰,ä¸»è¦æ˜¯å¯¹ç±»è‡ªèº«ä»¥å¤–çš„ä¿¡æ¯ï¼ˆå¸¸é‡æ± ä¸­çš„å„ç§ç¬¦å·å¼•ç”¨ï¼‰è¿›è¡ŒåŒ¹é…æ€§çš„æ ¡éªŒã€‚ å‡†å¤‡â€‹ å‡†å¤‡é˜¶æ®µæ˜¯æ­£å¼ä¸ºç±»å˜é‡åˆ†é…å†…å­˜å¹¶è®¾ç½®ç±»å˜é‡åˆå§‹å€¼çš„é˜¶æ®µï¼Œè¿™äº›å†…å­˜éƒ½å°†åœ¨æ–¹æ³•åŒºä¸­åˆ†é…ã€‚å¯¹äºŽè¯¥é˜¶æ®µæœ‰ä»¥ä¸‹å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š â€‹ 1ã€è¿™æ—¶å€™è¿›è¡Œå†…å­˜åˆ†é…çš„ä»…åŒ…æ‹¬ç±»å˜é‡ï¼ˆstaticï¼‰,è€Œä¸åŒ…æ‹¬å®žä¾‹å˜é‡ï¼Œå®žä¾‹å˜é‡ä¼šåœ¨å¯¹è±¡å®žä¾‹åŒ–æ—¶éšç€å¯¹è±¡ä¸€å—åˆ†é…åœ¨Javaå †ä¸­ã€‚ â€‹ 2ã€è¿™é‡Œæ‰€è®¾ç½®çš„åˆå§‹å€¼é€šå¸¸æƒ…å†µä¸‹æ˜¯æ•°æ®ç±»åž‹é»˜è®¤çš„é›¶å€¼ï¼ˆå¦‚0ã€0Lã€nullã€falseç­‰ï¼‰,è€Œä¸æ˜¯è¢«åœ¨Javaä»£ç ä¸­è¢«æ˜¾å¼åœ°èµ‹äºˆçš„å€¼ã€‚ å‡è®¾ä¸€ä¸ªç±»å˜é‡çš„å®šä¹‰ä¸ºï¼š public static int value = 3ï¼› â€‹ é‚£ä¹ˆå˜é‡valueåœ¨å‡†å¤‡é˜¶æ®µè¿‡åŽçš„åˆå§‹å€¼ä¸º0ï¼Œè€Œä¸æ˜¯3ï¼Œå› ä¸ºè¿™æ—¶å€™å°šæœªå¼€å§‹æ‰§è¡Œä»»ä½•Javaæ–¹æ³•ï¼Œè€ŒæŠŠvalueèµ‹å€¼ä¸º3çš„putstaticæŒ‡ä»¤æ˜¯åœ¨ç¨‹åºç¼–è¯‘åŽï¼Œå­˜æ”¾äºŽç±»æž„é€ å™¨()æ–¹æ³•ä¹‹ä¸­çš„ï¼Œæ‰€ä»¥æŠŠvalueèµ‹å€¼ä¸º3çš„åŠ¨ä½œå°†åœ¨åˆå§‹åŒ–é˜¶æ®µæ‰ä¼šæ‰§è¡Œã€‚ â€‹ ä¸‹è¡¨åˆ—å‡ºäº†Javaä¸­æ‰€æœ‰åŸºæœ¬æ•°æ®ç±»åž‹ä»¥åŠreferenceç±»åž‹çš„é»˜è®¤é›¶å€¼ï¼š è¿™é‡Œè¿˜éœ€è¦æ³¨æ„å¦‚ä¸‹å‡ ç‚¹ï¼š å¯¹åŸºæœ¬æ•°æ®ç±»åž‹æ¥è¯´ï¼Œå¯¹äºŽç±»å˜é‡ï¼ˆstaticï¼‰å’Œå…¨å±€å˜é‡ï¼Œå¦‚æžœä¸æ˜¾å¼åœ°å¯¹å…¶èµ‹å€¼è€Œç›´æŽ¥ä½¿ç”¨ï¼Œåˆ™ç³»ç»Ÿä¼šä¸ºå…¶èµ‹äºˆé»˜è®¤çš„é›¶å€¼ï¼Œè€Œå¯¹äºŽå±€éƒ¨å˜é‡æ¥è¯´ï¼Œåœ¨ä½¿ç”¨å‰å¿…é¡»æ˜¾å¼åœ°ä¸ºå…¶èµ‹å€¼ï¼Œå¦åˆ™ç¼–è¯‘æ—¶ä¸é€šè¿‡ã€‚ å¯¹äºŽåŒæ—¶è¢«staticå’Œfinalä¿®é¥°çš„å¸¸é‡ï¼Œå¿…é¡»åœ¨å£°æ˜Žçš„æ—¶å€™å°±ä¸ºå…¶æ˜¾å¼åœ°èµ‹å€¼ï¼Œå¦åˆ™ç¼–è¯‘æ—¶ä¸é€šè¿‡ï¼›è€Œåªè¢«finalä¿®é¥°çš„å¸¸é‡åˆ™æ—¢å¯ä»¥åœ¨å£°æ˜Žæ—¶æ˜¾å¼åœ°ä¸ºå…¶èµ‹å€¼ï¼Œä¹Ÿå¯ä»¥åœ¨ç±»åˆå§‹åŒ–æ—¶æ˜¾å¼åœ°ä¸ºå…¶èµ‹å€¼ï¼Œæ€»ä¹‹ï¼Œåœ¨ä½¿ç”¨å‰å¿…é¡»ä¸ºå…¶æ˜¾å¼åœ°èµ‹å€¼ï¼Œç³»ç»Ÿä¸ä¼šä¸ºå…¶èµ‹äºˆé»˜è®¤é›¶å€¼ã€‚ å¯¹äºŽå¼•ç”¨æ•°æ®ç±»åž‹referenceæ¥è¯´ï¼Œå¦‚æ•°ç»„å¼•ç”¨ã€å¯¹è±¡å¼•ç”¨ç­‰ï¼Œå¦‚æžœæ²¡æœ‰å¯¹å…¶è¿›è¡Œæ˜¾å¼åœ°èµ‹å€¼è€Œç›´æŽ¥ä½¿ç”¨ï¼Œç³»ç»Ÿéƒ½ä¼šä¸ºå…¶èµ‹äºˆé»˜è®¤çš„é›¶å€¼ï¼Œå³nullã€‚ å¦‚æžœåœ¨æ•°ç»„åˆå§‹åŒ–æ—¶æ²¡æœ‰å¯¹æ•°ç»„ä¸­çš„å„å…ƒç´ èµ‹å€¼ï¼Œé‚£ä¹ˆå…¶ä¸­çš„å…ƒç´ å°†æ ¹æ®å¯¹åº”çš„æ•°æ®ç±»åž‹è€Œè¢«èµ‹äºˆé»˜è®¤çš„é›¶å€¼ã€‚ â€‹ 3ã€å¦‚æžœç±»å­—æ®µçš„å­—æ®µå±žæ€§è¡¨ä¸­å­˜åœ¨ConstantValueå±žæ€§ï¼Œå³åŒæ—¶è¢«finalå’Œstaticä¿®é¥°ï¼Œé‚£ä¹ˆåœ¨å‡†å¤‡é˜¶æ®µå˜é‡valueå°±ä¼šè¢«åˆå§‹åŒ–ä¸ºConstValueå±žæ€§æ‰€æŒ‡å®šçš„å€¼ã€‚ å‡è®¾ä¸Šé¢çš„ç±»å˜é‡valueè¢«å®šä¹‰ä¸ºï¼š public static final int value = 3ï¼› â€‹ ç¼–è¯‘æ—¶Javacå°†ä¼šä¸ºvalueç”ŸæˆConstantValueå±žæ€§ï¼Œåœ¨å‡†å¤‡é˜¶æ®µè™šæ‹Ÿæœºå°±ä¼šæ ¹æ®ConstantValueçš„è®¾ç½®å°†valueèµ‹å€¼ä¸º3ã€‚å›žå¿†ä¸Šä¸€ç¯‡åšæ–‡ä¸­å¯¹è±¡è¢«åŠ¨å¼•ç”¨çš„ç¬¬2ä¸ªä¾‹å­ï¼Œä¾¿æ˜¯è¿™ç§æƒ…å†µã€‚æˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºstatic finalå¸¸é‡åœ¨ç¼–è¯‘æœŸå°±å°†å…¶ç»“æžœæ”¾å…¥äº†è°ƒç”¨å®ƒçš„ç±»çš„å¸¸é‡æ± ä¸­ã€‚ è§£æž è§£æžé˜¶æ®µæ˜¯è™šæ‹Ÿæœºå°†å¸¸é‡æ± ä¸­çš„ç¬¦å·å¼•ç”¨è½¬åŒ–ä¸ºç›´æŽ¥å¼•ç”¨çš„è¿‡ç¨‹ã€‚å‰é¢è¯´è§£æžé˜¶æ®µå¯èƒ½å¼€å§‹äºŽåˆå§‹åŒ–ä¹‹å‰ï¼Œä¹Ÿå¯èƒ½åœ¨åˆå§‹åŒ–ä¹‹åŽå¼€å§‹ï¼Œè™šæ‹Ÿæœºä¼šæ ¹æ®éœ€è¦æ¥åˆ¤æ–­ï¼Œåˆ°åº•æ˜¯åœ¨ç±»è¢«åŠ è½½å™¨åŠ è½½æ—¶å°±å¯¹å¸¸é‡æ± ä¸­çš„ç¬¦å·å¼•ç”¨è¿›è¡Œè§£æžï¼ˆåˆå§‹åŒ–ä¹‹å‰ï¼‰,è¿˜æ˜¯ç­‰åˆ°ä¸€ä¸ªç¬¦å·å¼•ç”¨å°†è¦è¢«ä½¿ç”¨å‰æ‰åŽ»è§£æžå®ƒï¼ˆåˆå§‹åŒ–ä¹‹åŽï¼‰ã€‚ â€‹ å¯¹åŒä¸€ä¸ªç¬¦å·å¼•ç”¨è¿›è¡Œå¤šæ¬¡è§£æžè¯·æ±‚æ—¶å¾ˆå¸¸è§çš„äº‹æƒ…ï¼Œè™šæ‹Ÿæœºå®žçŽ°å¯èƒ½ä¼šå¯¹ç¬¬ä¸€æ¬¡è§£æžçš„ç»“æžœè¿›è¡Œç¼“å­˜ï¼ˆåœ¨è¿è¡Œæ—¶å¸¸é‡æ± ä¸­è®°å½•ç›´æŽ¥å¼•ç”¨ï¼Œå¹¶æŠŠå¸¸é‡æ ‡ç¤ºä¸ºå·²è§£æžçŠ¶æ€ï¼‰,ä»Žè€Œé¿å…è§£æžåŠ¨ä½œé‡å¤è¿›è¡Œã€‚ â€‹ è§£æžåŠ¨ä½œä¸»è¦é’ˆå¯¹ç±»æˆ–æŽ¥å£ã€å­—æ®µã€ç±»æ–¹æ³•ã€æŽ¥å£æ–¹æ³•å››ç±»ç¬¦å·å¼•ç”¨è¿›è¡Œï¼Œåˆ†åˆ«å¯¹åº”äºŽå¸¸é‡æ± ä¸­çš„CONSTANT_Class_infoã€CONSTANT_Fieldref_infoã€CONSTANT_Methodref_infoã€CONSTANT_InterfaceMethodref_infoå››ç§å¸¸é‡ç±»åž‹ã€‚ â€‹ 1ã€ç±»æˆ–æŽ¥å£çš„è§£æžï¼šåˆ¤æ–­æ‰€è¦è½¬åŒ–æˆçš„ç›´æŽ¥å¼•ç”¨æ˜¯å¯¹æ•°ç»„ç±»åž‹ï¼Œè¿˜æ˜¯æ™®é€šçš„å¯¹è±¡ç±»åž‹çš„å¼•ç”¨ï¼Œä»Žè€Œè¿›è¡Œä¸åŒçš„è§£æžã€‚ â€‹ 2ã€å­—æ®µè§£æžï¼šå¯¹å­—æ®µè¿›è¡Œè§£æžæ—¶ï¼Œä¼šå…ˆåœ¨æœ¬ç±»ä¸­æŸ¥æ‰¾æ˜¯å¦åŒ…å«æœ‰ç®€å•åç§°å’Œå­—æ®µæè¿°ç¬¦éƒ½ä¸Žç›®æ ‡ç›¸åŒ¹é…çš„å­—æ®µï¼Œå¦‚æžœæœ‰ï¼Œåˆ™æŸ¥æ‰¾ç»“æŸï¼›å¦‚æžœæ²¡æœ‰ï¼Œåˆ™ä¼šæŒ‰ç…§ç»§æ‰¿å…³ç³»ä»Žä¸Šå¾€ä¸‹é€’å½’æœç´¢è¯¥ç±»æ‰€å®žçŽ°çš„å„ä¸ªæŽ¥å£å’Œå®ƒä»¬çš„çˆ¶æŽ¥å£ï¼Œè¿˜æ²¡æœ‰ï¼Œåˆ™æŒ‰ç…§ç»§æ‰¿å…³ç³»ä»Žä¸Šå¾€ä¸‹é€’å½’æœç´¢å…¶çˆ¶ç±»ï¼Œç›´è‡³æŸ¥æ‰¾ç»“æŸï¼ŒæŸ¥æ‰¾æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä»Žä¸‹é¢ä¸€æ®µä»£ç çš„æ‰§è¡Œç»“æžœä¸­å¾ˆå®¹æ˜“çœ‹å‡ºæ¥å­—æ®µè§£æžçš„æœç´¢é¡ºåºï¼š 1234567891011121314151617181920212223242526class Super&#123; public static int m = 11; static&#123; System.out.println("æ‰§è¡Œäº†superç±»é™æ€è¯­å¥å—"); &#125;&#125;class Father extends Super&#123; public static int m = 33; static&#123; System.out.println("æ‰§è¡Œäº†çˆ¶ç±»é™æ€è¯­å¥å—"); &#125;&#125;class Child extends Father&#123; static&#123; System.out.println("æ‰§è¡Œäº†å­ç±»é™æ€è¯­å¥å—"); &#125;&#125;public class StaticTest&#123; public static void main(String[] args)&#123; System.out.println(Child.m); &#125;&#125; â€‹ æ‰§è¡Œäº†superç±»é™æ€è¯­å¥å—â€‹ æ‰§è¡Œäº†çˆ¶ç±»é™æ€è¯­å¥å—â€‹ 33â€‹ å¦‚æžœæ³¨é‡ŠæŽ‰Fatherç±»ä¸­å¯¹må®šä¹‰çš„é‚£ä¸€è¡Œï¼Œåˆ™è¾“å‡ºç»“æžœå¦‚ä¸‹ï¼š â€‹ æ‰§è¡Œäº†superç±»é™æ€è¯­å¥å—â€‹ 11 åˆ†æžå¦‚ä¸‹ï¼šstaticå˜é‡å‘ç”Ÿåœ¨é™æ€è§£æžé˜¶æ®µï¼Œä¹Ÿå³æ˜¯åˆå§‹åŒ–ä¹‹å‰ï¼Œæ­¤æ—¶å·²ç»å°†å­—æ®µçš„ç¬¦å·å¼•ç”¨è½¬åŒ–ä¸ºäº†å†…å­˜å¼•ç”¨ï¼Œä¹Ÿä¾¿å°†å®ƒä¸Žå¯¹åº”çš„ç±»å…³è”åœ¨äº†ä¸€èµ·ï¼Œç”±äºŽåœ¨å­ç±»ä¸­æ²¡æœ‰æŸ¥æ‰¾åˆ°ä¸Žmç›¸åŒ¹é…çš„å­—æ®µï¼Œé‚£ä¹ˆmä¾¿ä¸ä¼šä¸Žå­ç±»å…³è”åœ¨ä¸€èµ·ï¼Œå› æ­¤å¹¶ä¸ä¼šè§¦å‘å­ç±»çš„åˆå§‹åŒ–ã€‚ â€‹ æœ€åŽéœ€è¦æ³¨æ„ï¼šç†è®ºä¸Šæ˜¯æŒ‰ç…§ä¸Šè¿°é¡ºåºè¿›è¡Œæœç´¢è§£æžï¼Œä½†åœ¨å®žé™…åº”ç”¨ä¸­ï¼Œè™šæ‹Ÿæœºçš„ç¼–è¯‘å™¨å®žçŽ°å¯èƒ½è¦æ¯”ä¸Šè¿°è§„èŒƒè¦æ±‚çš„æ›´ä¸¥æ ¼ä¸€äº›ã€‚å¦‚æžœæœ‰ä¸€ä¸ªåŒåå­—æ®µåŒæ—¶å‡ºçŽ°åœ¨è¯¥ç±»çš„æŽ¥å£å’Œçˆ¶ç±»ä¸­ï¼Œæˆ–åŒæ—¶åœ¨è‡ªå·±æˆ–çˆ¶ç±»çš„æŽ¥å£ä¸­å‡ºçŽ°ï¼Œç¼–è¯‘å™¨å¯èƒ½ä¼šæ‹’ç»ç¼–è¯‘ã€‚å¦‚æžœå¯¹ä¸Šé¢çš„ä»£ç åšäº›ä¿®æ”¹ï¼Œå°†Superæ”¹ä¸ºæŽ¥å£ï¼Œå¹¶å°†Childç±»ç»§æ‰¿Fatherç±»ä¸”å®žçŽ°SuperæŽ¥å£ï¼Œé‚£ä¹ˆåœ¨ç¼–è¯‘æ—¶ä¼šæŠ¥å‡ºå¦‚ä¸‹é”™è¯¯ï¼š StaticTest.java:24: å¯¹ m çš„å¼•ç”¨ä¸æ˜Žç¡®ï¼ŒFather ä¸­çš„ å˜é‡ m å’Œ Super ä¸­çš„ å˜é‡ méƒ½åŒ¹é…â€‹ System.out.println(Child.m);â€‹ ^1 é”™è¯¯ â€‹ 3ã€ç±»æ–¹æ³•è§£æžï¼šå¯¹ç±»æ–¹æ³•çš„è§£æžä¸Žå¯¹å­—æ®µè§£æžçš„æœç´¢æ­¥éª¤å·®ä¸å¤šï¼Œåªæ˜¯å¤šäº†åˆ¤æ–­è¯¥æ–¹æ³•æ‰€å¤„çš„æ˜¯ç±»è¿˜æ˜¯æŽ¥å£çš„æ­¥éª¤ï¼Œè€Œä¸”å¯¹ç±»æ–¹æ³•çš„åŒ¹é…æœç´¢ï¼Œæ˜¯å…ˆæœç´¢çˆ¶ç±»ï¼Œå†æœç´¢æŽ¥å£ã€‚ 4ã€æŽ¥å£æ–¹æ³•è§£æžï¼šä¸Žç±»æ–¹æ³•è§£æžæ­¥éª¤ç±»ä¼¼ï¼ŒçŸ¥è¯†æŽ¥å£ä¸ä¼šæœ‰çˆ¶ç±»ï¼Œå› æ­¤ï¼Œåªé€’å½’å‘ä¸Šæœç´¢çˆ¶æŽ¥å£å°±è¡Œäº†ã€‚ åˆå§‹åŒ–â€‹ åˆå§‹åŒ–æ˜¯ç±»åŠ è½½è¿‡ç¨‹çš„æœ€åŽä¸€æ­¥ï¼Œåˆ°äº†æ­¤é˜¶æ®µï¼Œæ‰çœŸæ­£å¼€å§‹æ‰§è¡Œç±»ä¸­å®šä¹‰çš„Javaç¨‹åºä»£ç ã€‚åœ¨å‡†å¤‡é˜¶æ®µï¼Œç±»å˜é‡å·²ç»è¢«èµ‹è¿‡ä¸€æ¬¡ç³»ç»Ÿè¦æ±‚çš„åˆå§‹å€¼ï¼Œè€Œåœ¨åˆå§‹åŒ–é˜¶æ®µï¼Œåˆ™æ˜¯æ ¹æ®ç¨‹åºå‘˜é€šè¿‡ç¨‹åºæŒ‡å®šçš„ä¸»è§‚è®¡åˆ’åŽ»åˆå§‹åŒ–ç±»å˜é‡å’Œå…¶ä»–èµ„æºï¼Œæˆ–è€…å¯ä»¥ä»Žå¦ä¸€ä¸ªè§’åº¦æ¥è¡¨è¾¾ï¼šåˆå§‹åŒ–é˜¶æ®µæ˜¯æ‰§è¡Œç±»æž„é€ å™¨()æ–¹æ³•çš„è¿‡ç¨‹ã€‚ è¿™é‡Œç®€å•è¯´æ˜Žä¸‹()æ–¹æ³•çš„æ‰§è¡Œè§„åˆ™: ()æ–¹æ³•æ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨æ”¶é›†ç±»ä¸­çš„æ‰€æœ‰ç±»å˜é‡çš„èµ‹å€¼åŠ¨ä½œå’Œé™æ€è¯­å¥å—ä¸­çš„è¯­å¥åˆå¹¶äº§ç”Ÿçš„ï¼Œç¼–è¯‘å™¨æ”¶é›†çš„é¡ºåºæ˜¯ç”±è¯­å¥åœ¨æºæ–‡ä»¶ä¸­å‡ºçŽ°çš„é¡ºåºæ‰€å†³å®šçš„ï¼Œé™æ€è¯­å¥å—ä¸­åªèƒ½è®¿é—®åˆ°å®šä¹‰åœ¨é™æ€è¯­å¥å—ä¹‹å‰çš„å˜é‡ï¼Œå®šä¹‰åœ¨å®ƒä¹‹åŽçš„å˜é‡ï¼Œåœ¨å‰é¢çš„é™æ€è¯­å¥ä¸­å¯ä»¥èµ‹å€¼ï¼Œä½†æ˜¯ä¸èƒ½è®¿é—®ã€‚ ()æ–¹æ³•ä¸Žå®žä¾‹æž„é€ å™¨()æ–¹æ³•ï¼ˆç±»çš„æž„é€ å‡½æ•°ï¼‰ä¸åŒï¼Œå®ƒä¸éœ€è¦æ˜¾å¼åœ°è°ƒç”¨çˆ¶ç±»æž„é€ å™¨ï¼Œè™šæ‹Ÿæœºä¼šä¿è¯åœ¨å­ç±»çš„()æ–¹æ³•æ‰§è¡Œä¹‹å‰ï¼Œçˆ¶ç±»çš„()æ–¹æ³•å·²ç»æ‰§è¡Œå®Œæ¯•ã€‚å› æ­¤ï¼Œåœ¨è™šæ‹Ÿæœºä¸­ç¬¬ä¸€ä¸ªè¢«æ‰§è¡Œçš„()æ–¹æ³•çš„ç±»è‚¯å®šæ˜¯java.lang.Objectã€‚ ()æ–¹æ³•å¯¹äºŽç±»æˆ–æŽ¥å£æ¥è¯´å¹¶ä¸æ˜¯å¿…é¡»çš„ï¼Œå¦‚æžœä¸€ä¸ªç±»ä¸­æ²¡æœ‰é™æ€è¯­å¥å—ï¼Œä¹Ÿæ²¡æœ‰å¯¹ç±»å˜é‡çš„èµ‹å€¼æ“ä½œï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å¯ä»¥ä¸ä¸ºè¿™ä¸ªç±»ç”Ÿæˆ()æ–¹æ³•ã€‚ æŽ¥å£ä¸­ä¸èƒ½ä½¿ç”¨é™æ€è¯­å¥å—ï¼Œä½†ä»ç„¶æœ‰ç±»å˜é‡ï¼ˆfinal staticï¼‰åˆå§‹åŒ–çš„èµ‹å€¼æ“ä½œï¼Œå› æ­¤æŽ¥å£ä¸Žç±»ä¸€æ ·ä¼šç”Ÿæˆ()æ–¹æ³•ã€‚ä½†æ˜¯æŽ¥å£é±¼ç±»ä¸åŒçš„æ˜¯ï¼šæ‰§è¡ŒæŽ¥å£çš„()æ–¹æ³•ä¸éœ€è¦å…ˆæ‰§è¡Œçˆ¶æŽ¥å£çš„()æ–¹æ³•ï¼Œåªæœ‰å½“çˆ¶æŽ¥å£ä¸­å®šä¹‰çš„å˜é‡è¢«ä½¿ç”¨æ—¶ï¼Œçˆ¶æŽ¥å£æ‰ä¼šè¢«åˆå§‹åŒ–ã€‚å¦å¤–ï¼ŒæŽ¥å£çš„å®žçŽ°ç±»åœ¨åˆå§‹åŒ–æ—¶ä¹Ÿä¸€æ ·ä¸ä¼šæ‰§è¡ŒæŽ¥å£çš„()æ–¹æ³•ã€‚ è™šæ‹Ÿæœºä¼šä¿è¯ä¸€ä¸ªç±»çš„()æ–¹æ³•åœ¨å¤šçº¿ç¨‹çŽ¯å¢ƒä¸­è¢«æ­£ç¡®åœ°åŠ é”å’ŒåŒæ­¥ï¼Œå¦‚æžœå¤šä¸ªçº¿ç¨‹åŒæ—¶åŽ»åˆå§‹åŒ–ä¸€ä¸ªç±»ï¼Œé‚£ä¹ˆåªä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹åŽ»æ‰§è¡Œè¿™ä¸ªç±»çš„()æ–¹æ³•ï¼Œå…¶ä»–çº¿ç¨‹éƒ½éœ€è¦é˜»å¡žç­‰å¾…ï¼Œç›´åˆ°æ´»åŠ¨çº¿ç¨‹æ‰§è¡Œ()æ–¹æ³•å®Œæ¯•ã€‚å¦‚æžœåœ¨ä¸€ä¸ªç±»çš„()æ–¹æ³•ä¸­æœ‰è€—æ—¶å¾ˆé•¿çš„æ“ä½œï¼Œé‚£å°±å¯èƒ½é€ æˆå¤šä¸ªçº¿ç¨‹é˜»å¡žï¼Œåœ¨å®žé™…åº”ç”¨ä¸­è¿™ç§é˜»å¡žå¾€å¾€æ˜¯å¾ˆéšè”½çš„ã€‚ â€‹ ä¸‹é¢ç»™å‡ºä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œä»¥ä¾¿æ›´æ¸…æ™°åœ°è¯´æ˜Žå¦‚ä¸Šè§„åˆ™ï¼š 12345678910111213141516class Father&#123; public static int a = 1; static&#123; a = 2; &#125;&#125;class Child extends Father&#123; public static int b = a;&#125;public class ClinitTest&#123; public static void main(String[] args)&#123; System.out.println(Child.b); &#125;&#125; æ‰§è¡Œä¸Šé¢çš„ä»£ç ï¼Œä¼šæ‰“å°å‡º2ï¼Œä¹Ÿå°±æ˜¯è¯´bçš„å€¼è¢«èµ‹ä¸ºäº†2ã€‚ â€‹ æˆ‘ä»¬æ¥çœ‹å¾—åˆ°è¯¥ç»“æžœçš„æ­¥éª¤ã€‚é¦–å…ˆåœ¨å‡†å¤‡é˜¶æ®µä¸ºç±»å˜é‡åˆ†é…å†…å­˜å¹¶è®¾ç½®ç±»å˜é‡åˆå§‹å€¼ï¼Œè¿™æ ·Aå’ŒBå‡è¢«èµ‹å€¼ä¸ºé»˜è®¤å€¼0ï¼Œè€ŒåŽå†åœ¨è°ƒç”¨()æ–¹æ³•æ—¶ç»™ä»–ä»¬èµ‹äºˆç¨‹åºä¸­æŒ‡å®šçš„å€¼ã€‚å½“æˆ‘ä»¬è°ƒç”¨Child.bæ—¶ï¼Œè§¦å‘Childçš„()æ–¹æ³•ï¼Œæ ¹æ®è§„åˆ™2ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œè¦å…ˆæ‰§è¡Œå®Œå…¶çˆ¶ç±»Fatherçš„()æ–¹æ³•ï¼Œåˆæ ¹æ®è§„åˆ™1ï¼Œåœ¨æ‰§è¡Œ()æ–¹æ³•æ—¶ï¼Œéœ€è¦æŒ‰staticè¯­å¥æˆ–staticå˜é‡èµ‹å€¼æ“ä½œç­‰åœ¨ä»£ç ä¸­å‡ºçŽ°çš„é¡ºåºæ¥æ‰§è¡Œç›¸å…³çš„staticè¯­å¥ï¼Œå› æ­¤å½“è§¦å‘æ‰§è¡ŒFatherçš„()æ–¹æ³•æ—¶ï¼Œä¼šå…ˆå°†aèµ‹å€¼ä¸º1ï¼Œå†æ‰§è¡Œstaticè¯­å¥å—ä¸­è¯­å¥ï¼Œå°†aèµ‹å€¼ä¸º2ï¼Œè€ŒåŽå†æ‰§è¡ŒChildç±»çš„()æ–¹æ³•ï¼Œè¿™æ ·ä¾¿ä¼šå°†bçš„èµ‹å€¼ä¸º2. â€‹ å¦‚æžœæˆ‘ä»¬é¢ å€’ä¸€ä¸‹Fatherç±»ä¸­â€œpublic static int a = 1;â€è¯­å¥å’Œâ€œstaticè¯­å¥å—â€çš„é¡ºåºï¼Œç¨‹åºæ‰§è¡ŒåŽï¼Œåˆ™ä¼šæ‰“å°å‡º1ã€‚å¾ˆæ˜Žæ˜¾æ˜¯æ ¹æ®è§„åˆ™1ï¼Œæ‰§è¡ŒFatherçš„()æ–¹æ³•æ—¶ï¼Œæ ¹æ®é¡ºåºå…ˆæ‰§è¡Œäº†staticè¯­å¥å—ä¸­çš„å†…å®¹ï¼ŒåŽæ‰§è¡Œäº†â€œpublic static int a = 1;â€è¯­å¥ã€‚ â€‹ å¦å¤–ï¼Œåœ¨é¢ å€’äºŒè€…çš„é¡ºåºä¹‹åŽï¼Œå¦‚æžœåœ¨staticè¯­å¥å—ä¸­å¯¹aè¿›è¡Œè®¿é—®ï¼ˆæ¯”å¦‚å°†aèµ‹ç»™æŸä¸ªå˜é‡ï¼‰,åœ¨ç¼–è¯‘æ—¶å°†ä¼šæŠ¥é”™ï¼Œå› ä¸ºæ ¹æ®è§„åˆ™1ï¼Œå®ƒåªèƒ½å¯¹aè¿›è¡Œèµ‹å€¼ï¼Œè€Œä¸èƒ½è®¿é—®ã€‚ æ€»ç»“â€‹ æ•´ä¸ªç±»åŠ è½½è¿‡ç¨‹ä¸­ï¼Œé™¤äº†åœ¨åŠ è½½é˜¶æ®µç”¨æˆ·åº”ç”¨ç¨‹åºå¯ä»¥è‡ªå®šä¹‰ç±»åŠ è½½å™¨å‚ä¸Žä¹‹å¤–ï¼Œå…¶ä½™æ‰€æœ‰çš„åŠ¨ä½œå®Œå…¨ç”±è™šæ‹Ÿæœºä¸»å¯¼å’ŒæŽ§åˆ¶ã€‚åˆ°äº†åˆå§‹åŒ–æ‰å¼€å§‹æ‰§è¡Œç±»ä¸­å®šä¹‰çš„Javaç¨‹åºä»£ç ï¼ˆäº¦åŠå­—èŠ‚ç ï¼‰,ä½†è¿™é‡Œçš„æ‰§è¡Œä»£ç åªæ˜¯ä¸ªå¼€ç«¯ï¼Œå®ƒä»…é™äºŽ()æ–¹æ³•ã€‚ç±»åŠ è½½è¿‡ç¨‹ä¸­ä¸»è¦æ˜¯å°†Classæ–‡ä»¶ï¼ˆå‡†ç¡®åœ°è®²ï¼Œåº”è¯¥æ˜¯ç±»çš„äºŒè¿›åˆ¶å­—èŠ‚æµï¼‰åŠ è½½åˆ°è™šæ‹Ÿæœºå†…å­˜ä¸­ï¼ŒçœŸæ­£æ‰§è¡Œå­—èŠ‚ç çš„æ“ä½œï¼Œåœ¨åŠ è½½å®ŒæˆåŽæ‰çœŸæ­£å¼€å§‹ã€‚]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Classç±»æ–‡ä»¶ç»“æž„]]></title>
    <url>%2Fjvm-classFileConstructor%2F</url>
    <content type="text"><![CDATA[Classç±»æ–‡ä»¶ç»“æž„æ— å…³çš„åŸºçŸ³Sun å…¬å¸å‘å¸ƒäº†å„ç§å¹³å°ä¸Šä¸åŒçš„è™šæ‹Ÿæœºç‰ˆæœ¬,è¿™äº›ä¸åŒå¹³å°ä¸Šçš„è™šæ‹Ÿæœºåªè¯†åˆ«å­—èŠ‚ç æ–‡ä»¶,è¿™ç§å­—èŠ‚ç æ–‡ä»¶å°±æ˜¯æž„æˆå¹³å°æ— å…³æ€§çš„åŸºçŸ³.é™¤äº†å¹³å°æ— å…³æ€§,è¯­è¨€æ— å…³æ€§ä¹Ÿæœ‰å¾ˆå¤§çš„ä¼˜åŠ¿, Java è™šæ‹Ÿæœºä¸å’ŒåŒ…æ‹¬ Java åœ¨å†…çš„æ‰€æœ‰è¯­è¨€ç»‘å®š,åªä¸Žâ€Class æ–‡ä»¶â€è¿™ç§ç‰¹å®šçš„äºŒè¿›åˆ¶æ–‡ä»¶æ ¼å¼æ‰€å…³è”, Class æ–‡ä»¶åŒ…å«äº† Java è™šæ‹ŸæœºæŒ‡ä»¤å’Œç¬¦å·è¡¨ä»¥åŠè‹¥å¹²å…¶ä»–è¾…åŠ©ä¿¡æ¯.è™šæ‹Ÿæœºä¸å…³å¿ƒ Class çš„æ¥æºæ˜¯ä½•ç§è¯­è¨€. Class æ–‡ä»¶ç»“æž„Class æ–‡ä»¶é‡‡ç”¨ç±»ä¼¼ C è¯­è¨€ç»“æž„ä½“çš„ä¼ªç»“æž„ä½“æ¥å­˜å‚¨æ•°æ®,è¿™ç§ä¼ªç»“æž„åªæœ‰ä¸¤ç§æ•°æ®ç±»åž‹,æ— ç¬¦å·æ•°å’Œè¡¨.æ— ç¬¦å·æ•°å¯ä»¥æè¿°æ•°å­—,ç´¢å¼•å¼•ç”¨,æ•°é‡å€¼æˆ–è€…æŒ‰ç…§ UTF-8ç¼–ç æž„æˆçš„å­—ç¬¦ä¸²å€¼.è¡¨æ˜¯ç”±æ— ç¬¦å·æ•°æˆ–è€…å…¶ä»–è¡¨ä½œä¸ºæ•°æ®é¡¹æž„æˆçš„å¤åˆæ•°æ®ç±»åž‹ é­”æ•°ä¸Ž Class æ–‡ä»¶ç‰ˆæœ¬æ¯ä¸ª Class æ–‡ä»¶çš„å¤´4ä¸ªå­—èŠ‚æ˜¯é­”æ•°,å®ƒçš„å”¯ä¸€ä½œç”¨æ˜¯ç¡®å®šå½“å‰æ–‡ä»¶èƒ½å¦è¢«è™šæ‹Ÿæœºè¿›è¡ŒåŠ è½½.å¾ˆå¤šæ–‡ä»¶å­˜å‚¨æ ¼å¼å¦ä½¿ç”¨é­”æ•°æ¥è¿›è¡Œèº«ä»½è¯†åˆ«,ä½¿ç”¨é­”æ•°è€Œä¸ä½¿ç”¨æ‰©å±•åæ˜¯å› ä¸ºæ‰©å±•åéšæ„æ›´æ”¹.ç´§æŽ¥ç€é­”æ•°åŽçš„4ä¸ªå­—èŠ‚æ˜¯ç‰ˆæœ¬å·,é«˜ç‰ˆæœ¬çš„è™šæ‹Ÿæœºèƒ½å¤Ÿå‘ä¸‹å…¼å®¹ä»¥å‰ç‰ˆæœ¬çš„ Class æ–‡ä»¶,ä½†ä¸èƒ½è¿è¡Œä»¥åŽç‰ˆæœ¬çš„ Class æ–‡ä»¶. å¸¸é‡æ± å¸¸é‡æ± ä¸­æœ‰14ç§å¸¸é‡ç±»åž‹,æ¯ç§ç±»åž‹éƒ½æœ‰è‡ªå·±çš„ç»“æž„.ç”±äºŽè¿™äº›å¸¸é‡çš„ä¸ªæ•°æ˜¯ä¸å›ºå®šçš„,æ‰€ä»¥åœ¨å¸¸é‡æ± çš„å…¥å£æ”¾ç½®ä¸€é¡¹ u2ç±»åž‹çš„æ•°æ®,ä»£è¡¨å¸¸é‡æ± å®¹é‡è®¡æ•°å€¼.è™šæ‹Ÿæœºçš„å¸¸é‡æ± ä¸»è¦å­˜æ”¾ä¸¤å¤§ç±»å¸¸é‡:å­—é¢é‡å’Œç¬¦å·å¼•ç”¨.å­—é¢é‡æŽ¥è¿‘äºŽ Java è¯­è¨€å±‚é¢çš„å¸¸é‡æ¦‚å¿µ,å¦‚å­—ç¬¦ä¸²,å£°æ˜Žä¸º final çš„å¸¸é‡å€¼ç­‰.ç¬¦å·å¼•ç”¨åˆ™æ•°æ®ç¼–è¯‘åŽŸç†æ–¹é¢çš„æ¦‚å¿µ,åŒ…æ‹¬:ç±»å’Œç»“æž„çš„å…¨é™å®šå,å­—æ®µå’Œåç§°çš„æè¿°ç¬¦,æ–¹æ³•çš„åç§°å’Œæè¿°ç¬¦. è®¿é—®æ ‡è¯†åœ¨å¸¸é‡æ± ç»“æŸåŽçš„ä¸¤ä¸ªå­—èŠ‚ä»£è¡¨è®¿é—®æ ‡è¯†,ç”¨äºŽè¯†åˆ«ç±»æˆ–è€…æŽ¥å£çš„è®¿é—®ä¿¡æ¯,åŒ…æ‹¬:è¿™ä¸ª Class æ˜¯ç±»è¿˜æ˜¯æŽ¥å£,æ˜¯å¦å®šä¹‰ä¸º public ç±»åž‹,æ˜¯å¦å®šä¹‰ä¸º abstract ç±»åž‹ç­‰. ç±»ç´¢å¼•,çˆ¶ç±»ç´¢å¼•ä¸ŽæŽ¥å£ç´¢å¼•é›†åˆClass æ–‡ä»¶ç”±è¿™ä¸‰é¡¹æ¥ç¡®å®šç±»çš„ç»§æ‰¿å…³ç³»,ç±»ç´¢å¼•ç¡®å®šè¿™ä¸ªç±»çš„å…¨é™å®šå,çˆ¶ç±»ç´¢å¼•ç¡®å®šè¿™ä¸ªç±»çˆ¶ç±»çš„å…¨é™å®šå,æŽ¥å£ç´¢å¼•é›†åˆç”¨æ¥æè¿°è¿™ä¸ªç±»å®žçŽ°äº†é‚£äº›æŽ¥å£. å­—æ®µè¡¨é›†åˆå­—æ®µè¡¨ç”¨æ¥æè¿°ç±»æˆ–æŽ¥å£ä¸­å£°æ˜Žçš„å˜é‡,åŒ…æ‹¬ç±»çº§å˜é‡ä»¥åŠå®žä¾‹çº§å˜é‡,ä½†ä¸åŒ…æ‹¬æ–¹æ³•å†…éƒ¨å£°æ˜Žçš„å±€éƒ¨å˜é‡. æ–¹æ³•è¡¨é›†åˆæ–¹æ³•è¡¨çš„ç»“æž„å¦‚å­—æ®µä¸€æ ·,åŒ…å«äº†è®¿é—®æ ‡è¯†,åç§°ç´¢å¼•,æè¿°ç¬¦ç´¢å¼•å‡ é¡¹. å±žæ€§è¡¨é›†åˆ Code å±žæ€§ å½“ä»£ç ç»è¿‡ç¼–è¯‘ä¹‹åŽ,æœ€ç»ˆå­—èŠ‚ç æŒ‡ä»¤å­˜å‚¨åœ¨ Code å±žæ€§å†…. Exceptions å±žæ€§ åˆ—ä¸¾å‡ºæ–¹æ³•å¯èƒ½æŠ›å‡ºçš„å—æŸ¥å¼‚å¸¸ LineNumberTable å±žæ€§ æè¿° Java æºä»£ç è¡Œå·ä¸Žå­—èŠ‚ç è¡Œå·ä¹‹é—´çš„å…³ç³». LocalVarableTable å±žæ€§ æè¿°æ ˆå¸§ä¸­å±€éƒ¨å˜é‡è¡¨ä¸­çš„å˜é‡ä¸Ž Java æºä»£ç ä¸­å®šä¹‰çš„å˜é‡ä¹‹é—´çš„å…³ç³». SourceFile å±žæ€§ è®°å½•ç”Ÿæˆè¿™ä¸ª Class æ–‡ä»¶çš„æºç æ–‡ä»¶åç§°. ConstantValue å±žæ€§ é€šçŸ¥è™šæ‹Ÿæœºè‡ªåŠ¨ä¸ºé™æ€å˜é‡èµ‹å€¼. InnerClasses å±žæ€§ è®°å½•å†…éƒ¨ç±»ä¸Žå®¿ä¸»ç±»ä¹‹é—´çš„å…³è”. Deprecated åŠ Synthetic å±žæ€§ è¿™ä¸¤ä¸ªå±žæ€§éƒ½æ•°æ®æ ‡å¿—ç±»åž‹çš„å¸ƒå°”å±žæ€§.Deprecated ç”¨äºŽè¡¨ç¤ºæŸä¸ªç±»,å­—æ®µæˆ–è€…æ–¹æ³•è¢«ç¨‹åºä½œè€…å®šä½ä¸å†æŽ¨èä½¿ç”¨.Synthetic ä»£è¡¨æ­¤å­—æ®µæˆ–è€…æ–¹æ³•å¹¶ä¸æ˜¯ç”± Java æºç äº§ç”Ÿçš„,è€Œæ˜¯ç”±ç¼–è¾‘å™¨è‡ªè¡Œæ·»åŠ . StackMapTable å±žæ€§ ä¸€ä¸ªå¤æ‚çš„å˜é•¿å±žæ€§,ä½äºŽ Code å±žæ€§çš„å±žæ€§è¡¨ä¸­.è¿™ä¸ªå±žæ€§ä¼šåœ¨è™šæ‹Ÿæœºç±»åŠ è½½çš„å­—èŠ‚ç éªŒè¯é˜¶æ®µè¢«æ–°ç±»åž‹æ£€æŸ¥éªŒè¯å™¨ä½¿ç”¨,ç›®çš„æ˜¯ä»£æ›¿ä»¥å‰æ¯”è¾ƒæ¶ˆè€—æ–°èƒ½çš„åŸºäºŽæ•°æ®æµåˆ†æžçš„ç±»åž‹æŽ¨å¯¼éªŒè¯å™¨. Signature å±žæ€§ å¯ä»¥å‡ºçŽ°äºŽç±»,å±žæ€§è¡¨å’Œæ–¹æ³•è¡¨ç»“æž„çš„å±žæ€§è¡¨ä¸­,åœ¨ JDK1.5ä¹‹åŽ,ä»»ä½•ç±»,æŽ¥å£,æ–¹æ³•çš„æ³›åž‹ç­¾åå¦‚æžœåŒ…å«äº†ç±»åž‹å˜é‡æˆ–å‚æ•°åŒ–ç±»åž‹,åˆ™ Signature å±žæ€§ä¼šè®°å½•æ³›åž‹ç­¾åä¿¡æ¯.å› ä¸º Java è¯­è¨€çš„æ³›åž‹é‡‡ç”¨æ“¦é™¤æ–¹æ³•å®žçŽ°,åœ¨å­—èŠ‚ç ä¸­,æ³›åž‹ä¿¡æ¯ç¼–è¯‘ä¹‹åŽç»Ÿç»Ÿè¢«æ“¦é™¤æŽ‰.ä½¿ç”¨æ“¦é™¤çš„åŽŸå› æ˜¯å®žçŽ°ç®€å•,è¿è¡ŒæœŸä¹Ÿèƒ½èŠ‚çœä¸€äº›ç±»åž‹æ‰€å çš„å†…å­˜ç©ºé—´,åå¤„æ˜¯è¿è¡ŒæœŸæ— æ³•åƒ C# ç­‰æœ‰çœŸæ³›åž‹æ”¯æŒçš„è¯­è¨€é‚£æ ·,å°†æ³›åž‹ç±»åž‹ä¸Žç”¨æˆ·å®šä¹‰çš„ç±»åž‹ä¿¡æ¯åŒç­‰å¯¹å¾…, Signature å°±æ˜¯ä¸ºäº†å¼¥è¡¥è¿™ä¸ªç¼ºé™·,å¦‚ Java çš„åå°„ API èƒ½å¤ŸèŽ·å–æ³›åž‹ç±»åž‹,å°±æ˜¯æ¥æºè¿™ä¸ªå±žæ€§. å­—èŠ‚ç æŒ‡ä»¤ç®€ä»‹ç”±ä¸€ä¸ªå­—èŠ‚é•¿åº¦çš„,ä»£è¡¨æŸç§ç‰¹å®šæ“ä½œå«ä¹‰çš„æ•°æ®ä»¥åŠåŽé¢çš„é›¶åˆ°å¤šä¸ªä»£è¡¨æ­¤æ“ä½œæ‰€æ‰€éœ€å‚æ•°æž„æˆ.ç”±äºŽJava è™šæ‹Ÿæœºé¢å‘æ“ä½œæ•°æ ˆè€Œä¸æ˜¯å¯„å­˜å™¨åŠæž¶æž„,æ‰€ä»¥å¤§å¤šæ•°çš„æŒ‡ä»¤éƒ½ä¸åŒ…å«æ“ä½œæ•°. å­—èŠ‚ç ä¸Žæ•°æ®ç±»åž‹åœ¨ Java è™šæ‹Ÿæœºçš„æŒ‡ä»¤é›†ä¸­,å¤§å¤šæ•°çš„æŒ‡ä»¤éƒ½åŒ…å«äº†å…¶æ“ä½œæ‰€å¯¹åº”çš„æ•°æ®ç±»åž‹ä¿¡æ¯.å¦‚: iload æŒ‡ä»¤ç”¨äºŽä»Žå±€éƒ¨å˜é‡è¡¨ä¸­åŠ è½½ int ç±»åž‹çš„æ•°æ®åˆ°æ“ä½œæ•°æ ˆä¸­. åŠ è½½ä¸Žå­˜å‚¨æŒ‡ä»¤åŠ è½½å’Œå­˜å‚¨æŒ‡ä»¤ç”¨äºŽå°†æ•°æ®åœ¨æ ˆå¸§ä¸­çš„å±€éƒ¨å˜é‡è¡¨å’Œæ“ä½œæ•°æ ˆä¹‹é—´æ¥å›žä¼ è¾“.å¦‚:å°†ä¸€ä¸ªå±€éƒ¨å˜é‡åŠ è½½åˆ°æ“ä½œæ ˆ: iloadå°†ä¸€ä¸ªæ•°å€¼ä»Žæ“ä½œæ•°æ ˆå­˜å‚¨åˆ°å±€éƒ¨å˜é‡è¡¨: istore è¿ç®—æŒ‡ä»¤å°†ä¸¤ä¸ªæ“ä½œæ•°æ ˆä¸Šçš„æ•°æ®è¿›è¡ŒæŸç§ç‰¹å®šæ“ä½œ,å¹¶å°†ç»“æž„é‡æ–°å­˜å…¥æ“ä½œæ ˆé¡¶. ç±»åž‹è½¬åŒ–æŒ‡ä»¤å¯¹ä¸¤ä¸ªæ•°å€¼ç±»åž‹è¿›è¡Œç›¸äº’è½¬æ¢,ä¸€èˆ¬ç”¨äºŽå®žçŽ°ç”¨æˆ·ä»£ç ä¸­çš„æ˜¾å¼ç±»åž‹è½¬æ¢æ“ä½œ. æ“ä½œæ•°æ ˆç®¡ç†æŒ‡ä»¤æ“ä½œä¸€ä¸ªæ™®é€šæ“ä½œæ•°æ®ç»“æž„ä¸­çš„å †æ ˆä¸€æ ·, Java è™šæ‹Ÿæœºæä¾›äº†ä¸€äº›ç”¨äºŽç›´æŽ¥æ“ä½œæ“ä½œæ•°æ ˆçš„æŒ‡ä»¤,åŒ…æ‹¬: å°†æ“ä½œæ•°æ ˆçš„æ ˆé¡¶ä¸€ä¸ªæˆ–è€…ä¸¤ä¸ªå…ƒç´ å‡ºæ ˆ: pop,pop2 å°†æ ˆæœ€é¡¶ç«¯çš„ä¸¤ä¸ªæ•°å€¼äº’æ¢: swap. æŽ§åˆ¶è½¬ç§»æŒ‡ä»¤å¯ä»¥è®© Java è™šæ‹Ÿæœºæœ‰æ¡ä»¶æˆ–æ— æ¡ä»¶åœ°ä»ŽæŒ‡å®šä½ç½®æŒ‡ä»¤è€Œä¸æ˜¯æŽ§åˆ¶è½¬ç§»æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ç»§ç»­æ‰§è¡Œç¨‹åº. å…¬æœ‰è®¾è®¡å’Œç§æœ‰è®¾è®¡Java è™šæ‹Ÿæœºçš„å®žçŽ°è¿è¡Œåœ¨æ»¡è¶³è™šæ‹Ÿæœºè§„èŒƒçš„çº¦æŸä¸‹å¯¹å…·ä½“å®žçŽ°åšå‡ºä¿®æ”¹å’Œä¼˜åŒ–.åªè¦ä¼˜åŒ–åŽçš„ Class æ–‡ä»¶ä¾ç„¶å¯ä»¥è¢«æ­£ç¡®è¯»å–,å®žçŽ°è€…å¯ä»¥é€‰æ‹©ä»»ä½•æ–¹å¼åŽ»å®žçŽ°è¿™äº›è¯­ä¹‰. Class æ–‡ä»¶ç»“æž„çš„å‘å±•è‡ª Class æ–‡ä»¶å‘å¸ƒåå¤šå¹´ä»¥æ¥, Class æ–‡ä»¶çš„ä¸»ä½“ç»“æž„,å­—èŠ‚ç æŒ‡ä»¤çš„è¯­ä¹‰å’Œæ•°é‡å‡ ä¹Žæ²¡æœ‰æ”¹åŠ¨,æ‰€æœ‰çš„æ”¹åŠ¨éƒ½é›†ä¸­åœ¨ è®¿é—®æ ‡è¯†,å±žæ€§è¡¨è¿™äº›åœ¨è®¾è®¡ä¸Šå¯æ‰©å±•çš„æ•°æ®ç»“æž„ä¸­æ·»åŠ å†…å®¹.Class æ–‡ä»¶æ ¼å¼é”å…·å¤‡çš„å¹³å°ä¸­ç«‹,ç´§å‡‘,ç¨³å®šå’Œå¯æ‰©å±•çš„ç‰¹ç‚¹,æ˜¯ Java æŠ€æœ¯ä½“ç³»å®žçŽ°å¹³å°æ— å…³,è¯­è¨€æ— å…³ä¸¤é¡¹ç‰¹æ€§çš„é‡è¦æ”¯æŸ±.]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ·±å…¥ç†è§£Javaä¸­çš„ç»„åˆå’Œç»§æ‰¿]]></title>
    <url>%2Fjicheng-and-zuhe%2F</url>
    <content type="text"><![CDATA[æ·±å…¥ç†è§£Javaä¸­çš„ç»„åˆå’Œç»§æ‰¿å‰è¨€ç”±äºŽæ„Ÿè§‰è‡ªå·±å¯¹JavaåŸºç¡€çŸ¥è¯†æœ‰ç‚¹é—å¿˜ï¼Œå°±æ‰¾äº†ä¸€ç¯‡æ–‡ç« æ¥å·©å›ºä¸€ä¸‹ã€‚ é¢å‘å¯¹è±¡çš„å¤ç”¨æŠ€æœ¯å¤ç”¨æ€§æ˜¯é¢å‘å¯¹è±¡æŠ€æœ¯å¸¦æ¥çš„å¾ˆæ£’çš„æ½œåœ¨å¥½å¤„ä¹‹ä¸€ã€‚å¦‚æžœè¿ç”¨çš„å¥½çš„è¯å¯ä»¥å¸®åŠ©æˆ‘ä»¬èŠ‚çœå¾ˆå¤šå¼€å‘æ—¶é—´ï¼Œæå‡å¼€å‘æ•ˆçŽ‡ã€‚ä½†æ˜¯ï¼Œå¦‚æžœè¢«æ»¥ç”¨é‚£ä¹ˆå°±å¯èƒ½äº§ç”Ÿå¾ˆå¤šéš¾ä»¥ç»´æŠ¤çš„ä»£ç ã€‚ ä½œä¸ºä¸€é—¨é¢å‘å¯¹è±¡å¼€å‘çš„è¯­è¨€ï¼Œä»£ç å¤ç”¨æ˜¯Javaå¼•äººæ³¨æ„çš„åŠŸèƒ½ä¹‹ä¸€ã€‚Javaä»£ç çš„å¤ç”¨æœ‰ç»§æ‰¿ï¼Œç»„åˆä»¥åŠä»£ç†ä¸‰ç§å…·ä½“çš„è¡¨çŽ°å½¢å¼ã€‚æœ¬æ–‡å°†é‡ç‚¹ä»‹ç»ç»§æ‰¿å¤ç”¨å’Œç»„åˆå¤ç”¨ã€‚ ç»§æ‰¿ç»§æ‰¿ï¼ˆInheritanceï¼‰æ˜¯ä¸€ç§è”ç»“ç±»ä¸Žç±»çš„å±‚æ¬¡æ¨¡åž‹ã€‚æŒ‡çš„æ˜¯ä¸€ä¸ªç±»ï¼ˆç§°ä¸ºå­ç±»ã€å­æŽ¥å£ï¼‰ç»§æ‰¿å¦å¤–çš„ä¸€ä¸ªç±»ï¼ˆç§°ä¸ºçˆ¶ç±»ã€çˆ¶æŽ¥å£ï¼‰çš„åŠŸèƒ½ï¼Œå¹¶å¯ä»¥å¢žåŠ å®ƒè‡ªå·±çš„æ–°åŠŸèƒ½çš„èƒ½åŠ›ï¼Œç»§æ‰¿æ˜¯ç±»ä¸Žç±»æˆ–è€…æŽ¥å£ä¸ŽæŽ¥å£ä¹‹é—´æœ€å¸¸è§çš„å…³ç³»ï¼›ç»§æ‰¿æ˜¯ä¸€ç§is-aå…³ç³»ã€‚ï¼ˆå›¾ç‰‡æ¥è‡ªç½‘ç»œï¼Œä¾µåˆ ã€‚ï¼‰ ç»„åˆç»„åˆ(Composition)ä½“çŽ°çš„æ˜¯æ•´ä½“ä¸Žéƒ¨åˆ†ã€æ‹¥æœ‰çš„å…³ç³»ï¼Œå³has-açš„å…³ç³»ã€‚ ç»„åˆä¸Žç»§æ‰¿çš„åŒºåˆ«å’Œè”ç³» åœ¨ç»§æ‰¿ç»“æž„ä¸­ï¼Œçˆ¶ç±»çš„å†…éƒ¨ç»†èŠ‚å¯¹äºŽå­ç±»æ˜¯å¯è§çš„ã€‚æ‰€ä»¥æˆ‘ä»¬é€šå¸¸ä¹Ÿå¯ä»¥è¯´é€šè¿‡ç»§æ‰¿çš„ä»£ç å¤ç”¨æ˜¯ä¸€ç§ç™½ç›’å¼ä»£ç å¤ç”¨ã€‚ï¼ˆå¦‚æžœåŸºç±»çš„å®žçŽ°å‘ç”Ÿæ”¹å˜ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»çš„å®žçŽ°ä¹Ÿå°†éšä¹‹æ”¹å˜ã€‚è¿™æ ·å°±å¯¼è‡´äº†å­ç±»è¡Œä¸ºçš„ä¸å¯é¢„çŸ¥æ€§ï¼›ï¼‰ ç»„åˆæ˜¯é€šè¿‡å¯¹çŽ°æœ‰çš„å¯¹è±¡è¿›è¡Œæ‹¼è£…ï¼ˆç»„åˆï¼‰äº§ç”Ÿæ–°çš„ã€æ›´å¤æ‚çš„åŠŸèƒ½ã€‚å› ä¸ºåœ¨å¯¹è±¡ä¹‹é—´ï¼Œå„è‡ªçš„å†…éƒ¨ç»†èŠ‚æ˜¯ä¸å¯è§çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿè¯´è¿™ç§æ–¹å¼çš„ä»£ç å¤ç”¨æ˜¯é»‘ç›’å¼ä»£ç å¤ç”¨ã€‚ï¼ˆå› ä¸ºç»„åˆä¸­ä¸€èˆ¬éƒ½å®šä¹‰ä¸€ä¸ªç±»åž‹ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘æœŸæ ¹æœ¬ä¸çŸ¥é“å…·ä½“ä¼šè°ƒç”¨å“ªä¸ªå®žçŽ°ç±»çš„æ–¹æ³•ï¼‰ ç»§æ‰¿ï¼Œåœ¨å†™ä»£ç çš„æ—¶å€™å°±è¦æŒ‡åå…·ä½“ç»§æ‰¿å“ªä¸ªç±»ï¼Œæ‰€ä»¥ï¼Œåœ¨ç¼–è¯‘æœŸå°±ç¡®å®šäº†å…³ç³»ã€‚ï¼ˆä»ŽåŸºç±»ç»§æ‰¿æ¥çš„å®žçŽ°æ˜¯æ— æ³•åœ¨è¿è¡ŒæœŸåŠ¨æ€æ”¹å˜çš„ï¼Œå› æ­¤é™ä½Žäº†åº”ç”¨çš„çµæ´»æ€§ã€‚ï¼‰ ç»„åˆï¼Œåœ¨å†™ä»£ç çš„æ—¶å€™å¯ä»¥é‡‡ç”¨é¢å‘æŽ¥å£ç¼–ç¨‹ã€‚æ‰€ä»¥ï¼Œç±»çš„ç»„åˆå…³ç³»ä¸€èˆ¬åœ¨è¿è¡ŒæœŸç¡®å®šã€‚ ä¼˜ç¼ºç‚¹å¯¹æ¯” ç»„ åˆ å…³ ç³» ç»§ æ‰¿ å…³ ç³» ä¼˜ç‚¹ï¼šä¸ç ´åå°è£…ï¼Œæ•´ä½“ç±»ä¸Žå±€éƒ¨ç±»ä¹‹é—´æ¾è€¦åˆï¼Œå½¼æ­¤ç›¸å¯¹ç‹¬ç«‹ ç¼ºç‚¹ï¼šç ´åå°è£…ï¼Œå­ç±»ä¸Žçˆ¶ç±»ä¹‹é—´ç´§å¯†è€¦åˆï¼Œå­ç±»ä¾èµ–äºŽçˆ¶ç±»çš„å®žçŽ°ï¼Œå­ç±»ç¼ºä¹ç‹¬ç«‹æ€§ ä¼˜ç‚¹ï¼šå…·æœ‰è¾ƒå¥½çš„å¯æ‰©å±•æ€§ ç¼ºç‚¹ï¼šæ”¯æŒæ‰©å±•ï¼Œä½†æ˜¯å¾€å¾€ä»¥å¢žåŠ ç³»ç»Ÿç»“æž„çš„å¤æ‚åº¦ä¸ºä»£ä»· ä¼˜ç‚¹ï¼šæ”¯æŒåŠ¨æ€ç»„åˆã€‚åœ¨è¿è¡Œæ—¶ï¼Œæ•´ä½“å¯¹è±¡å¯ä»¥é€‰æ‹©ä¸åŒç±»åž‹çš„å±€éƒ¨å¯¹è±¡ ç¼ºç‚¹ï¼šä¸æ”¯æŒåŠ¨æ€ç»§æ‰¿ã€‚åœ¨è¿è¡Œæ—¶ï¼Œå­ç±»æ— æ³•é€‰æ‹©ä¸åŒçš„çˆ¶ç±» ä¼˜ç‚¹ï¼šæ•´ä½“ç±»å¯ä»¥å¯¹å±€éƒ¨ç±»è¿›è¡ŒåŒ…è£…ï¼Œå°è£…å±€éƒ¨ç±»çš„æŽ¥å£ï¼Œæä¾›æ–°çš„æŽ¥å£ ç¼ºç‚¹ï¼šå­ç±»ä¸èƒ½æ”¹å˜çˆ¶ç±»çš„æŽ¥å£ ç¼ºç‚¹ï¼šæ•´ä½“ç±»ä¸èƒ½è‡ªåŠ¨èŽ·å¾—å’Œå±€éƒ¨ç±»åŒæ ·çš„æŽ¥å£ ä¼˜ç‚¹ï¼šå­ç±»èƒ½è‡ªåŠ¨ç»§æ‰¿çˆ¶ç±»çš„æŽ¥å£ ç¼ºç‚¹ï¼šåˆ›å»ºæ•´ä½“ç±»çš„å¯¹è±¡æ—¶ï¼Œéœ€è¦åˆ›å»ºæ‰€æœ‰å±€éƒ¨ç±»çš„å¯¹è±¡ ä¼˜ç‚¹ï¼šåˆ›å»ºå­ç±»çš„å¯¹è±¡æ—¶ï¼Œæ— é¡»åˆ›å»ºçˆ¶ç±»çš„å¯¹è±¡ å¦‚ä½•é€‰æ‹©ç›¸ä¿¡å¾ˆå¤šäººéƒ½çŸ¥é“é¢å‘å¯¹è±¡ä¸­æœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„åŽŸåˆ™ã€Žå¤šç”¨ç»„åˆã€å°‘ç”¨ç»§æ‰¿ã€æˆ–è€…è¯´ã€Žç»„åˆä¼˜äºŽç»§æ‰¿ã€ã€‚ä»Žå‰é¢çš„ä»‹ç»å·²ç»ä¼˜ç¼ºç‚¹å¯¹æ¯”ä¸­ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œç»„åˆç¡®å®žæ¯”ç»§æ‰¿æ›´åŠ çµæ´»ï¼Œä¹Ÿæ›´æœ‰åŠ©äºŽä»£ç ç»´æŠ¤ã€‚ æ‰€ä»¥ï¼Œ å»ºè®®åœ¨åŒæ ·å¯è¡Œçš„æƒ…å†µä¸‹ï¼Œä¼˜å…ˆä½¿ç”¨ç»„åˆè€Œä¸æ˜¯ç»§æ‰¿ã€‚ å› ä¸ºç»„åˆæ›´å®‰å…¨ï¼Œæ›´ç®€å•ï¼Œæ›´çµæ´»ï¼Œæ›´é«˜æ•ˆã€‚ æ³¨æ„ï¼Œå¹¶ä¸æ˜¯è¯´ç»§æ‰¿å°±ä¸€ç‚¹ç”¨éƒ½æ²¡æœ‰äº†ï¼Œå‰é¢è¯´çš„æ˜¯ã€åœ¨åŒæ ·å¯è¡Œçš„æƒ…å†µä¸‹ã€‘ã€‚æœ‰ä¸€äº›åœºæ™¯è¿˜æ˜¯éœ€è¦ä½¿ç”¨ç»§æ‰¿çš„ï¼Œæˆ–è€…æ˜¯æ›´é€‚åˆä½¿ç”¨ç»§æ‰¿ã€‚ è½¬è½½è‡ªhttp://www.hollischuang.com/archives/1319]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvmåžƒåœ¾æ”¶é›†å™¨ä¸Žå†…å­˜åˆ†é…ç­–ç•¥]]></title>
    <url>%2Fjvm-GC%2F</url>
    <content type="text"><![CDATA[åžƒåœ¾æ”¶é›†å™¨ä¸Žå†…å­˜åˆ†é…ç­–ç•¥åžƒåœ¾å›žæ”¶ç®—æ³•å¼•ç”¨è®¡æ•°ç®—æ³•ï¼šç»™å¯¹è±¡æ·»åŠ ä¸€ä¸ªå¼•ç”¨è®¡æ•°å™¨ï¼Œæ¯å½“æœ‰ä¸€ä¸ªåœ°æ–¹å¼•ç”¨æ—¶å°±åŠ 1ï¼Œå½“å¼•ç”¨å¤±æ•ˆå°±å‡1ã€‚å½“å¼•ç”¨ä¸º0æ—¶ä¼šè¢«å›žæ”¶ã€‚ å¯è¾¾æ€§åˆ†æžç®—æ³•ï¼šé€šè¿‡ä¸€ç³»åˆ—çš„ç§°ä¸ºâ€œGC Rootsâ€çš„å¯¹è±¡ä½œä¸ºèµ·å§‹ç‚¹ï¼Œä»Žè¿™äº›èŠ‚ç‚¹å¼€å§‹å‘ä¸‹æœç´¢ï¼Œæœç´¢èµ°è¿‡çš„è·¯ä½œä¸ºå¼•ç”¨é“¾ï¼Œå½“ä¸€ä¸ªå¯¹è±¡æ²¡æœ‰ä»»ä½•å¼•ç”¨é“¾ç›¸è”ï¼Œåˆ™è¯¥å¯¹è±¡ä¸å¯è¾¾ï¼Œå³ä¸ºå¯å›žæ”¶çš„å¯¹è±¡ã€‚ GC-RootsåŒ…æ‹¬ï¼š è™šæ‹Ÿæœºæ ˆï¼ˆæ ˆå¸§ä¸­æœ¬åœ°å˜é‡è¡¨ï¼‰ä¸­å¼•ç”¨çš„å¯¹è±¡ æ–¹æ³•åŒºä¸­ç±»é™æ€å±žæ€§å¼•ç”¨çš„å¯¹è±¡ æ–¹æ³•åŒºä¸­å¸¸é‡å¼•ç”¨çš„å¯¹è±¡ æœ¬åœ°æ–¹æ³•æ ˆä¸­JNIï¼ˆä¸€èˆ¬ä¸ºNativeæ–¹æ³•ï¼‰å¼•ç”¨çš„å¯¹è±¡ æ ‡è®°-æ¸…é™¤ç®—æ³•ï¼šé¦–å…ˆæ ‡è®°æ‰€æœ‰éœ€è¦å›žæ”¶çš„å¯¹è±¡ï¼Œåœ¨æ ‡è®°å®ŒæˆåŽç»Ÿä¸€å›žæ”¶æ‰€æœ‰è¢«æ ‡è®°çš„å¯¹è±¡ ä¸è¶³ä¹‹å¤„ï¼š æ ‡è®°å’Œæ¸…é™¤ä¸¤ä¸ªè¿‡ç¨‹æ•ˆçŽ‡éƒ½ä¸é«˜ ç»“æŸåŽä¼šäº§ç”Ÿå¤§é‡ç¢Žç‰‡ å¤åˆ¶ç®—æ³•ï¼šæŠŠå†…å­˜åˆ’åˆ†ä¸ºå¤§å°ç›¸ç­‰çš„ä¸¤å—ï¼Œæ¯æ¬¡ä½¿ç”¨å…¶ä¸­ä¸€å—ï¼Œä½¿ç”¨çš„é‚£å—å‘ç”ŸGCæ—¶å°†å­˜æ´»çš„å¯¹è±¡å¤åˆ¶åˆ°å¦ä¸€å—ï¼Œæ¯æ¬¡åªå¯¹ä¸€ä¸ªåŠåŒºè¿›è¡Œå›žæ”¶ã€‚ ä¸è¶³ï¼šå°†å†…å­˜ç¼©å°ä¸ºåŽŸæ¥çš„ä¸€åŠï¼Œæµªè´¹ç©ºé—´ æ ‡è®°-æ•´ç†ç®—æ³•ï¼šæ ‡è®°è¿‡ç¨‹ä¸Žâ€œæ ‡è®°-æ¸…é™¤ç®—æ³•â€ç›¸åŒï¼Œç„¶åŽå°†å¯¹è±¡ç¢Žç‰‡éƒ½å‘ä¸€è¾¹ç§»åŠ¨ï¼Œåˆæˆä¸€ä¸ªæ•´ä½“ å†è°ˆå¼•ç”¨å¼ºå¼•ç”¨ï¼šæ™®éå­˜åœ¨ï¼Œå³Object obj = new Object(); åªè¦å¼ºå¼•ç”¨è¿˜åœ¨å¯¹è±¡å°±ä¸ä¼šè¢«å›žæ”¶ è½¯å¼•ç”¨ï¼šæè¿°ä¸€äº›æœ‰ç”¨ä½†å´éžå¿…éœ€çš„å¯¹è±¡ï¼Œåœ¨å‘ç”Ÿå†…å­˜æº¢å‡ºå¼‚å¸¸ä¹‹å‰ä¼šè¢«å›žæ”¶ã€‚ å¼±å¼•ç”¨ï¼šæè¿°éžå¿…éœ€å¯¹è±¡ï¼Œæ¯”è½¯å¼•ç”¨å¼±ä¸€äº›ï¼Œåœ¨å‘ç”ŸGCä¹‹å‰ä¼šè¢«å›žæ”¶ã€‚ è™šå¼•ç”¨ï¼šæœ€å¼±çš„å¼•ç”¨ï¼Œå¯¹äºŽå¯¹è±¡çš„ç”Ÿå­˜å‘¨æœŸæ— å½±å“ï¼Œä¹Ÿæ— æ³•é€šè¿‡è™šå¼•ç”¨æ¥èŽ·å¾—å¯¹è±¡å®žä¾‹ã€‚åªæ˜¯åœ¨å¯¹è±¡è¢«å›žæ”¶æ—¶ä¼šæ”¶åˆ°é€šçŸ¥ã€‚ åžƒåœ¾æ”¶é›†å™¨Serialæ”¶é›†å™¨å•çº¿ç¨‹æ”¶é›†å™¨ï¼Œåœ¨GCæ—¶éœ€è¦STWï¼Œå³â€œStop The Worldâ€æš‚åœå…¶ä»–æ‰€æœ‰å·¥ä½œçº¿ç¨‹ã€‚ç¼ºç‚¹æ˜¾è€Œæ˜“è§ï¼Œåœé¡¿é•¿ä½“éªŒå·®ã€‚å”¯ä¸€çš„ä¼˜ç‚¹æ˜¯æ²¡æœ‰å¤šä½™çš„çº¿ç¨‹å¼€é”€ï¼Œæœ€é«˜çš„å•çº¿ç¨‹æ”¶é›†æ•ˆçŽ‡ï¼Œå¯¹äºŽåˆ†é…å†…å­˜è¾ƒå°çš„æ¡Œé¢åº”ç”¨ï¼ˆClientï¼‰åœé¡¿ä¸€èˆ¬æŽ§åˆ¶åœ¨å‡ åæ¯«ç§’ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é€‰æ‹©ã€‚ ParNewæ”¶é›†å™¨Serialçš„å¤šçº¿ç¨‹ç‰ˆæœ¬ï¼Œæ˜¯è®¸å¤šè¿è¡Œåœ¨serveræ¨¡å¼ä¸‹jvmé¦–é€‰çš„æ–°ç”Ÿä»£æ”¶é›†å™¨ï¼Œè€Œä¸”é™¤äº†Serialåªæœ‰ParNewèƒ½ä¸ŽCMSæ”¶é›†å™¨é…åˆå·¥ä½œ å¹¶è¡Œï¼šå¤šä¸ªå¤„ç†å™¨ä¸Šå¤šä¸ªä»»åŠ¡ å¹¶å‘ï¼šä¸€ä¸ªå¤„ç†å™¨ä¸Šå¤šä¸ªä»»åŠ¡ Parallel Scavengeæ”¶é›†å™¨å¤šçº¿ç¨‹ä½¿ç”¨å¤åˆ¶ç®—æ³•çš„æ–°ç”Ÿä»£æ”¶é›†å™¨ï¼Œå…³æ³¨ç‚¹ä¸ŽCMSç­‰æ”¶é›†å™¨å°½å¯èƒ½ç¼©çŸ­åœé¡¿æ—¶é—´ä¸åŒï¼Œå…¶ç›®æ ‡æ˜¯è¾¾åˆ°ä¸€ä¸ªå¯æŽ§åˆ¶çš„åžåé‡ï¼ˆåžåé‡=è¿è¡Œç”¨æˆ·ä»£ç æ—¶é—´ / ï¼ˆè¿è¡Œç”¨æˆ·ä»£ç æ—¶é—´ + åžƒåœ¾æ”¶é›†æ—¶é—´ï¼‰ï¼‰ï¼Œç§°ä¸ºåžåé‡ä¼˜å…ˆæ”¶é›†å™¨ã€‚ Serial Oldæ”¶é›†å™¨Serialè€å¹´ä»£ç‰ˆæœ¬ï¼Œå•çº¿ç¨‹æ”¶é›†å™¨ï¼Œä½¿ç”¨â€œæ ‡è®°-æ•´ç†ç®—æ³•â€ã€‚ Parallel Oldæ”¶é›†å™¨Parallel Scavengeçš„è€å¹´ä»£ç‰ˆæœ¬ï¼Œä½¿ç”¨å¤šçº¿ç¨‹å’Œâ€œæ ‡è®°-æ•´ç†â€ç®—æ³•ã€‚Parallel Scavenge + Parallel OldçœŸæ­£çš„åžåé‡ä¼˜å…ˆæ”¶é›†å™¨ã€‚ CMSæ”¶é›†å™¨åŸºäºŽâ€œæ ‡è®°-æ¸…é™¤â€ç®—æ³•ï¼Œè¿‡ç¨‹åˆ†ä¸ºå››æ­¥ï¼š åˆå§‹æ ‡è®° å¹¶å‘æ ‡è®° é‡æ–°æ ‡è®° å¹¶å‘æ¸…é™¤ å…¶ä¸­åˆå§‹æ ‡è®°å’Œé‡æ–°æ ‡è®°éœ€è¦STW ç¼ºç‚¹æœ‰ä¸‰ï¼š å¯¹CPUèµ„æºæ•æ„Ÿï¼Œå¹¶å‘æ ‡è®°æ—¶ç”¨æˆ·çº¿ç¨‹æ²¡æœ‰æš‚åœï¼Œæ”¶é›†å™¨å ç”¨éƒ¨åˆ†CPUèµ„æºï¼Œå¯èƒ½ä¼šä½¿ç”¨æˆ·ç¨‹åºååº”å˜æ…¢ æ— æ³•å¤„ç†æµ®åŠ¨åžƒåœ¾ï¼Œç”±äºŽGCæ—¶ç”¨æˆ·çº¿ç¨‹è¿˜åœ¨è¿›è¡Œï¼Œä¸åœåœ°ä¼šæœ‰æ–°çš„åžƒåœ¾äº§ç”Ÿï¼Œåªèƒ½åœ¨ä¸‹ä¸€æ¬¡GCæ—¶å¤„ç†ï¼Œè¿™éƒ¨åˆ†åžƒåœ¾å«åšæµ®åŠ¨åžƒåœ¾ åŸºäºŽâ€œæ ‡è®°-æ¸…é™¤â€ç®—æ³•ï¼Œä¼šäº§ç”Ÿå¤§é‡ç©ºé—´ç¢Žç‰‡ï¼Œå¯¼è‡´æ— æ³•æ‰¾åˆ°è¶³å¤Ÿå¤§çš„è¿žç»­ç©ºé—´åˆ†é…è€Œæå‰GC G1æ”¶é›†å™¨è¿ä½œæ­¥éª¤ï¼š åˆå§‹æ ‡è®° å¹¶å‘æ ‡è®° æœ€ç»ˆæ ‡è®° ç­›é€‰å›žæ”¶ ç‰¹ç‚¹ï¼š å¹¶è¡Œä¸Žå¹¶å‘ åˆ†ä»£æ”¶é›†ï¼ˆä»ç„¶ä¿ç•™äº†åˆ†ä»£çš„æ¦‚å¿µï¼‰ ç©ºé—´æ•´åˆï¼ˆæ•´ä½“ä¸Šå±žäºŽâ€œæ ‡è®°-æ•´ç†â€ç®—æ³•ï¼Œä¸ä¼šå¯¼è‡´ç©ºé—´ç¢Žç‰‡ï¼‰ å¯é¢„æµ‹çš„åœé¡¿ï¼ˆæ¯”CMSæ›´å…ˆè¿›çš„åœ°æ–¹åœ¨äºŽèƒ½è®©ä½¿ç”¨è€…æ˜Žç¡®æŒ‡å®šæ—¶é—´ç‰‡æ®µå†…ï¼Œæ¶ˆè€—åœ¨åžƒåœ¾æ”¶é›†ä¸Šçš„æ—¶é—´ï¼‰ å†…å­˜åˆ†é…ç­–ç•¥å¯¹è±¡ä¼˜å…ˆåœ¨Edenï¼ˆå¹´è½»ä»£ï¼‰åˆ†é… æ–°ç”Ÿä»£GCï¼ˆMirror GCï¼‰ï¼šJavaå¯¹è±¡å¤§éƒ¨åˆ†éƒ½å…·å¤‡æœç”Ÿå¤•ç­çš„ç‰¹æ€§ï¼ŒMirror GCéžå¸¸é¢‘ç¹ è€å¹´ä»£GCï¼ˆFull GCï¼‰ï¼šå‡ºçŽ°Full GCå¸¸ä¼´éšç€Mirror GCï¼Œæ¯”Mirror GCæ…¢åå€ä»¥ä¸Š å¤§å¯¹è±¡ç›´æŽ¥è¿›å…¥è€å¹´ä»£è¶…è¿‡å‚æ•°çš„å¯¹è±¡ç›´æŽ¥åœ¨è€å¹´ä»£åˆ†é… é•¿æœŸå­˜æ´»çš„å¯¹è±¡å°†è¿›å…¥è€å¹´ä»£è™šæ‹Ÿæœºç»™æ¯ä¸ªå¯¹è±¡å®šä¹‰ä¸€ä¸ªå¯¹è±¡å¹´é¾„è®¡æ•°å™¨ï¼Œå½“å¯¹è±¡åœ¨Edenå‡ºç”Ÿå¹¶ä¸”ç†¬è¿‡ç¬¬ä¸€æ¬¡GCè¿›å…¥Survivorç©ºé—´ï¼Œé‚£ä¹ˆå®ƒçš„å¹´é¾„å³è®¾ä¸º1ï¼Œæ¯ç†¬è¿‡ä¸€æ¬¡GCå¹´é¾„å°±åŠ 1ï¼Œè¾¾åˆ°é˜ˆå€¼å°±ä¼šæ™‹å‡åˆ°è€å¹´ä»£ä¸­ å¯¹è±¡å¹´é¾„åˆ¤æ–­ç„¶è€Œä¹Ÿå¹¶ä¸æ˜¯ä¸€å®šè¦åˆ°è¾¾é˜ˆå€¼æ‰èƒ½æ™‹å‡ï¼Œå¦‚æžœåœ¨Survivorç©ºé—´ç›¸åŒå¹´é¾„çš„å¯¹è±¡çš„æ€»å’Œå¤§äºŽSurvivorç©ºé—´çš„ä¸€åŠï¼Œå¤§äºŽç­‰äºŽè¯¥å¹´é¾„çš„å¯¹è±¡å³å¯ç›´æŽ¥è¿›å…¥è€å¹´ä»£ ç©ºé—´åˆ†é…æ‹…ä¿Mirror GCä¹‹å‰è™šæ‹Ÿæœºä¼šæ£€æŸ¥è€å¹´ä»£å¯ç”¨ç©ºé—´æ˜¯å¦å¤§äºŽæ–°ç”Ÿä»£æ‰€æœ‰å¯¹è±¡å¤§å°æ€»å’Œï¼Œå¦‚æžœæ˜¯ï¼Œé‚£ä¹ˆå¯ä»¥ç¡®ä¿Mirror GCå®‰å…¨ã€‚å¦‚æžœä¸æ˜¯çš„è¯ï¼Œçœ‹æ˜¯å¦å…è®¸æ‹…ä¿å¤±è´¥ï¼ˆå…è®¸å†’é™©ï¼‰ï¼Œå¦‚æžœå…è®¸é‚£ä¹ˆå°†æ£€æŸ¥è€å¹´ä»£å¯ç”¨ç©ºé—´æ˜¯å¦å¤§äºŽåŽ†æ¬¡æ™‹å‡å¯¹è±¡å¤§å°çš„å¹³å‡å€¼ï¼Œå¦‚æžœæ˜¯çš„è¯å°†è¿›è¡Œä¸€æ¬¡Mirror GCï¼Œå°½ç®¡æœ‰é£Žé™©ä¼šå¤±è´¥ï¼›å¦‚æžœå°äºŽé‚£ä¹ˆå°†è¿›è¡ŒFull GC]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvmä¹‹å†…å­˜åŒºåŸŸ]]></title>
    <url>%2Fjvm-neicun%2F</url>
    <content type="text"><![CDATA[Javaå†…å­˜åŒºåŸŸåˆ’åˆ†ï¼š ç¨‹åºè®¡æ•°å™¨ï¼šçº¿ç¨‹ç§æœ‰ã€‚å½“å‰æ‰€æ‰§è¡Œçº¿ç¨‹çš„è¡Œå·æŒ‡ç¤ºå™¨ è™šæ‹Ÿæœºæ ˆï¼šçº¿ç¨‹ç§æœ‰ã€‚æ–¹æ³•æ‰§è¡Œçš„åŒæ—¶åˆ›å»ºä¸€ä¸ªæ ˆå¸§ï¼Œç”¨äºŽå­˜å‚¨å±€éƒ¨å˜é‡è¡¨ï¼ˆåŒ…æ‹¬åŸºæœ¬æ•°æ®ç±»åž‹ã€å¯¹è±¡å¼•ç”¨ï¼‰ã€æ“ä½œæ•°æ ˆã€åŠ¨æ€é“¾æŽ¥ã€æ–¹æ³•å‡ºå£ç­‰ã€‚æ¯ä¸€ä¸ªæ–¹æ³•ä»Žè°ƒç”¨æ‰§è¡Œç›´åˆ°ç»“æŸçš„è¿‡ç¨‹å°±å¯¹åº”ä¸€ä¸ªæ ˆå¸§å…¥æ ˆåˆ°å‡ºæ ˆçš„è¿‡ç¨‹ã€‚ æœ¬åœ°æ–¹æ³•æ ˆï¼šçº¿ç¨‹ç§æœ‰ã€‚ä¸Žè™šæ‹Ÿæœºæ ˆï¼ˆä¸ºJavaæ–¹æ³•å³å­—èŠ‚ç æœåŠ¡ï¼‰ç±»ä¼¼ï¼Œè€Œæœ¬åœ°æ–¹æ³•æ ˆä¸ºNativeæ–¹æ³•æœåŠ¡ï¼Œå³éžJavaæ–¹æ³•ï¼ˆå¦‚Cæ–¹æ³•ï¼‰ã€‚æœ‰äº›è™šæ‹Ÿæœºï¼ˆå¦‚HotSpotï¼‰ä¼šå°†è™šæ‹Ÿæœºæ ˆå’Œæœ¬åœ°æ–¹æ³•æ ˆåˆäºŒä¸ºä¸€ã€‚ å †åŒºï¼šæ‰€æœ‰çº¿ç¨‹å…±äº«ã€‚å¯¹è±¡å®žä¾‹åˆ†é…å†…å­˜çš„åœ°æ–¹ æ–¹æ³•åŒºï¼ˆéžå †ï¼‰ï¼šæ‰€æœ‰çº¿ç¨‹å…±äº«ã€‚å­˜å‚¨å·²è¢«è™šæ‹ŸæœºåŠ è½½çš„ç±»ä¿¡æ¯ï¼Œå¸¸é‡ï¼Œé™æ€å˜é‡ï¼Œå³æ—¶ç¼–è¯‘åŽçš„ä»£ç ç­‰æ•°æ® è¿è¡Œæ—¶å¸¸é‡æ± ï¼šæ˜¯æ–¹æ³•åŒºçš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºŽå­˜æ”¾ç¼–è¯‘æœŸäº§ç”Ÿçš„å„ç§å­—é¢é‡ï¼ˆç±»ä¼¼äºŽå¸¸é‡ï¼‰å’Œç¬¦å·å¼•ç”¨ã€‚ å†…å­˜æ³„æ¼ä¸Žå†…å­˜æº¢å‡º å†…å­˜æ³„éœ²ï¼šæŒ‡ç¨‹åºä¸­ä¸€äº›å¯¹è±¡ä¸ä¼šè¢«GCæ‰€å›žæ”¶ï¼Œå®ƒå§‹ç»ˆå ç”¨å†…å­˜ï¼Œå³è¢«åˆ†é…çš„å¯¹è±¡å¼•ç”¨é“¾å¯è¾¾ä½†å·²æ— ç”¨ã€‚ï¼ˆå¯ç”¨å†…å­˜å‡å°‘ï¼‰ å†…å­˜æº¢å‡ºï¼šç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­æ— æ³•ç”³è¯·åˆ°è¶³å¤Ÿçš„å†…å­˜è€Œå¯¼è‡´çš„ä¸€ç§é”™è¯¯ã€‚å†…å­˜æº¢å‡ºé€šå¸¸å‘ç”ŸäºŽOLDæ®µæˆ–Permæ®µåžƒåœ¾å›žæ”¶åŽï¼Œä»ç„¶æ— å†…å­˜ç©ºé—´å®¹çº³æ–°çš„Javaå¯¹è±¡çš„æƒ…å†µã€‚ å†…å­˜æ³„éœ²æ˜¯å†…å­˜æº¢å‡ºçš„ä¸€ç§è¯±å› ï¼Œä¸æ˜¯å”¯ä¸€å› ç´ ã€‚ å¯¹è±¡åˆ›å»ºçš„å †å†…å­˜åˆ†é…æ–¹å¼ æŒ‡é’ˆç¢°æ’žï¼šå†…å­˜è§„æ•´æ— ç¢Žç‰‡æ—¶ï¼Œç›´æŽ¥åˆ’åˆ†å †å°¾éƒ¨å†…å­˜ç»™å¯¹è±¡ã€‚ ç©ºé—²åˆ—è¡¨ï¼šæœ‰ç¢Žç‰‡æ—¶ï¼Œç»´æŠ¤ä¸€ä¸ªåˆ—è¡¨è®°å½•å“ªäº›å†…å­˜å¯ç”¨ï¼Œå¹¶åˆ†é…è¶³å¤Ÿå¤§çš„å†…å­˜ç»™å¯¹è±¡ã€‚ å¯¹è±¡çš„å†…å­˜å¸ƒå±€å¯¹è±¡çš„å†…å­˜å¸ƒå±€åŒ…æ‹¬ï¼š å¯¹è±¡å¤´ï¼šå‚¨å­˜å¯¹è±¡è‡ªèº«è¿è¡Œæ—¶æ•°æ®ï¼Œå¦‚å“ˆå¸Œç ã€GCåˆ†ä»£å¹´é¾„ã€çº¿ç¨‹æŒæœ‰é”ç­‰ å®žä¾‹æ•°æ®ï¼šå¯¹è±¡çœŸæ­£å‚¨å­˜çš„æœ‰æ•ˆä¿¡æ¯ å¯¹é½å¡«å……ï¼šç”±äºŽå¯¹è±¡å¤§å°å¿…é¡»æ˜¯8çš„æ•´æ•°å€ï¼Œå¯¹è±¡å¤´æ­£å¥½æ˜¯8çš„æ•´æ•°å€ï¼Œå¦‚æžœå®žä¾‹æ•°æ®éƒ¨åˆ†æ²¡æœ‰å¯¹é½ï¼Œåˆ™éœ€è¦å¯¹é½æˆ8çš„å€æ•° å¯¹è±¡çš„è®¿é—®å®šä½ é€šè¿‡å¥æŸ„è®¿é—®ï¼šä½¿ç”¨å¥æŸ„è®¿é—®æ–¹å¼ï¼Œjavaå †å°†ä¼šåˆ’åˆ†å‡ºæ¥ä¸€éƒ¨åˆ†å†…å­˜åŽ»æ¥ä½œä¸ºå¥æŸ„æ± ï¼Œreferenceä¸­å­˜å‚¨çš„å°±æ˜¯å¯¹è±¡çš„å¥æŸ„åœ°å€ã€‚è€Œå¥æŸ„ä¸­åˆ™åŒ…å«å¯¹è±¡å®žä¾‹æ•°æ®çš„åœ°å€å’Œå¯¹è±¡ç±»åž‹æ•°æ®ï¼ˆå¦‚å¯¹è±¡çš„ç±»åž‹ï¼Œå®žçŽ°çš„æŽ¥å£ã€æ–¹æ³•ã€çˆ¶ç±»ã€fieldç­‰ï¼‰çš„å…·ä½“åœ°å€ä¿¡æ¯ã€‚ é€šè¿‡ç›´æŽ¥æŒ‡é’ˆè®¿é—®ï¼š å¦‚æžœä½¿ç”¨æŒ‡é’ˆè®¿é—®ï¼Œé‚£ä¹ˆjavaå †å¯¹è±¡çš„å¸ƒå±€ä¸­å°±å¿…é¡»è€ƒè™‘å¦‚ä½•æ”¾ç½®è®¿é—®ç±»åž‹çš„ç›¸å…³ä¿¡æ¯ï¼ˆå¦‚å¯¹è±¡çš„ç±»åž‹ï¼Œå®žçŽ°çš„æŽ¥å£ã€æ–¹æ³•ã€çˆ¶ç±»ã€fieldç­‰ï¼‰ï¼Œè€Œreferenceä¸­å­˜å‚¨çš„å°±æ˜¯å¯¹è±¡çš„åœ°å€ è¿™ä¸¤ç§è®¿é—®æ–¹å¼å„æœ‰åˆ©å¼Šï¼Œä½¿ç”¨å¥æŸ„è®¿æœ€å¤§çš„å¥½å¤„æ˜¯referenceä¸­å­˜å‚¨ç€ç¨³å®šçš„å¥æŸ„åœ°å€ï¼Œå½“å¯¹è±¡ç§»åŠ¨ä¹‹åŽï¼ˆåžƒåœ¾æ”¶é›†æ—¶ç§»åŠ¨å¯¹è±¡æ˜¯éžå¸¸æ™®éçš„è¡Œä¸ºï¼‰ï¼Œåªéœ€è¦æ”¹å˜å¥æŸ„ä¸­çš„å¯¹è±¡å®žä¾‹åœ°å€å³å¯ï¼Œreferenceä¸ç”¨ä¿®æ”¹ã€‚ ä½¿ç”¨æŒ‡é’ˆè®¿é—®çš„å¥½å¤„æ˜¯è®¿é—®é€Ÿåº¦å¿«ï¼Œå®ƒå‡å°‘äº†ä¸€æ¬¡æŒ‡é’ˆå®šä½çš„æ—¶é—´å¼€é”€ï¼Œç”±äºŽjavaæ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œåœ¨å¼€å‘ä¸­javaå¯¹è±¡çš„è®¿é—®éžå¸¸çš„é¢‘ç¹ï¼Œå› æ­¤è¿™ç±»å¼€é”€ç§¯å°‘æˆå¤šä¹Ÿæ˜¯éžå¸¸å¯è§‚çš„ï¼Œåä¹‹åˆ™æå‡è®¿é—®é€Ÿåº¦ã€‚å¯¹äºŽHotSpotè™šæ‹Ÿæœºæ¥è¯´ï¼Œä½¿ç”¨çš„å°±æ˜¯ç›´æŽ¥æŒ‡é’ˆè®¿é—®çš„æ–¹å¼ã€‚]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºŽJavaåå°„çš„ç†è§£]]></title>
    <url>%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[é¦–å…ˆï¼Œä»ŽåŠ¨æ€è¯­è¨€è®²èµ·ã€‚åƒPythonã€Rubyè¿™ç§è¯­è¨€ï¼Œåªè¦ä¿®æ”¹äº†ä»£ç ï¼Œä¿®æ”¹çš„æ•ˆæžœç«‹å³ç”Ÿæ•ˆï¼Œå› ä¸ºè¿™ç§è¯­è¨€æ˜¯æ— éœ€ç¼–è¯‘ï¼Œç›´æŽ¥æ‰§è¡Œä»£ç çš„ï¼Œæˆ‘ä»¬ç§°è¿™ç±»è¯­è¨€æ˜¯â€œåŠ¨æ€è¯­è¨€â€ã€‚è€ŒC++ã€Javaè¿™ç§ï¼Œåœ¨è¿è¡Œä¹‹å‰éœ€è¦å…ˆç¼–è¯‘ï¼Œå¦‚æžœä¸­é€”ä¿®æ”¹äº†ä»£ç ä¸é‡æ–°ç¼–è¯‘åŽ»æ‰§è¡Œçš„è¯å°±æ²¡æœ‰å˜åŒ–ã€‚ä½†æ˜¯ï¼ŒJavaæœ‰ä¸€ä¸ªéžå¸¸çªå‡ºçš„åŠ¨æ€ç›¸å…³æœºåˆ¶ï¼Œå³åå°„ï¼šæˆ‘ä»¬å¯ä»¥äºŽè¿è¡Œæ—¶ï¼ˆåŒºåˆ«äºŽç¼–è¯‘æ—¶ï¼‰åŠ è½½ã€æŽ¢çŸ¥ã€ä½¿ç”¨ç¼–è¯‘æœŸé—´å®Œå…¨æœªçŸ¥çš„classesã€‚æ¢å¥è¯è¯´ï¼ŒJavaç¨‹åºå¯ä»¥åŠ è½½ä¸€ä¸ªè¿è¡Œæ—¶æ‰å¾—çŸ¥åç§°çš„classï¼ˆåœ¨è¿™ä¹‹å‰ä¿®æ”¹è¿™ä¸ªç±»å³æ—¶ä¸ç¼–è¯‘éƒ½æœ‰æ•ˆï¼‰ï¼ŒèŽ·æ‚‰å…¶å®Œæ•´æž„é€ ï¼ˆä½†ä¸åŒ…æ‹¬methodså®šä¹‰ï¼‰ï¼Œå¹¶ç”Ÿæˆå…¶å¯¹è±¡å®žä½“ã€æˆ–å¯¹å…¶fieldsè®¾å€¼ã€æˆ–å”¤èµ·å…¶methodsã€‚ å†é€šä¿—åœ°è¯´ä¸€ä¸‹ä»€ä¹ˆæ˜¯åå°„ï¼Ÿ æ™®é€šçš„Javaå¯¹è±¡æ˜¯é€šè¿‡newå…³é”®å­—æŠŠå¯¹åº”ç±»çš„å­—èŠ‚ç æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ï¼Œç„¶åŽåˆ›å»ºè¯¥å¯¹è±¡çš„ã€‚ åå°„æ˜¯é€šè¿‡ä¸€ä¸ªåä¸ºClassçš„ç‰¹æ®Šç±»ï¼Œç”¨Class.forName(â€œç±»åâ€);å¾—åˆ°ç±»çš„å­—èŠ‚ç å¯¹è±¡ï¼Œç„¶åŽç”¨newInstance()æ–¹æ³•åœ¨è™šæ‹Ÿæœºå†…éƒ¨æž„é€ è¿™ä¸ªå¯¹è±¡ï¼ˆé’ˆå¯¹æ— å‚æž„é€ å‡½æ•°ï¼‰ã€‚ ä¹Ÿå°±æ˜¯è¯´åå°„æœºåˆ¶è®©æˆ‘ä»¬å¯ä»¥åœ¨ç¨‹åºè¿è¡Œæ—¶åŠ¨æ€åœ°æ‹¿åˆ°Javaç±»å¯¹åº”çš„å­—èŠ‚ç å¯¹è±¡ï¼ˆè€Œä¸æ˜¯åœ¨ç¼–è¯‘çš„æ—¶å€™ï¼‰ï¼Œç„¶åŽåŠ¨æ€çš„è¿›è¡Œä»»ä½•å¯èƒ½çš„æ“ä½œã€‚åå°„çš„åŠŸèƒ½ä¸»è¦åŒ…æ‹¬ï¼š åœ¨è¿è¡Œæ—¶åˆ¤æ–­ä»»æ„ä¸€ä¸ªå¯¹è±¡æ‰€å±žçš„ç±» åœ¨è¿è¡Œæ—¶æž„é€ ä»»æ„ä¸€ä¸ªç±»çš„å¯¹è±¡ åœ¨è¿è¡Œæ—¶åˆ¤æ–­ä»»æ„ä¸€ä¸ªç±»æ‰€å…·æœ‰çš„æˆå‘˜å˜é‡å’Œæ–¹æ³• åœ¨è¿è¡Œæ—¶è°ƒç”¨ä»»æ„ä¸€ä¸ªå¯¹è±¡çš„æ–¹æ³•ï¼ˆè¿™æ ·å°±å¯ä»¥ä¿®æ”¹è¿™ä¸ªå¯¹è±¡çš„å±žæ€§ï¼‰ ç”ŸæˆåŠ¨æ€ä»£ç† ä½¿ç”¨åå°„çš„ä¸»è¦ä½œç”¨æ˜¯æ–¹ä¾¿ç¨‹åºçš„æ‰©å±•ï¼Œç”±äºŽå…¶è¿è¡Œæ—¶åŠ¨æ€åŠ è½½çš„ç‰¹æ€§ã€‚ Classç±»Javaä¸­åªæœ‰2ç§ä¸œè¥¿ä¸æ˜¯é¢å‘å¯¹è±¡çš„ï¼Œä¸€ä¸ªåŸºæœ¬ç±»åž‹ï¼Œä¸€ä¸ªé™æ€æˆå‘˜ï¼ˆæ–¹æ³•ã€å˜é‡ã€å¸¸é‡ï¼‰ã€‚æˆ‘ä»¬æä¾›çš„æ¯ä¸€ä¸ªç±»ä¹Ÿæ˜¯å¯¹è±¡ï¼Œä¸€ä¸ªç±»çš„ç±»ç±»åž‹æ˜¯java.lang.Classç±»çš„å®žä¾‹å¯¹è±¡ã€‚ 123456789101112131415161718192021// åˆ›å»ºç±»Fooçš„å®žä¾‹å¯¹è±¡Foo foo1 = new Foo();// Fooè¿™ä¸ªç±»ä¹Ÿæ˜¯ä¸€ä¸ªå®žä¾‹å¯¹è±¡ï¼ŒClassç±»çš„å®žä¾‹å¯¹è±¡// ä»»ä½•ä¸€ä¸ªç±»éƒ½æ˜¯Classçš„å®žä¾‹å¯¹è±¡ï¼Œè¿™ä¸ªå®žä¾‹å¯¹è±¡æœ‰ä¸‰ç§è¡¨è¾¾æ–¹å¼// ç¬¬ä¸€ç§è¡¨è¾¾æ–¹å¼ã€‚å®žé™…ä¸Šè¡¨æ˜Žä»»ä½•ä¸€ä¸ªç±»éƒ½æœ‰ä¸€ä¸ªéšå«çš„é™æ€æˆå‘˜å˜é‡ClassClass c1 = Foo.class;// ç¬¬äºŒç§è¡¨è¾¾æ–¹å¼Class c2 = foo1.getClass();// æ ¹æ®å®˜ç½‘è¯´æ³•ï¼Œc1,c2è¡¨ç¤ºäº†Fooç±»çš„ç±»ç±»åž‹(class type)// ç±»ä¹Ÿæ˜¯å¯¹è±¡ï¼Œæ˜¯Classç±»çš„å®žä¾‹å¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡æˆ‘ä»¬æˆä¸ºè¯¥ç±»çš„ç±»ç±»åž‹System.out.println(c1==c2) // true // ç¬¬ä¸‰ç§è¡¨è¾¾æ–¹å¼Class c3 = Class.forName("Foo"); System.out.println(c1==c3) // true Classç±»çš„æž„é€ å™¨æ˜¯ç§æœ‰çš„ï¼Œåªèƒ½JVMèƒ½åˆ›å»ºClassç±»çš„å®žä¾‹å¯¹è±¡ã€‚ å¯ä»¥é€šè¿‡ç±»ç±»åž‹ (ä¸Šé¢çš„c1 c2 c3)åˆ›å»ºFooç±»çš„å®žä¾‹å¯¹è±¡ï¼š 1Foo foo = (Foo)c1.newInstance(); åŠ¨æ€åŠ è½½ç±»ä»€ä¹ˆæ˜¯åŠ¨æ€åŠ è½½ï¼Ÿä»€ä¹ˆæ˜¯é™æ€åŠ è½½ï¼Ÿ é™æ€åŠ è½½çš„ç±»åœ¨ç¼–è¯‘çš„æ—¶å€™å°±è¦æä¾›ï¼Œè€ŒåŠ¨æ€åŠ è½½çš„ç±»åœ¨æºç¨‹åºç¼–è¯‘æ—¶å¯ä»¥ç¼ºå¸­ã€‚åŒºåˆ†ç¼–è¯‘æ—¶å’Œè¿è¡Œæ—¶ã€‚ Class.forName(â€œç±»åâ€) è¿™ç§æ–¹å¼ï¼Œä¸ä»…è¡¨ç¤ºäº†ç±»çš„ç±»ç±»åž‹ï¼Œè¿˜ä»£è¡¨äº†åŠ¨æ€åŠ è½½ç±»ã€‚ ç”¨newè¿™ç§æ–¹å¼é™æ€åŠ è½½æ–¹å¼ï¼Œç¼–è¯‘çš„æ—¶å€™ï¼Œå¦‚æžœnewçš„å¯¹è±¡çš„é‚£ä¸ªç±»ä¸å­˜åœ¨çš„è¯ï¼Œç¼–è¯‘ä¸é€šè¿‡ï¼›ä½†æ˜¯ç”¨Class.forNameè¿™ç§åŠ¨æ€åŠ è½½æ–¹å¼ï¼Œæ²¡æœ‰è¿™ä¸ªç±»ç¼–è¯‘çš„æ—¶å€™ä¸ä¼šæŠ¥ä»»ä½•é”™ï¼Œä½†æ˜¯è¿è¡Œçš„æ—¶å€™ä¼šå› ä¸ºæ‰¾ä¸åˆ°è¿™ä¸ªç±»è€ŒæŠ¥é”™ã€‚åŠ¨æ€åŠ è½½æœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿé…åˆæŽ¥å£ç¼–ç¨‹ï¼Œå¯ä»¥å®žçŽ°ä¸€ä¸ªæŽ¥å£å¯¹å¤šç§å®žçŽ°ï¼Œä»Žè€Œå¯ä»¥åŠ¨æ€åœ°åŽ»é€‰æ‹©å®Œæˆä¸åŒçš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œç±»åŠ¨æ€åŠ è½½å¯¹æ‰©å±•åŠŸèƒ½å¾ˆæœ‰ç”¨ã€‚ å…¶å®žï¼ŒåŠ¨æ€ç±»åŠ è½½ä¸»è¦å°±æ˜¯é€šè¿‡åå°„æœºåˆ¶å°†ç±»å¯¹è±¡æ³¨å…¥è¿›åŽ»ã€‚ é™æ€åŠ è½½ï¼š 12345678910111213public class Office_Static &#123; public static void main(String[] args) &#123; //new åˆ›å»ºå¯¹è±¡ï¼Œæ˜¯é™æ€åŠ è½½ç±»ï¼Œåœ¨ç¼–è¯‘æ—¶åˆ»å°±éœ€è¦ç”¨åˆ°Wordå’ŒExcelï¼Œå¹¶å°†å…¶ç¼–è¯‘ if("Word".equals(args[0]))&#123; Word w = new Word(); w.start(); &#125; if("Excel".equals(args[0]))&#123; Excel e = new Excel(); e.start(); &#125; &#125; &#125; åŠ¨æ€åŠ è½½ï¼š 123public interface OfficeAble &#123; public void start(); &#125; 12345public class Word implements OfficeAble &#123; public void start()&#123; System.out.println("word start"); &#125; &#125; 12345public class Excel implements OfficeAble &#123; public void start()&#123; System.out.println("excel start"); &#125; &#125; 1234567891011121314public class OfficeBetter &#123; public static void main(String[] args) &#123; try &#123; //åŠ¨æ€åŠ è½½ç±»ï¼Œåœ¨è¿è¡Œæ—¶åˆ»æ‰è¦ç”¨è¿™ä¸ªç±» Class c = Class.forName(args[0]);//åœ¨è¿è¡Œé…ç½®é‡Œé¢è¾“å…¥com.imooc.åŠ è½½ç±».Excel //é€šè¿‡ç±»ç±»åž‹ï¼Œåˆ›å»ºè¯¥ç±»å¯¹è±¡(å…ˆè½¬æ¢ä¸ºWordå’ŒExcelçš„å…±åŒæŽ¥å£OfficeAble) OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; é€šè¿‡åå°„åŠ¨æ€èŽ·å–å¯¹è±¡çš„æ–¹æ³•å±žæ€§æž„é€ å™¨ä¿¡æ¯12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.lang.reflect.Method;import java.lang.reflect.Field;import java.lang.reflect.Constructor;public class ClassUtil &#123; /** * æ‰“å°ç±»çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç±»çš„æˆå‘˜å‡½æ•°ã€æˆå‘˜å˜é‡(åªèŽ·å–æˆå‘˜å‡½æ•°) * * @param obj * è¯¥å¯¹è±¡æ‰€å±žç±»çš„ä¿¡æ¯ */ public static void printClassMethodMessage(Object obj) &#123; // è¦èŽ·å–ç±»çš„ä¿¡æ¯ é¦–å…ˆè¦èŽ·å–ç±»çš„ç±»ç±»åž‹ Class c = obj.getClass();// ä¼ é€’çš„æ˜¯å“ªä¸ªå­ç±»çš„å¯¹è±¡ cå°±æ˜¯è¯¥å­ç±»çš„ç±»ç±»åž‹ // èŽ·å–ç±»çš„åç§° System.out.println("ç±»çš„åç§°æ˜¯:" + c.getName()); /* * Methodç±»ï¼Œæ–¹æ³•å¯¹è±¡ ä¸€ä¸ªæˆå‘˜æ–¹æ³•å°±æ˜¯ä¸€ä¸ªMethodå¯¹è±¡ * getMethods()æ–¹æ³•èŽ·å–çš„æ˜¯æ‰€æœ‰çš„publicçš„å‡½æ•°ï¼ŒåŒ…æ‹¬çˆ¶ç±»ç»§æ‰¿è€Œæ¥çš„ * getDeclaredMethods()èŽ·å–çš„æ˜¯æ‰€æœ‰è¯¥ç±»è‡ªå·±å£°æ˜Žçš„æ–¹æ³•ï¼Œä¸é—®è®¿é—®æƒé™ */ Method[] ms = c.getMethods();// c.getDeclaredMethods() for (int i = 0; i &lt; ms.length; i++) &#123; // å¾—åˆ°æ–¹æ³•çš„è¿”å›žå€¼ç±»åž‹çš„ç±»ç±»åž‹ Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName() + " "); // å¾—åˆ°æ–¹æ³•çš„åç§° System.out.print(ms[i].getName() + "("); // èŽ·å–å‚æ•°ç±»åž‹---&gt;å¾—åˆ°çš„æ˜¯å‚æ•°åˆ—è¡¨çš„ç±»åž‹çš„ç±»ç±»åž‹ Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + ","); &#125; System.out.println(")"); &#125; &#125; /** * èŽ·å–æˆå‘˜å˜é‡çš„ä¿¡æ¯ * * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * æˆå‘˜å˜é‡ä¹Ÿæ˜¯å¯¹è±¡ java.lang.reflect.Field Fieldç±»å°è£…äº†å…³äºŽæˆå‘˜å˜é‡çš„æ“ä½œ * getFields()æ–¹æ³•èŽ·å–çš„æ˜¯æ‰€æœ‰çš„publicçš„æˆå‘˜å˜é‡çš„ä¿¡æ¯ * getDeclaredFieldsèŽ·å–çš„æ˜¯è¯¥ç±»è‡ªå·±å£°æ˜Žçš„æˆå‘˜å˜é‡çš„ä¿¡æ¯ */ // Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; // å¾—åˆ°æˆå‘˜å˜é‡çš„ç±»åž‹çš„ç±»ç±»åž‹ Class fieldType = field.getType(); String typeName = fieldType.getName(); // å¾—åˆ°æˆå‘˜å˜é‡çš„åç§° String fieldName = field.getName(); System.out.println(typeName + " " + fieldName); &#125; &#125; /** * æ‰“å°å¯¹è±¡çš„æž„é€ å‡½æ•°çš„ä¿¡æ¯ * * @param obj */ public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* * æž„é€ å‡½æ•°ä¹Ÿæ˜¯å¯¹è±¡ java.lang. Constructorä¸­å°è£…äº†æž„é€ å‡½æ•°çš„ä¿¡æ¯ * getConstructorsèŽ·å–æ‰€æœ‰çš„publicçš„æž„é€ å‡½æ•° getDeclaredConstructorså¾—åˆ°æ‰€æœ‰çš„æž„é€ å‡½æ•° */ // Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName() + "("); // èŽ·å–æž„é€ å‡½æ•°çš„å‚æ•°åˆ—è¡¨---&gt;å¾—åˆ°çš„æ˜¯å‚æ•°åˆ—è¡¨çš„ç±»ç±»åž‹ Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + ","); &#125; System.out.println(")"); &#125; &#125;&#125; é€šè¿‡åå°„è¿è¡Œæ—¶åŠ¨æ€è°ƒç”¨å¯¹è±¡çš„æ–¹æ³•ç”¨æ–¹æ³•å¯¹è±¡è¿›è¡Œåå°„æ“ä½œï¼Œè¿è¡Œæ—¶åŠ¨æ€è°ƒç”¨ä¸€ä¸ªå¯¹è±¡çš„æ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; // è¦èŽ·å–print(int ,int )æ–¹æ³• 1.è¦èŽ·å–ä¸€ä¸ªæ–¹æ³•å°±æ˜¯èŽ·å–ç±»çš„ä¿¡æ¯ï¼ŒèŽ·å–ç±»çš„ä¿¡æ¯é¦–å…ˆè¦èŽ·å–ç±»çš„ç±»ç±»åž‹ A a1 = new A(); Class c = a1.getClass(); /* * 2.èŽ·å–æ–¹æ³• åç§°å’Œå‚æ•°åˆ—è¡¨æ¥å†³å®š getMethodèŽ·å–çš„æ˜¯publicçš„æ–¹æ³• getDelcaredMethodè‡ªå·±å£°æ˜Žçš„æ–¹æ³• */ try &#123; // Method m = c.getMethod("print", new // Class[]&#123;int.class,int.class&#125;); Method m = c.getMethod("print", int.class, int.class); // æ–¹æ³•çš„åå°„æ“ä½œ // a1.print(10, 20);æ–¹æ³•çš„åå°„æ“ä½œæ˜¯ç”¨må¯¹è±¡æ¥è¿›è¡Œæ–¹æ³•è°ƒç”¨ å’Œa1.printè°ƒç”¨çš„æ•ˆæžœå®Œå…¨ç›¸åŒ // æ–¹æ³•å¦‚æžœæ²¡æœ‰è¿”å›žå€¼è¿”å›žnull,æœ‰è¿”å›žå€¼è¿”å›žå…·ä½“çš„è¿”å›žå€¼ // Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); Object o = m.invoke(a1, 10, 20); System.out.println("=================="); // èŽ·å–æ–¹æ³•print(String,String) Method m1 = c.getMethod("print", String.class, String.class); // ç”¨æ–¹æ³•è¿›è¡Œåå°„æ“ä½œ // a1.print("hello", "WORLD"); o = m1.invoke(a1, "hello", "WORLD"); System.out.println("==================="); // Method m2 = c.getMethod("print", new Class[]&#123;&#125;); Method m2 = c.getMethod("print"); // m2.invoke(a1, new Object[]&#123;&#125;); m2.invoke(a1); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class A &#123; public void print() &#123; System.out.println("helloworld"); &#125; public void print(int a, int b) &#123; System.out.println(a + b); &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + "," + b.toLowerCase()); &#125;&#125; é€šè¿‡åå°„äº†è§£Javaæ³›åž‹çš„æœ¬è´¨åå°„çš„æ“ä½œéƒ½æ˜¯ç¼–è¯‘ä¹‹åŽçš„æ“ä½œï¼Œåå°„åŠ¨æ€åŠ è½½çš„ç±»æ˜¯åœ¨ç¨‹åºè¿è¡Œæ—¶ç¼–è¯‘å¹¶åŠ è½½çš„ã€‚æ¥çœ‹çœ‹ä¸‹é¢è¿™ä¸ªä¾‹å­ã€‚ 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo2&#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add("hello"); //list1.add(20);é”™è¯¯çš„ Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2);// éƒ½æ˜¯ArrayListçš„ç±»ç±»åž‹ï¼Œtrue //åå°„çš„æ“ä½œéƒ½æ˜¯ç¼–è¯‘ä¹‹åŽçš„æ“ä½œ /* * c1==c2ç»“æžœè¿”å›žtrueè¯´æ˜Žç¼–è¯‘ä¹‹åŽé›†åˆçš„æ³›åž‹æ˜¯åŽ»æ³›åž‹åŒ–çš„ * Javaä¸­é›†åˆçš„æ³›åž‹ï¼Œæ˜¯é˜²æ­¢é”™è¯¯è¾“å…¥çš„ï¼Œåªåœ¨ç¼–è¯‘é˜¶æ®µæœ‰æ•ˆï¼Œ * ç»•è¿‡ç¼–è¯‘å°±æ— æ•ˆäº† * éªŒè¯ï¼šæˆ‘ä»¬å¯ä»¥é€šè¿‡æ–¹æ³•çš„åå°„æ¥æ“ä½œï¼Œç»•è¿‡ç¼–è¯‘ */ try &#123; Method m = c2.getMethod("add", Object.class); m.invoke(list1, 20);//ç»•è¿‡ç¼–è¯‘æ“ä½œå°±ç»•è¿‡äº†æ³›åž‹ System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) &#123; System.out.println(string); &#125;*///çŽ°åœ¨ä¸èƒ½è¿™æ ·éåŽ† &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; è½¬è½½è‡ªï¼šhttp://lioncruise.github.io/2016/11/29/java-reflection/]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç†è§£Javaä¸­çš„å¼±å¼•ç”¨]]></title>
    <url>%2Fjava-reference-1%2F</url>
    <content type="text"><![CDATA[å¼ºå¼•ç”¨(Strong Reference)å¼ºå¼•ç”¨å°±æ˜¯æˆ‘ä»¬ç»å¸¸ä½¿ç”¨çš„å¼•ç”¨ï¼Œå…¶å†™æ³•å¦‚ä¸‹ StringBuffer buffer = new StringBuffer(); ä¸Šé¢åˆ›å»ºäº†ä¸€ä¸ªStringBufferå¯¹è±¡ï¼Œå¹¶å°†è¿™ä¸ªå¯¹è±¡çš„ï¼ˆå¼ºï¼‰å¼•ç”¨å­˜åˆ°å˜é‡bufferä¸­ã€‚æ˜¯çš„ï¼Œå°±æ˜¯è¿™ä¸ªå°å„¿ç§‘çš„æ“ä½œï¼ˆè¯·åŽŸè°…æˆ‘è¿™æ ·çš„è¯´æ³•ï¼‰ã€‚å¼ºå¼•ç”¨æœ€é‡è¦çš„å°±æ˜¯å®ƒèƒ½å¤Ÿè®©å¼•ç”¨å˜å¾—å¼ºï¼ˆStrongï¼‰ï¼Œè¿™å°±å†³å®šäº†å®ƒå’Œåžƒåœ¾å›žæ”¶å™¨çš„äº¤äº’ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æžœä¸€ä¸ªå¯¹è±¡é€šè¿‡ä¸€ä¸²å¼ºå¼•ç”¨é“¾æŽ¥å¯åˆ°è¾¾(Strongly reachable)ï¼Œå®ƒæ˜¯ä¸ä¼šè¢«å›žæ”¶çš„ã€‚å¦‚æžœä½ ä¸æƒ³è®©ä½ æ­£åœ¨ä½¿ç”¨çš„å¯¹è±¡è¢«å›žæ”¶ï¼Œè¿™å°±æ­£æ˜¯ä½ æ‰€éœ€è¦çš„ã€‚ ä½†æ˜¯å¼ºå¼•ç”¨å¦‚æ­¤ä¹‹å¼ºåœ¨ä¸€ä¸ªç¨‹åºé‡Œï¼Œå°†ä¸€ä¸ªç±»è®¾ç½®æˆä¸å¯è¢«æ‰©å±•æ˜¯æœ‰ç‚¹ä¸å¤ªå¸¸è§çš„ï¼Œå½“ç„¶è¿™ä¸ªå®Œå…¨å¯ä»¥é€šè¿‡ç±»æ ‡è®°æˆfinalå®žçŽ°ã€‚æˆ–è€…ä¹Ÿå¯ä»¥æ›´åŠ å¤æ‚ä¸€äº›ï¼Œå°±æ˜¯é€šè¿‡å†…éƒ¨åŒ…å«äº†æœªçŸ¥æ•°é‡å…·ä½“å®žçŽ°çš„å·¥åŽ‚æ–¹æ³•è¿”å›žä¸€ä¸ªæŽ¥å£(Interface)ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬æƒ³è¦ä½¿ç”¨ä¸€ä¸ªå«åšWidgetçš„ç±»ï¼Œä½†æ˜¯è¿™ä¸ªç±»ä¸èƒ½è¢«ç»§æ‰¿ï¼Œæ‰€ä»¥æ— æ³•å¢žåŠ æ–°çš„åŠŸèƒ½ã€‚ ä½†æ˜¯æˆ‘ä»¬å¦‚æžœæƒ³è¿½è¸ªWidgetå¯¹è±¡çš„é¢å¤–ä¿¡æ¯ï¼Œæˆ‘ä»¬è¯¥æ€Žä¹ˆåŠžï¼Ÿ å‡è®¾æˆ‘ä»¬éœ€è¦è®°å½•æ¯ä¸ªå¯¹è±¡çš„åºåˆ—å·ï¼Œä½†æ˜¯ç”±äºŽWidgetç±»å¹¶ä¸åŒ…å«è¿™ä¸ªå±žæ€§ï¼Œè€Œä¸”ä¹Ÿä¸èƒ½æ‰©å±•å¯¼è‡´æˆ‘ä»¬ä¹Ÿä¸èƒ½å¢žåŠ è¿™ä¸ªå±žæ€§ã€‚å…¶å®žä¸€ç‚¹é—®é¢˜ä¹Ÿæ²¡æœ‰ï¼ŒHashMapå®Œå…¨å¯ä»¥è§£å†³ä¸Šè¿°çš„é—®é¢˜ã€‚ serialNumberMap.put(widget, widgetSerialNumber); è¿™è¡¨é¢çœ‹ä¸ŠåŽ»æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯widgetå¯¹è±¡çš„å¼ºå¼•ç”¨å¾ˆæœ‰å¯èƒ½ä¼šå¼•å‘é—®é¢˜ã€‚æˆ‘ä»¬å¯ä»¥ç¡®ä¿¡å½“ä¸€ä¸ªwidgetåºåˆ—å·ä¸éœ€è¦æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥å°†è¿™ä¸ªæ¡ç›®ä»Žmapä¸­ç§»é™¤ã€‚å¦‚æžœæˆ‘ä»¬æ²¡æœ‰ç§»é™¤çš„è¯ï¼Œå¯èƒ½ä¼šå¯¼è‡´å†…å­˜æ³„éœ²ï¼Œäº¦æˆ–è€…æˆ‘ä»¬æ‰‹åŠ¨ç§»é™¤æ—¶åˆ é™¤äº†æˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„widgetsï¼Œä¼šå¯¼è‡´æœ‰æ•ˆæ•°æ®çš„ä¸¢å¤±ã€‚å…¶å®žè¿™äº›é—®é¢˜å¾ˆç±»ä¼¼ï¼Œè¿™å°±æ˜¯æ²¡æœ‰åžƒåœ¾å›žæ”¶æœºåˆ¶çš„è¯­è¨€ç®¡ç†å†…å­˜æ—¶å¸¸é‡åˆ°çš„é—®é¢˜ã€‚ä½†æ˜¯æˆ‘ä»¬ä¸ç”¨åŽ»æ‹…å¿ƒè¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ—¶å…·æœ‰åžƒåœ¾å›žæ”¶æœºåˆ¶çš„Javaè¯­è¨€ã€‚ å¦ä¸€ä¸ªå¼ºå¼•ç”¨å¯èƒ½å¸¦æ¥çš„é—®é¢˜å°±æ˜¯ç¼“å­˜,å°¤å…¶æ˜¯åƒå›¾ç‰‡è¿™æ ·çš„å¤§æ–‡ä»¶çš„ç¼“å­˜ã€‚å‡è®¾ä½ æœ‰ä¸€ä¸ªç¨‹åºéœ€è¦å¤„ç†ç”¨æˆ·æä¾›çš„å›¾ç‰‡ï¼Œé€šå¸¸çš„åšæ³•å°±æ˜¯åšå›¾ç‰‡æ•°æ®ç¼“å­˜ï¼Œå› ä¸ºä»Žç£ç›˜åŠ è½½å›¾ç‰‡ä»£ä»·å¾ˆå¤§ï¼Œå¹¶ä¸”åŒæ—¶æˆ‘ä»¬ä¹Ÿæƒ³é¿å…åœ¨å†…å­˜ä¸­åŒæ—¶å­˜åœ¨ä¸¤ä»½ä¸€æ ·çš„å›¾ç‰‡æ•°æ®ã€‚ ç¼“å­˜è¢«è®¾è®¡çš„ç›®çš„å°±æ˜¯é¿å…æˆ‘ä»¬åŽ»å†æ¬¡åŠ è½½å“ªäº›ä¸éœ€è¦çš„æ–‡ä»¶ã€‚ä½ ä¼šå¾ˆå¿«å‘çŽ°åœ¨ç¼“å­˜ä¸­ä¼šä¸€ç›´åŒ…å«ä¸€ä¸ªåˆ°å·²ç»æŒ‡å‘å†…å­˜ä¸­å›¾ç‰‡æ•°æ®çš„å¼•ç”¨ã€‚ä½¿ç”¨å¼ºå¼•ç”¨ä¼šå¼ºåˆ¶å›¾ç‰‡æ•°æ®ç•™åœ¨å†…å­˜ï¼Œè¿™å°±éœ€è¦ä½ æ¥å†³å®šä»€ä¹ˆæ—¶å€™å›¾ç‰‡æ•°æ®ä¸éœ€è¦å¹¶ä¸”æ‰‹åŠ¨ä»Žç¼“å­˜ä¸­ç§»é™¤ï¼Œè¿›è€Œå¯ä»¥è®©åžƒåœ¾å›žæ”¶å™¨å›žæ”¶ã€‚å› æ­¤ä½ å†ä¸€æ¬¡è¢«å¼ºåˆ¶åšåžƒåœ¾å›žæ”¶å™¨è¯¥åšçš„å·¥ä½œï¼Œå¹¶ä¸”äººä¸ºå†³å®šæ˜¯è¯¥æ¸…ç†åˆ°å“ªä¸€ä¸ªå¯¹è±¡ã€‚ å¼±å¼•ç”¨(Weak Reference)å¼±å¼•ç”¨ç®€å•æ¥è¯´å°±æ˜¯å°†å¯¹è±¡ç•™åœ¨å†…å­˜çš„èƒ½åŠ›ä¸æ˜¯é‚£ä¹ˆå¼ºçš„å¼•ç”¨ã€‚ä½¿ç”¨WeakReferenceï¼Œåžƒåœ¾å›žæ”¶å™¨ä¼šå¸®ä½ æ¥å†³å®šå¼•ç”¨çš„å¯¹è±¡ä½•æ—¶å›žæ”¶å¹¶ä¸”å°†å¯¹è±¡ä»Žå†…å­˜ç§»é™¤ã€‚åˆ›å»ºå¼±å¼•ç”¨å¦‚ä¸‹ WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget); ä½¿ç”¨weakWidget.get()å°±å¯ä»¥å¾—åˆ°çœŸå®žçš„Widgetå¯¹è±¡ï¼Œå› ä¸ºå¼±å¼•ç”¨ä¸èƒ½é˜»æŒ¡åžƒåœ¾å›žæ”¶å™¨å¯¹å…¶å›žæ”¶ï¼Œä½ ä¼šå‘çŽ°ï¼ˆå½“æ²¡æœ‰ä»»ä½•å¼ºå¼•ç”¨åˆ°widgetå¯¹è±¡æ—¶ï¼‰ä½¿ç”¨getæ—¶çªç„¶è¿”å›žnullã€‚ è§£å†³ä¸Šè¿°çš„widgetåºåˆ—æ•°è®°å½•çš„é—®é¢˜ï¼Œæœ€ç®€å•çš„åŠžæ³•å°±æ˜¯ä½¿ç”¨Javaå†…ç½®çš„WeakHashMapç±»ã€‚WeakHashMapå’ŒHashMapå‡ ä¹Žä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯å®ƒçš„é”®ï¼ˆä¸æ˜¯å€¼!!!ï¼‰ä½¿ç”¨WeakReferenceå¼•ç”¨ã€‚å½“WeakHashMapçš„é”®æ ‡è®°ä¸ºåžƒåœ¾çš„æ—¶å€™ï¼Œè¿™ä¸ªé”®å¯¹åº”çš„æ¡ç›®å°±ä¼šè‡ªåŠ¨è¢«ç§»é™¤ã€‚è¿™å°±é¿å…äº†ä¸Šé¢ä¸éœ€è¦çš„Widgetå¯¹è±¡æ‰‹åŠ¨åˆ é™¤çš„é—®é¢˜ã€‚ä½¿ç”¨WeakHashMapå¯ä»¥å¾ˆä¾¿æ·åœ°è½¬ä¸ºHashMapæˆ–è€…Mapã€‚ å¼•ç”¨é˜Ÿåˆ—(Reference Queue)ä¸€æ—¦å¼±å¼•ç”¨å¯¹è±¡å¼€å§‹è¿”å›žnullï¼Œè¯¥å¼±å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡å°±è¢«æ ‡è®°æˆäº†åžƒåœ¾ã€‚è€Œè¿™ä¸ªå¼±å¼•ç”¨å¯¹è±¡ï¼ˆéžå…¶æŒ‡å‘çš„å¯¹è±¡ï¼‰å°±æ²¡æœ‰ä»€ä¹ˆç”¨äº†ã€‚é€šå¸¸è¿™æ—¶å€™éœ€è¦è¿›è¡Œä¸€äº›æ¸…ç†å·¥ä½œã€‚æ¯”å¦‚WeakHashMapä¼šåœ¨è¿™æ—¶å€™ç§»é™¤æ²¡ç”¨çš„æ¡ç›®æ¥é¿å…ä¿å­˜æ— é™åˆ¶å¢žé•¿çš„æ²¡æœ‰æ„ä¹‰çš„å¼±å¼•ç”¨ã€‚ å¼•ç”¨é˜Ÿåˆ—å¯ä»¥å¾ˆå®¹æ˜“åœ°å®žçŽ°è·Ÿè¸ªä¸éœ€è¦çš„å¼•ç”¨ã€‚å½“ä½ åœ¨æž„é€ WeakReferenceæ—¶ä¼ å…¥ä¸€ä¸ªReferenceQueueå¯¹è±¡ï¼Œå½“è¯¥å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡è¢«æ ‡è®°ä¸ºåžƒåœ¾çš„æ—¶å€™ï¼Œè¿™ä¸ªå¼•ç”¨å¯¹è±¡ä¼šè‡ªåŠ¨åœ°åŠ å…¥åˆ°å¼•ç”¨é˜Ÿåˆ—é‡Œé¢ã€‚æŽ¥ä¸‹æ¥ï¼Œä½ å°±å¯ä»¥åœ¨å›ºå®šçš„å‘¨æœŸï¼Œå¤„ç†ä¼ å…¥çš„å¼•ç”¨é˜Ÿåˆ—ï¼Œæ¯”å¦‚åšä¸€äº›æ¸…ç†å·¥ä½œæ¥å¤„ç†è¿™äº›æ²¡æœ‰ç”¨çš„å¼•ç”¨å¯¹è±¡ã€‚ å››ç§å¼•ç”¨Javaä¸­å®žé™…ä¸Šæœ‰å››ç§å¼ºåº¦ä¸åŒçš„å¼•ç”¨ï¼Œä»Žå¼ºåˆ°å¼±å®ƒä»¬åˆ†åˆ«æ˜¯ï¼Œå¼ºå¼•ç”¨ï¼Œè½¯å¼•ç”¨ï¼Œå¼±å¼•ç”¨å’Œè™šå¼•ç”¨ã€‚ä¸Šé¢éƒ¨åˆ†ä»‹ç»äº†å¼ºå¼•ç”¨å’Œå¼±å¼•ç”¨ï¼Œä¸‹é¢ä»‹ç»å‰©ä¸‹çš„ä¸¤ä¸ªï¼Œè½¯å¼•ç”¨å’Œè™šå¼•ç”¨ã€‚ è½¯å¼•ç”¨ï¼ˆSoft Referenceï¼‰è½¯å¼•ç”¨åŸºæœ¬ä¸Šå’Œå¼±å¼•ç”¨å·®ä¸å¤šï¼Œåªæ˜¯ç›¸æ¯”å¼±å¼•ç”¨ï¼Œå®ƒé˜»æ­¢åžƒåœ¾å›žæ”¶æœŸå›žæ”¶å…¶æŒ‡å‘çš„å¯¹è±¡çš„èƒ½åŠ›å¼ºä¸€äº›ã€‚å¦‚æžœä¸€ä¸ªå¯¹è±¡æ˜¯å¼±å¼•ç”¨å¯åˆ°è¾¾ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡ä¼šè¢«åžƒåœ¾å›žæ”¶å™¨æŽ¥ä¸‹æ¥çš„å›žæ”¶å‘¨æœŸé”€æ¯ã€‚ä½†æ˜¯å¦‚æžœæ˜¯è½¯å¼•ç”¨å¯ä»¥åˆ°è¾¾ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡ä¼šåœç•™åœ¨å†…å­˜æ›´æ—¶é—´ä¸Šé•¿ä¸€äº›ã€‚å½“å†…å­˜ä¸è¶³æ—¶åžƒåœ¾å›žæ”¶å™¨æ‰ä¼šå›žæ”¶è¿™äº›è½¯å¼•ç”¨å¯åˆ°è¾¾çš„å¯¹è±¡ã€‚ ç”±äºŽè½¯å¼•ç”¨å¯åˆ°è¾¾çš„å¯¹è±¡æ¯”å¼±å¼•ç”¨å¯è¾¾åˆ°çš„å¯¹è±¡æ»žç•™å†…å­˜æ—¶é—´ä¼šé•¿ä¸€äº›ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ¥åšç¼“å­˜ã€‚è¿™æ ·çš„è¯ï¼Œä½ å°±å¯ä»¥èŠ‚çœäº†å¾ˆå¤šäº‹æƒ…ï¼Œåžƒåœ¾å›žæ”¶å™¨ä¼šå…³å¿ƒå½“å‰å“ªç§å¯åˆ°è¾¾ç±»åž‹ä»¥åŠå†…å­˜çš„æ¶ˆè€—ç¨‹åº¦æ¥è¿›è¡Œå¤„ç†ã€‚ è™šå¼•ç”¨ ï¼ˆPhantom Referenceï¼‰ä¸Žè½¯å¼•ç”¨ï¼Œå¼±å¼•ç”¨ä¸åŒï¼Œè™šå¼•ç”¨æŒ‡å‘çš„å¯¹è±¡ååˆ†è„†å¼±ï¼Œæˆ‘ä»¬ä¸å¯ä»¥é€šè¿‡getæ–¹æ³•æ¥å¾—åˆ°å…¶æŒ‡å‘çš„å¯¹è±¡ã€‚å®ƒçš„å”¯ä¸€ä½œç”¨å°±æ˜¯å½“å…¶æŒ‡å‘çš„å¯¹è±¡è¢«å›žæ”¶ä¹‹åŽï¼Œè‡ªå·±è¢«åŠ å…¥åˆ°å¼•ç”¨é˜Ÿåˆ—ï¼Œç”¨ä½œè®°å½•è¯¥å¼•ç”¨æŒ‡å‘çš„å¯¹è±¡å·²è¢«é”€æ¯ã€‚ å½“å¼±å¼•ç”¨çš„æŒ‡å‘å¯¹è±¡å˜å¾—å¼±å¼•ç”¨å¯åˆ°è¾¾ï¼Œè¯¥å¼±å¼•ç”¨å°±ä¼šåŠ å…¥åˆ°å¼•ç”¨é˜Ÿåˆ—ã€‚è¿™ä¸€æ“ä½œå‘ç”Ÿåœ¨å¯¹è±¡æžæž„æˆ–è€…åžƒåœ¾å›žæ”¶çœŸæ­£å‘ç”Ÿä¹‹å‰ã€‚ç†è®ºä¸Šï¼Œè¿™ä¸ªå³å°†è¢«å›žæ”¶çš„å¯¹è±¡æ˜¯å¯ä»¥åœ¨ä¸€ä¸ªä¸ç¬¦åˆè§„èŒƒçš„æžæž„æ–¹æ³•é‡Œé¢é‡æ–°å¤æ´»ã€‚ä½†æ˜¯è¿™ä¸ªå¼±å¼•ç”¨ä¼šé”€æ¯ã€‚è™šå¼•ç”¨åªæœ‰åœ¨å…¶æŒ‡å‘çš„å¯¹è±¡ä»Žå†…å­˜ä¸­ç§»é™¤æŽ‰ä¹‹åŽæ‰ä¼šåŠ å…¥åˆ°å¼•ç”¨é˜Ÿåˆ—ä¸­ã€‚å…¶getæ–¹æ³•ä¸€ç›´è¿”å›žnullå°±æ˜¯ä¸ºäº†é˜»æ­¢å…¶æŒ‡å‘çš„å‡ ä¹Žè¢«é”€æ¯çš„å¯¹è±¡é‡æ–°å¤æ´»ã€‚ è™šå¼•ç”¨ä½¿ç”¨åœºæ™¯ä¸»è¦ç”±ä¸¤ä¸ªã€‚å®ƒå…è®¸ä½ çŸ¥é“å…·ä½“ä½•æ—¶å…¶å¼•ç”¨çš„å¯¹è±¡ä»Žå†…å­˜ä¸­ç§»é™¤ã€‚è€Œå®žé™…ä¸Šè¿™æ˜¯Javaä¸­å”¯ä¸€çš„æ–¹å¼ã€‚è¿™ä¸€ç‚¹å°¤å…¶è¡¨çŽ°åœ¨å¤„ç†ç±»ä¼¼å›¾ç‰‡çš„å¤§æ–‡ä»¶çš„æƒ…å†µã€‚å½“ä½ ç¡®å®šä¸€ä¸ªå›¾ç‰‡æ•°æ®å¯¹è±¡åº”è¯¥è¢«å›žæ”¶ï¼Œä½ å¯ä»¥åˆ©ç”¨è™šå¼•ç”¨æ¥åˆ¤æ–­è¿™ä¸ªå¯¹è±¡å›žæ”¶ä¹‹åŽåœ¨ç»§ç»­åŠ è½½ä¸‹ä¸€å¼ å›¾ç‰‡ã€‚è¿™æ ·å¯ä»¥å°½å¯èƒ½åœ°é¿å…å¯æ€•çš„å†…å­˜æº¢å‡ºé”™è¯¯ã€‚ ç¬¬äºŒç‚¹ï¼Œè™šå¼•ç”¨å¯ä»¥é¿å…å¾ˆå¤šæžæž„æ—¶çš„é—®é¢˜ã€‚finalizeæ–¹æ³•å¯ä»¥é€šè¿‡åˆ›å»ºå¼ºå¼•ç”¨æŒ‡å‘å¿«è¢«é”€æ¯çš„å¯¹è±¡æ¥è®©è¿™äº›å¯¹è±¡é‡æ–°å¤æ´»ã€‚ç„¶è€Œï¼Œä¸€ä¸ªé‡å†™äº†finalizeæ–¹æ³•çš„å¯¹è±¡å¦‚æžœæƒ³è¦è¢«å›žæ”¶æŽ‰ï¼Œéœ€è¦ç»åŽ†ä¸¤ä¸ªå•ç‹¬çš„åžƒåœ¾æ”¶é›†å‘¨æœŸã€‚åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸä¸­ï¼ŒæŸä¸ªå¯¹è±¡è¢«æ ‡è®°ä¸ºå¯å›žæ”¶ï¼Œè¿›è€Œæ‰èƒ½è¿›è¡Œæžæž„ã€‚ä½†æ˜¯å› ä¸ºåœ¨æžæž„è¿‡ç¨‹ä¸­ä»æœ‰å¾®å¼±çš„å¯èƒ½è¿™ä¸ªå¯¹è±¡ä¼šé‡æ–°å¤æ´»ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œåœ¨è¿™ä¸ªå¯¹è±¡çœŸå®žé”€æ¯ä¹‹å‰ï¼Œåžƒåœ¾å›žæ”¶å™¨éœ€è¦å†æ¬¡è¿è¡Œã€‚å› ä¸ºæžæž„å¯èƒ½å¹¶ä¸æ˜¯å¾ˆåŠæ—¶ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨å¯¹è±¡çš„æžæž„ä¹‹å‰ï¼Œéœ€è¦ç»åŽ†æ•°é‡ä¸ç¡®å®šçš„åžƒåœ¾æ”¶é›†å‘¨æœŸã€‚è¿™å°±æ„å‘³ç€åœ¨çœŸæ­£æ¸…ç†æŽ‰è¿™ä¸ªå¯¹è±¡çš„æ—¶å€™å¯èƒ½å‘ç”Ÿå¾ˆå¤§çš„å»¶è¿Ÿã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå½“å¤§éƒ¨åˆ†å †è¢«æ ‡è®°æˆåžƒåœ¾æ—¶è¿˜æ˜¯ä¼šå‡ºçŽ°çƒ¦äººçš„å†…å­˜æº¢å‡ºé”™è¯¯ã€‚ ä½¿ç”¨è™šå¼•ç”¨ï¼Œä¸Šè¿°æƒ…å†µå°†å¼•åˆƒè€Œè§£ï¼Œå½“ä¸€ä¸ªè™šå¼•ç”¨åŠ å…¥åˆ°å¼•ç”¨é˜Ÿåˆ—æ—¶ï¼Œä½ ç»å¯¹æ²¡æœ‰åŠžæ³•å¾—åˆ°ä¸€ä¸ªé”€æ¯äº†çš„å¯¹è±¡ã€‚å› ä¸ºè¿™æ—¶å€™ï¼Œå¯¹è±¡å·²ç»ä»Žå†…å­˜ä¸­é”€æ¯äº†ã€‚å› ä¸ºè™šå¼•ç”¨ä¸èƒ½è¢«ç”¨ä½œè®©å…¶æŒ‡å‘çš„å¯¹è±¡é‡ç”Ÿï¼Œæ‰€ä»¥å…¶å¯¹è±¡ä¼šåœ¨åžƒåœ¾å›žæ”¶çš„ç¬¬ä¸€ä¸ªå‘¨æœŸå°±å°†è¢«æ¸…ç†æŽ‰ã€‚ æ˜¾è€Œæ˜“è§ï¼Œfinalizeæ–¹æ³•ä¸å»ºè®®è¢«é‡å†™ã€‚å› ä¸ºè™šå¼•ç”¨æ˜Žæ˜¾åœ°å®‰å…¨é«˜æ•ˆï¼ŒåŽ»æŽ‰finalizeæ–¹æ³•å¯ä»¥è™šæ‹Ÿæœºå˜å¾—æ˜Žæ˜¾ç®€å•ã€‚å½“ç„¶ä½ ä¹Ÿå¯ä»¥åŽ»é‡å†™è¿™ä¸ªæ–¹æ³•æ¥å®žçŽ°æ›´å¤šã€‚è¿™å®Œå…¨çœ‹ä¸ªäººé€‰æ‹©ã€‚]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaè®¾è®¡æ¨¡å¼è‡ªæˆ‘æ€»ç»“-1]]></title>
    <url>%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[çœ‹äº†ä¸€éƒ¨åˆ†è®¾è®¡æ¨¡å¼ï¼Œè‡ªå·±éƒ½ç”¨ä¸€å¥è¯æ€»ç»“äº†ä¸‹ï¼š å•ä¾‹æ¨¡å¼Singletonç±»å†…å®šä¹‰ç§æœ‰çš„æž„é€ æ–¹æ³•ï¼Œå¹¶å®žä¾‹åŒ–ä¸€ä¸ªé™æ€çš„Singletonå¯¹è±¡ï¼ˆå…¨å±€åªæœ‰ä¸€ä¸ªï¼‰ï¼ŒäºŽæ˜¯å¤–éƒ¨åªèƒ½è°ƒç”¨ä½ å°è£…çš„getSingletonæ–¹æ³•å–å¾—Singletonå®žä¾‹ å·¥åŽ‚æ¨¡å¼æ˜¯è®¾ç½®ä¸€ä¸ªè¿‡æ¸¡ç«¯ï¼ˆå³å·¥åŽ‚ç±»ï¼‰ç”¨ä»¥å–å¾—æŽ¥å£å¯¹åº”çš„å­ç±»ç±»åž‹å¹¶å®žä¾‹åŒ–ï¼Œç„¶åŽå›žä¼ æŽ¥å£çš„å¼•ç”¨åˆ°å®¢æˆ·ç«¯ï¼ˆè°ƒç”¨å¤„ï¼Œå¦‚ä¸»æ–¹æ³•ï¼‰ ä»£ç†æ¨¡å¼å°±æ˜¯å°†çœŸå®žç±»ä½œä¸ºå±žæ€§æ³¨å…¥åˆ°ä»£ç†ç±»ï¼Œç„¶åŽå…ˆè°ƒç”¨ä»£ç†ç±»çš„å…¶ä»–ä¸šåŠ¡æ“ä½œå†è°ƒç”¨çœŸå®žç±»çš„ä¸šåŠ¡ é€‚é…å™¨æ¨¡å¼ä¸»è¦ç”¨äºŽå­ç±»åªéœ€è¦å®žçŽ°æŽ¥å£çš„ä¸€éƒ¨åˆ†æ–¹æ³•ï¼Œæ­¤æ—¶è®¾å®šä¸€ä¸ªé€‚é…å™¨æŠ½è±¡ç±»å®žçŽ°è‹¥å¹²æˆ–è€…æ‰€æœ‰æŠ½è±¡æ–¹æ³•ï¼ˆæ–¹æ³•ä½“ä¸ºç©ºå³å¯ï¼‰æ¥è¿‡æ¸¡ï¼Œç„¶åŽå­ç±»æœ‰é€‰æ‹©çš„å®žçŽ°ä¸€éƒ¨åˆ†é€‚é…å™¨ç±»çš„æ–¹æ³•å³å¯]]></content>
      <categories>
        <category>è®¾è®¡æ¨¡å¼</category>
      </categories>
      <tags>
        <tag>è®¾è®¡æ¨¡å¼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springå››ç§ä¾èµ–æ³¨å…¥æ–¹å¼]]></title>
    <url>%2Fspring-1%2F</url>
    <content type="text"><![CDATA[springå››ç§ä¾èµ–æ³¨å…¥æ–¹å¼â€‹ â€‹ å¹³å¸¸çš„javaå¼€å‘ä¸­ï¼Œç¨‹åºå‘˜åœ¨æŸä¸ªç±»ä¸­éœ€è¦ä¾èµ–å…¶å®ƒç±»çš„æ–¹æ³•ï¼Œåˆ™é€šå¸¸æ˜¯newä¸€ä¸ªä¾èµ–ç±»å†è°ƒç”¨ç±»å®žä¾‹çš„æ–¹æ³•ï¼Œè¿™ç§å¼€å‘å­˜åœ¨çš„é—®é¢˜æ˜¯newçš„ç±»å®žä¾‹ä¸å¥½ç»Ÿä¸€ç®¡ç†ï¼Œspringæå‡ºäº†ä¾èµ–æ³¨å…¥çš„æ€æƒ³ï¼Œå³ä¾èµ–ç±»ä¸ç”±ç¨‹åºå‘˜å®žä¾‹åŒ–ï¼Œè€Œæ˜¯é€šè¿‡springå®¹å™¨å¸®æˆ‘ä»¬newæŒ‡å®šå®žä¾‹å¹¶ä¸”å°†å®žä¾‹æ³¨å…¥åˆ°éœ€è¦è¯¥å¯¹è±¡çš„ç±»ä¸­ã€‚ä¾èµ–æ³¨å…¥çš„å¦ä¸€ç§è¯´æ³•æ˜¯â€œæŽ§åˆ¶åè½¬â€ï¼Œé€šä¿—çš„ç†è§£æ˜¯ï¼šå¹³å¸¸æˆ‘ä»¬newä¸€ä¸ªå®žä¾‹ï¼Œè¿™ä¸ªå®žä¾‹çš„æŽ§åˆ¶æƒæ˜¯æˆ‘ä»¬ç¨‹åºå‘˜ï¼Œè€ŒæŽ§åˆ¶åè½¬æ˜¯æŒ‡newå®žä¾‹å·¥ä½œä¸ç”±æˆ‘ä»¬ç¨‹åºå‘˜æ¥åšè€Œæ˜¯äº¤ç»™springå®¹å™¨æ¥åšã€‚ â€‹ springæœ‰å¤šç§ä¾èµ–æ³¨å…¥çš„å½¢å¼ï¼Œä¸‹é¢ä»…ä»‹ç»springé€šè¿‡xmlè¿›è¡ŒIOCé…ç½®çš„æ–¹å¼ï¼š setæ–¹æ³•æ³¨å…¥â€‹ è¿™æ˜¯æœ€ç®€å•çš„æ³¨å…¥æ–¹å¼ï¼Œå‡è®¾æœ‰ä¸€ä¸ªSpringActionï¼Œç±»ä¸­éœ€è¦å®žä¾‹åŒ–ä¸€ä¸ªSpringDaoå¯¹è±¡ï¼Œé‚£ä¹ˆå°±å¯ä»¥å®šä¹‰ä¸€ä¸ªprivateçš„SpringDaoæˆå‘˜å˜é‡ï¼Œç„¶åŽåˆ›å»ºSpringDaoçš„setæ–¹æ³•ï¼ˆè¿™æ˜¯iocçš„æ³¨å…¥å…¥å£ï¼‰ï¼š 12345678910111213package com.bless.springdemo.action;public class SpringAction &#123; //æ³¨å…¥å¯¹è±¡springDao private SpringDao springDao; //ä¸€å®šè¦å†™è¢«æ³¨å…¥å¯¹è±¡çš„setæ–¹æ³• public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125;&#125; â€‹ éšåŽç¼–å†™springçš„xmlæ–‡ä»¶ï¼Œä¸­çš„nameå±žæ€§æ˜¯classå±žæ€§çš„ä¸€ä¸ªåˆ«åï¼Œclasså±žæ€§æŒ‡ç±»çš„å…¨åï¼Œå› ä¸ºåœ¨SpringActionä¸­æœ‰ä¸€ä¸ªå…¬å…±å±žæ€§Springdaoï¼Œæ‰€ä»¥è¦åœ¨æ ‡ç­¾ä¸­åˆ›å»ºä¸€ä¸ªæ ‡ç­¾æŒ‡å®šSpringDaoã€‚æ ‡ç­¾ä¸­çš„nameå°±æ˜¯SpringActionç±»ä¸­çš„SpringDaoå±žæ€§åï¼ŒrefæŒ‡ä¸‹é¢ï¼Œè¿™æ ·å…¶å®žæ˜¯springå°†SpringDaoImplå¯¹è±¡å®žä¾‹åŒ–å¹¶ä¸”è°ƒç”¨SpringActionçš„setSpringDaoæ–¹æ³•å°†SpringDaoæ³¨å…¥ï¼š 1234567&lt;!--é…ç½®bean,é…ç½®åŽè¯¥ç±»ç”±springç®¡ç†--&gt;&lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(1)ä¾èµ–æ³¨å…¥,é…ç½®å½“å‰ç±»ä¸­ç›¸åº”çš„å±žæ€§--&gt; &lt;property name="springDao" ref="springDao"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="springDao" class="com.bless.springdemo.dao.impl.SpringDaoImpl"&gt;&lt;/bean&gt; æž„é€ å™¨æ³¨å…¥â€‹ è¿™ç§æ–¹å¼çš„æ³¨å…¥æ˜¯æŒ‡å¸¦æœ‰å‚æ•°çš„æž„é€ å‡½æ•°æ³¨å…¥ï¼Œçœ‹ä¸‹é¢çš„ä¾‹å­ï¼Œæˆ‘åˆ›å»ºäº†ä¸¤ä¸ªæˆå‘˜å˜é‡SpringDaoå’ŒUserï¼Œä½†æ˜¯å¹¶æœªè®¾ç½®å¯¹è±¡çš„setæ–¹æ³•ï¼Œæ‰€ä»¥å°±ä¸èƒ½æ”¯æŒç¬¬ä¸€ç§æ³¨å…¥æ–¹å¼ï¼Œè¿™é‡Œçš„æ³¨å…¥æ–¹å¼æ˜¯åœ¨SpringActionçš„æž„é€ å‡½æ•°ä¸­æ³¨å…¥ï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨åˆ›å»ºSpringActionå¯¹è±¡æ—¶è¦å°†SpringDaoå’ŒUserä¸¤ä¸ªå‚æ•°å€¼ä¼ è¿›æ¥ï¼š 12345678910111213141516public class SpringAction &#123; //æ³¨å…¥å¯¹è±¡springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println("æž„é€ æ–¹æ³•è°ƒç”¨springDaoå’Œuser"); &#125; public void save()&#123; user.setName("å¡å¡"); springDao.save(user); &#125;&#125; åœ¨XMLæ–‡ä»¶ä¸­åŒæ ·ä¸ç”¨çš„å½¢å¼ï¼Œè€Œæ˜¯ä½¿ç”¨æ ‡ç­¾ï¼Œrefå±žæ€§åŒæ ·æŒ‡å‘å…¶å®ƒæ ‡ç­¾çš„nameå±žæ€§ï¼š 12345678&lt;!--é…ç½®bean,é…ç½®åŽè¯¥ç±»ç”±springç®¡ç†--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(2)åˆ›å»ºæž„é€ å™¨æ³¨å…¥,å¦‚æžœä¸»ç±»æœ‰å¸¦å‚çš„æž„é€ æ–¹æ³•åˆ™éœ€æ·»åŠ æ­¤é…ç½®--&gt; &lt;constructor-arg ref="springDao"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref="user"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name="springDao" class="com.bless.springdemo.dao.impl.SpringDaoImpl"&gt;&lt;/bean&gt; &lt;bean name="user" class="com.bless.springdemo.vo.User"&gt;&lt;/bean&gt; â€‹ è§£å†³æž„é€ æ–¹æ³•å‚æ•°çš„ä¸ç¡®å®šæ€§ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°æž„é€ æ–¹æ³•ä¼ å…¥çš„ä¸¤å‚æ•°éƒ½æ˜¯åŒç±»åž‹çš„ï¼Œä¸ºäº†åˆ†æ¸…å“ªä¸ªè¯¥èµ‹å¯¹åº”å€¼ï¼Œåˆ™éœ€è¦è¿›è¡Œä¸€äº›å°å¤„ç†ï¼š â€‹ ä¸‹é¢æ˜¯è®¾ç½®indexï¼Œå°±æ˜¯å‚æ•°ä½ç½®ï¼š 1234&lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;constructor-arg index="0" ref="springDao"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" ref="user"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; å¦ä¸€ç§æ˜¯è®¾ç½®å‚æ•°ç±»åž‹ï¼š 1&lt;constructor-arg type="java.lang.String" ref=""/&gt; é™æ€å·¥åŽ‚æž„é€ â€‹ é™æ€å·¥åŽ‚é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯é€šè¿‡è°ƒç”¨é™æ€å·¥åŽ‚çš„æ–¹æ³•æ¥èŽ·å–è‡ªå·±éœ€è¦çš„å¯¹è±¡ï¼Œä¸ºäº†è®©springç®¡ç†æ‰€æœ‰å¯¹è±¡ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æŽ¥é€šè¿‡â€å·¥ç¨‹ç±».é™æ€æ–¹æ³•()â€æ¥èŽ·å–å¯¹è±¡ï¼Œè€Œæ˜¯ä¾ç„¶é€šè¿‡springæ³¨å…¥çš„å½¢å¼èŽ·å–ï¼š 123456789101112package com.bless.springdemo.factory;import com.bless.springdemo.dao.FactoryDao;import com.bless.springdemo.dao.impl.FactoryDaoImpl;import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;public class DaoFactory &#123; //é™æ€å·¥åŽ‚ public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125; â€‹ åŒæ ·çœ‹å…³é”®ç±»ï¼Œè¿™é‡Œæˆ‘éœ€è¦æ³¨å…¥ä¸€ä¸ªFactoryDaoå¯¹è±¡ï¼Œè¿™é‡Œçœ‹èµ·æ¥è·Ÿç¬¬ä¸€ç§æ³¨å…¥ä¸€æ¨¡ä¸€æ ·ï¼Œä½†æ˜¯çœ‹éšåŽçš„xmlä¼šå‘çŽ°æœ‰å¾ˆå¤§å·®åˆ«: 123456789101112 public class SpringAction &#123; //æ³¨å…¥å¯¹è±¡ private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //æ³¨å…¥å¯¹è±¡çš„setæ–¹æ³• public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125; â€‹ Springçš„IOCé…ç½®æ–‡ä»¶ï¼Œæ³¨æ„çœ‹æŒ‡å‘çš„classå¹¶ä¸æ˜¯FactoryDaoçš„å®žçŽ°ç±»ï¼Œè€Œæ˜¯æŒ‡å‘é™æ€å·¥åŽ‚DaoFactoryï¼Œå¹¶ä¸”é…ç½® factory-method=â€getStaticFactoryDaoImplâ€æŒ‡å®šè°ƒç”¨å“ªä¸ªå·¥åŽ‚æ–¹æ³•ï¼š 12345678&lt;!--é…ç½®bean,é…ç½®åŽè¯¥ç±»ç”±springç®¡ç†--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction" &gt; &lt;!--(3)ä½¿ç”¨é™æ€å·¥åŽ‚çš„æ–¹æ³•æ³¨å…¥å¯¹è±¡,å¯¹åº”ä¸‹é¢çš„é…ç½®æ–‡ä»¶(3)--&gt; &lt;property name="staticFactoryDao" ref="staticFactoryDao"&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)æ­¤å¤„èŽ·å–å¯¹è±¡çš„æ–¹å¼æ˜¯ä»Žå·¥åŽ‚ç±»ä¸­èŽ·å–é™æ€æ–¹æ³•--&gt; &lt;bean name="staticFactoryDao" class="com.bless.springdemo.factory.DaoFactory" factory-method="getStaticFactoryDaoImpl"&gt;&lt;/bean&gt; å®žä¾‹å·¥åŽ‚æž„é€ â€‹ å®žä¾‹å·¥åŽ‚çš„æ„æ€æ˜¯èŽ·å–å¯¹è±¡å®žä¾‹çš„æ–¹æ³•ä¸æ˜¯é™æ€çš„ï¼Œæ‰€ä»¥ä½ éœ€è¦é¦–å…ˆnewå·¥åŽ‚ç±»ï¼Œå†è°ƒç”¨æ™®é€šçš„å®žä¾‹æ–¹æ³•ï¼š 123456public class DaoFactory &#123; //å®žä¾‹å·¥åŽ‚ public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125; â€‹ é‚£ä¹ˆä¸‹é¢è¿™ä¸ªç±»æ²¡ä»€ä¹ˆè¯´çš„ï¼Œè·Ÿå‰é¢ä¹Ÿå¾ˆç›¸ä¼¼ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦é€šè¿‡å®žä¾‹å·¥åŽ‚ç±»åˆ›å»ºFactoryDaoå¯¹è±¡ï¼š 123456789101112public class SpringAction &#123; //æ³¨å…¥å¯¹è±¡ private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125; æœ€åŽçœ‹springé…ç½®æ–‡ä»¶ 123456789&lt;!--é…ç½®bean,é…ç½®åŽè¯¥ç±»ç”±springç®¡ç†--&gt; &lt;bean name="springAction" class="com.bless.springdemo.action.SpringAction"&gt; &lt;!--(4)ä½¿ç”¨å®žä¾‹å·¥åŽ‚çš„æ–¹æ³•æ³¨å…¥å¯¹è±¡,å¯¹åº”ä¸‹é¢çš„é…ç½®æ–‡ä»¶(4)--&gt; &lt;property name="factoryDao" ref="factoryDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)æ­¤å¤„èŽ·å–å¯¹è±¡çš„æ–¹å¼æ˜¯ä»Žå·¥åŽ‚ç±»ä¸­èŽ·å–å®žä¾‹æ–¹æ³•--&gt; &lt;bean name="daoFactory" class="com.bless.springdemo.factory.DaoFactory"&gt;&lt;/bean&gt; &lt;bean name="factoryDao" factory-bean="daoFactory" factory-method="getFactoryDaoImpl"&gt;&lt;/bean&gt; æ€»ç»“â€‹ Spring IOCæ³¨å…¥æ–¹å¼ç”¨å¾—æœ€å¤šçš„æ˜¯(1)(2)ç§ï¼Œå¤šå†™å¤šç»ƒå°±ä¼šéžå¸¸ç†Ÿç»ƒã€‚ â€‹ å¦å¤–æ³¨æ„ï¼šé€šè¿‡Springåˆ›å»ºçš„å¯¹è±¡é»˜è®¤æ˜¯å•ä¾‹çš„ï¼Œå¦‚æžœéœ€è¦åˆ›å»ºå¤šå®žä¾‹å¯¹è±¡å¯ä»¥åœ¨æ ‡ç­¾åŽé¢æ·»åŠ ä¸€ä¸ªå±žæ€§ï¼š 1&lt;bean name="..." class="..." scope="prototype"&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javaè¿è¡Œæ—¶å¤šæ€æ€§ï¼šç»§æ‰¿å’ŒæŽ¥å£çš„å®žçŽ°]]></title>
    <url>%2Fduotai-1%2F</url>
    <content type="text"><![CDATA[å…ˆæ’ä¸€å¥é¢˜å¤–è¯ï¼š ç»§æ‰¿ä¸Žå¤šæ€çš„åŒºåˆ« â€‹ ç»§æ‰¿ï¼Œå­ç±»ç»§æ‰¿çˆ¶ç±»ä¸­æ‰€ä»¥çš„å±žæ€§å’Œæ–¹æ³•ï¼Œä½†æ˜¯å¯¹äºŽprivateçš„å±žç›¸å’Œæ–¹æ³•ï¼Œç”±äºŽè¿™ä¸ªæ˜¯çˆ¶ç±»çš„éšç§ï¼Œæ‰€ä»¥å­ç±»è™½ç„¶æ˜¯ç»§æ‰¿äº†ï¼Œä½†æ˜¯æ²¡æœ‰å¯ä»¥è®¿é—®è¿™äº›å±žæ€§å’Œæ–¹æ³•çš„å¼•ç”¨ï¼Œæ‰€ä»¥ç›¸å½“äºŽæ²¡æœ‰ç»§æ‰¿åˆ°ã€‚å¾ˆå¤šæ—¶å€™ï¼Œå¯ä»¥ç†è§£ä¸ºï¼Œæ²¡æœ‰ç»§æ‰¿ã€‚ â€‹ å¤šæ€ï¼šå°±æ˜¯çˆ¶ç±»å¼•ç”¨å¯ä»¥æŒæœ‰å­ç±»å¯¹è±¡ã€‚è¿™æ—¶å€™åªèƒ½è°ƒç”¨çˆ¶ç±»ä¸­çš„æ–¹æ³•ï¼Œè€Œå­ç±»ä¸­ç‰¹æœ‰æ–¹æ³•æ˜¯æ— æ³•è®¿é—®çš„ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™ï¼ˆç¼–è¯‘æ—¶ï¼‰ä½ æŠŠä»–çœ‹ä½œçˆ¶ç±»å¯¹è±¡çš„åŽŸå› ï¼Œä½†æ˜¯åˆ°äº†è¿è¡Œçš„æ—¶å€™ï¼Œç¼–è¯‘å™¨å°±ä¼šå‘çŽ°è¿™ä¸ªçˆ¶ç±»å¼•ç”¨ä¸­åŽŸæ¥æ˜¯ä¸€ä¸ªå­ç±»çš„å¯¹åƒï¼Œæ‰€ä»¥å¦‚æžœçˆ¶ç±»å’Œå­ç±»ä¸­æœ‰ç›¸åŒçš„æ–¹æ³•æ—¶ï¼Œè°ƒç”¨çš„ä¼šæ˜¯å­ç±»ä¸­çš„æ–¹æ³•ï¼Œè€Œä¸æ˜¯çˆ¶ç±»çš„ã€‚å¯ä»¥è¿™ä¹ˆè¯´ï¼šç¼–è¯‘æ—¶çœ‹çˆ¶ç±»ï¼Œè¿è¡Œæ—¶çœ‹å­ç±»ã€‚ è¿›å…¥æ­£é¢˜ï¼š Javaè¿è¡Œæ—¶å¤šæ€æ€§ï¼šç»§æ‰¿å’ŒæŽ¥å£çš„å®žçŽ°Javaæ˜¯é¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œè€Œè¿è¡Œæ—¶å¤šæ€æ€§æ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡ä»£ç é‡ç”¨çš„ä¸€ä¸ªæœ€å¼ºå¤§æœºåˆ¶ï¼ŒåŠ¨æ€æ€§çš„æ¦‚å¿µä¹Ÿå¯ä»¥è¢«è¯´æˆâ€œä¸€ä¸ªæŽ¥å£ï¼Œå¤šä¸ªæ–¹æ³•â€ã€‚Javaå®žçŽ°è¿è¡Œæ—¶å¤šæ€æ€§çš„åŸºç¡€æ˜¯åŠ¨æ€æ–¹æ³•è°ƒåº¦ï¼Œå®ƒæ˜¯ä¸€ç§åœ¨è¿è¡Œæ—¶è€Œä¸æ˜¯åœ¨ç¼–è¯‘æœŸè°ƒç”¨é‡è½½æ–¹æ³•çš„æœºåˆ¶ï¼Œä¸‹é¢å°±ç»§æ‰¿å’ŒæŽ¥å£å®žçŽ°ä¸¤æ–¹é¢è°ˆè°ˆjavaè¿è¡Œæ—¶å¤šæ€æ€§çš„å®žçŽ°ã€‚ ä¸€ã€é€šè¿‡ç»§æ‰¿ä¸­è¶…ç±»å¯¹è±¡å¼•ç”¨å˜é‡å¼•ç”¨å­ç±»å¯¹è±¡æ¥å®žçŽ°ä¸¾ä¾‹è¯´æ˜Žï¼š 12345678910111213141516171819202122232425262728293031323334353637383940//å®šä¹‰è¶…ç±»superA class superA &#123; int i = 100; void fun() &#123; System.out.println(â€œThis is superAâ€); &#125;&#125;//å®šä¹‰superAçš„å­ç±»subB class subB extends superA &#123; int m = 1; void fun() &#123; System.out.println(â€œThis is subBâ€); &#125;&#125;//å®šä¹‰superAçš„å­ç±»subC class subC extends superA &#123; int n = 1; void fun() &#123; System.out.println(â€œThis is subCâ€); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; superA a; subB b = new subB(); subC c = new subC(); a = b; a.fun(); (1) a = c; a.fun(); (2) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940 è¿è¡Œç»“æžœä¸ºï¼š 123This is subBThis is subC123 ä¸Šè¿°ä»£ç ä¸­subBå’ŒsubCæ˜¯è¶…ç±»superAçš„å­ç±»ï¼Œæˆ‘ä»¬åœ¨ç±»Testä¸­å£°æ˜Žäº†3ä¸ªå¼•ç”¨å˜é‡a, b, cï¼Œé€šè¿‡å°†å­ç±»å¯¹è±¡å¼•ç”¨èµ‹å€¼ç»™è¶…ç±»å¯¹è±¡å¼•ç”¨å˜é‡æ¥å®žçŽ°åŠ¨æ€æ–¹æ³•è°ƒç”¨ã€‚ä¹Ÿè®¸æœ‰äººä¼šé—®ï¼šâ€œä¸ºä»€ä¹ˆ(1)å’Œ(2)ä¸è¾“å‡ºï¼šThis is superAâ€ã€‚java çš„è¿™ç§æœºåˆ¶éµå¾ªä¸€ä¸ªåŽŸåˆ™ï¼šå½“è¶…ç±»å¯¹è±¡å¼•ç”¨å˜é‡å¼•ç”¨å­ç±»å¯¹è±¡æ—¶ï¼Œè¢«å¼•ç”¨å¯¹è±¡çš„ç±»åž‹è€Œä¸æ˜¯å¼•ç”¨å˜é‡çš„ç±»åž‹å†³å®šäº†è°ƒç”¨è°çš„æˆå‘˜æ–¹æ³•ï¼Œä½†æ˜¯è¿™ä¸ªè¢«è°ƒç”¨çš„æ–¹æ³•å¿…é¡»æ˜¯åœ¨è¶…ç±»ä¸­å®šä¹‰è¿‡çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¢«å­ç±»è¦†ç›–çš„æ–¹æ³•ã€‚ æ‰€ä»¥ï¼Œä¸è¦è¢«ä¸Šä¾‹ä¸­(1)å’Œ(2)æ‰€è¿·æƒ‘ï¼Œè™½ç„¶å†™æˆa.fun()ï¼Œä½†æ˜¯ç”±äºŽ(1)ä¸­çš„aè¢«bèµ‹å€¼ï¼ŒæŒ‡å‘äº†å­ç±»subBçš„ä¸€ä¸ªå®žä¾‹ï¼Œå› è€Œ(1)æ‰€è°ƒç”¨çš„fun()å®žé™…ä¸Šæ˜¯å­ç±»subBçš„æˆå‘˜æ–¹æ³•fun()ï¼Œå®ƒè¦†ç›–äº†è¶…ç±»superAçš„æˆå‘˜æ–¹æ³•fun()ï¼›åŒæ ·(2)è°ƒç”¨çš„æ˜¯å­ç±»subCçš„æˆå‘˜æ–¹æ³•fun()ã€‚ å¦å¤–ï¼Œå¦‚æžœå­ç±»ç»§æ‰¿çš„è¶…ç±»æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œè™½ç„¶æŠ½è±¡ç±»ä¸èƒ½é€šè¿‡newæ“ä½œç¬¦å®žä¾‹åŒ–ï¼Œä½†æ˜¯å¯ä»¥åˆ›å»ºæŠ½è±¡ç±»çš„å¯¹è±¡å¼•ç”¨æŒ‡å‘å­ç±»å¯¹è±¡ï¼Œä»¥å®žçŽ°è¿è¡Œæ—¶å¤šæ€æ€§ã€‚å…·ä½“çš„å®žçŽ°æ–¹æ³•åŒä¸Šä¾‹ã€‚ ä¸è¿‡ï¼ŒæŠ½è±¡ç±»çš„å­ç±»å¿…é¡»è¦†ç›–å®žçŽ°è¶…ç±»ä¸­çš„æ‰€æœ‰çš„æŠ½è±¡æ–¹æ³•ï¼Œå¦åˆ™å­ç±»å¿…é¡»è¢«abstractä¿®é¥°ç¬¦ä¿®é¥°ï¼Œå½“ç„¶ä¹Ÿå°±ä¸èƒ½è¢«å®žä¾‹åŒ–äº†ã€‚ äºŒã€é€šè¿‡æŽ¥å£ç±»åž‹å˜é‡å¼•ç”¨å®žçŽ°æŽ¥å£çš„ç±»çš„å¯¹è±¡æ¥å®žçŽ°æŽ¥å£çš„çµæ´»æ€§å°±åœ¨äºŽâ€œè§„å®šä¸€ä¸ªç±»å¿…é¡»åšä»€ä¹ˆï¼Œè€Œä¸ç®¡ä½ å¦‚ä½•åšâ€ã€‚æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæŽ¥å£ç±»åž‹çš„å¼•ç”¨å˜é‡æ¥å¼•ç”¨å®žçŽ°æŽ¥å£çš„ç±»çš„å®žä¾‹ï¼Œå½“è¿™ä¸ªå¼•ç”¨è°ƒç”¨æ–¹æ³•æ—¶ï¼Œå®ƒä¼šæ ¹æ®å®žé™…å¼•ç”¨çš„ç±»çš„å®žä¾‹æ¥åˆ¤æ–­å…·ä½“è°ƒç”¨å“ªä¸ªæ–¹æ³•ï¼Œè¿™å’Œä¸Šè¿°çš„è¶…ç±»å¯¹è±¡å¼•ç”¨è®¿é—®å­ç±»å¯¹è±¡çš„æœºåˆ¶ç›¸ä¼¼ã€‚ ä¸¾ä¾‹è¯´æ˜Žï¼š 1234567891011121314151617181920212223242526272829303132//å®šä¹‰æŽ¥å£InterA interface InterA&#123; void fun();&#125;//å®žçŽ°æŽ¥å£InterAçš„ç±»B class B implements InterA&#123; public void fun() &#123; System.out.println(â€œThis is Bâ€); &#125;&#125;//å®žçŽ°æŽ¥å£InterAçš„ç±»C class C implements InterA&#123; public void fun() &#123; System.out.println(â€œThis is Câ€); &#125;&#125;class Test&#123; public static void main(String[] args) &#123; InterA a; a= new B(); a.fun(); a = new C(); a.fun(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132 è¾“å‡ºç»“æžœä¸ºï¼š 123This is BThis is C123 ä¸Šä¾‹ä¸­ç±»Bå’Œç±»Cæ˜¯å®žçŽ°æŽ¥å£InterAçš„ä¸¤ä¸ªç±»ï¼Œåˆ†åˆ«å®žçŽ°äº†æŽ¥å£çš„æ–¹æ³•fun()ï¼Œé€šè¿‡å°†ç±»Bå’Œç±»Cçš„å®žä¾‹èµ‹ç»™æŽ¥å£å¼•ç”¨aè€Œå®žçŽ°äº†æ–¹æ³•åœ¨è¿è¡Œæ—¶çš„åŠ¨æ€ç»‘å®šï¼Œå……åˆ†åˆ©ç”¨äº†â€œä¸€ä¸ªæŽ¥å£ï¼Œå¤šä¸ªæ–¹æ³•â€å±•ç¤ºäº†Javaçš„åŠ¨æ€å¤šæ€æ€§ã€‚ éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼šJavaåœ¨åˆ©ç”¨æŽ¥å£å˜é‡è°ƒç”¨å…¶å®žçŽ°ç±»çš„å¯¹è±¡çš„æ–¹æ³•æ—¶ï¼Œè¯¥æ–¹æ³•å¿…é¡»å·²ç»åœ¨æŽ¥å£ä¸­è¢«å£°æ˜Žï¼Œè€Œä¸”åœ¨æŽ¥å£çš„å®žçŽ°ç±»ä¸­è¯¥å®žçŽ°æ–¹æ³•çš„ç±»åž‹å’Œå‚æ•°å¿…é¡»ä¸ŽæŽ¥å£ä¸­æ‰€å®šä¹‰çš„ç²¾ç¡®åŒ¹é…ã€‚ ç»“æŸè¯­ï¼šä»¥ä¸Šå°±æ˜¯javaè¿è¡Œæ—¶å¤šæ€æ€§çš„å®žçŽ°æ–¹æ³•ï¼Œå¤§å®¶åœ¨ç¼–ç¨‹è¿‡ç¨‹ä¸­å¯ä»¥çµæ´»è¿ç”¨ï¼Œä½†æ˜¯åœ¨æ€§èƒ½è¦æ±‚è¾ƒé«˜çš„ä»£ç ä¸­ä¸æå€¡è¿ç”¨è¿è¡Œæ—¶å¤šæ€ï¼Œæ¯•ç«ŸJavaçš„è¿è¡Œæ—¶åŠ¨æ€æ–¹æ³•è°ƒç”¨è¾ƒä¹‹æ™®é€šçš„æ–¹æ³•è°ƒç”¨çš„ç³»ç»Ÿå¼€é”€æ˜¯æ¯”è¾ƒå¤§çš„ã€‚ Javaé™æ€æ–¹æ³•ä¸å…·æœ‰å¤šæ€æ€§è¯¦è§£åŠ¨æ€ç»‘å®šæœºåˆ¶ä½¿å¾—åŸºç±»çš„å¼•ç”¨èƒ½å¤ŸæŒ‡å‘æ­£ç¡®çš„å­ç±»å¯¹è±¡ï¼Œä»Žè€Œä½¿å¾—é¢å‘åŸºç±»ç¼–ç¨‹æˆä¸ºå¯èƒ½ã€‚ç„¶è€ŒåŠ¨æ€ç»‘å®šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µä¼šå¤±æ•ˆã€‚ 1ã€åŸºç±»æ–¹æ³•æ˜¯privateæˆ–finalä¿®é¥°çš„ è¿™ä¸ªå¾ˆå¥½ç†è§£ï¼Œå› ä¸ºprivateè¯´æ˜Žè¯¥æ–¹æ³•å¯¹å­ç±»æ˜¯ä¸å¯è§çš„ï¼Œå­ç±»å†å†™ä¸€ä¸ªåŒåçš„æ–¹æ³•å¹¶ä¸æ˜¯å¯¹çˆ¶ç±»æ–¹æ³•è¿›è¡Œå¤å†™(Override)ï¼Œè€Œæ˜¯é‡æ–°ç”Ÿæˆä¸€ä¸ªæ–°çš„æ–¹æ³•ï¼Œä¹Ÿå°±ä¸å­˜åœ¨å¤šæ€çš„é—®é¢˜äº†ã€‚åŒç†ä¹Ÿå¯ä»¥è§£é‡Šfinalï¼Œå› ä¸ºæ–¹æ³•åŒæ ·æ˜¯ä¸å¯è¦†ç›–çš„ã€‚ 2ã€æ–¹æ³•æ˜¯staticä¿®é¥°çš„ ä»£ç å¦‚ä¸‹æ‰€ç¤º. 123456789101112131415161718192021222324252627class Base &#123; public static void staticMethod() &#123; System.out.println("Base staticMehtod"); &#125; public void dynamicMehtod() &#123; System.out.println("Base dynamicMehtod"); &#125;&#125;class Sub extends Base &#123; public static void staticMethod() &#123; System.out.println("Sub staticMehtod"); &#125; public void dynamicMehtod() &#123; System.out.println("Sub dynamicMehtod"); &#125;&#125;public class TJ4 &#123; public static void main(String args[]) &#123; Base c = new Sub(); c.staticMethod(); c.dynamicMehtod(); &#125;&#125;123456789101112131415161718192021222324252627 è¾“å‡ºç»“æžœå¦‚ä¸‹ï¼š 123 Base staticMehtod Sub dynamicMehtod123 è¾“å‡ºç»“æžœå¹¶ä¸åƒè®¾æƒ³çš„é‚£æ ·ï¼Œè¾“å‡º â€œSub staticMehtodâ€ã€‚å› ä¸ºé™æ€æ–¹æ³•æ˜¯ä¸Žç±»è€Œä¸æ˜¯ä¸ŽæŸä¸ªå¯¹è±¡ç›¸å…³è”ï¼Œc.staticMethod();ç­‰åŒäºŽCar.staticMethod(); æ‰€ä»¥å°½é‡ä¸è¦ä½¿ç”¨å®žä¾‹å˜é‡åŽ»è°ƒç”¨é™æ€æ–¹æ³•ï¼Œé¿å…æ··æ·†ã€‚ è½¬è½½ï¼šhttp://blog.csdn.net/jdsjlzx/article/details/52518723]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤šçº¿ç¨‹ä¹‹ä½¿ç”¨ç›®çš„]]></title>
    <url>%2Fthread-1%2F</url>
    <content type="text"><![CDATA[å¤šçº¿ç¨‹ä½¿ç”¨çš„ä¸»è¦ç›®çš„åœ¨äºŽï¼š åžåé‡ï¼šä½ åšWEBï¼Œå®¹å™¨å¸®ä½ åšäº†å¤šçº¿ç¨‹ï¼Œä½†æ˜¯ä»–åªèƒ½å¸®ä½ åšè¯·æ±‚å±‚é¢çš„ã€‚ç®€å•çš„è¯´ï¼Œå¯èƒ½å°±æ˜¯ä¸€ä¸ªè¯·æ±‚ä¸€ä¸ªçº¿ç¨‹ã€‚æˆ–å¤šä¸ªè¯·æ±‚ä¸€ä¸ªçº¿ç¨‹ã€‚å¦‚æžœæ˜¯å•çº¿ç¨‹ï¼Œé‚£åŒæ—¶åªèƒ½å¤„ç†ä¸€ä¸ªç”¨æˆ·çš„è¯·æ±‚ã€‚ ä¼¸ç¼©æ€§ï¼šä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¯ä»¥é€šè¿‡å¢žåŠ CPUæ ¸æ•°æ¥æå‡æ€§èƒ½ã€‚å¦‚æžœæ˜¯å•çº¿ç¨‹ï¼Œé‚£ç¨‹åºæ‰§è¡Œåˆ°æ­»ä¹Ÿå°±åˆ©ç”¨äº†å•æ ¸ï¼Œè‚¯å®šæ²¡åŠžæ³•é€šè¿‡å¢žåŠ CPUæ ¸æ•°æ¥æå‡æ€§èƒ½ã€‚ é‰´äºŽåšWEBçš„ç¬¬1ç‚¹å¯èƒ½å‡ ä¹Žä¸æ¶‰åŠã€‚é‚£è¿™é‡Œå°±è®²ç¬¬äºŒç‚¹å§ã€‚ â€“ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼šå‡è®¾æœ‰ä¸ªè¯·æ±‚ï¼Œè¿™ä¸ªè¯·æ±‚æœåŠ¡ç«¯çš„å¤„ç†éœ€è¦æ‰§è¡Œ3ä¸ªå¾ˆç¼“æ…¢çš„IOæ“ä½œï¼ˆæ¯”å¦‚æ•°æ®åº“æŸ¥è¯¢æˆ–æ–‡ä»¶æŸ¥è¯¢ï¼‰ï¼Œé‚£ä¹ˆæ­£å¸¸çš„é¡ºåºå¯èƒ½æ˜¯ï¼ˆæ‹¬å·é‡Œé¢ä»£è¡¨æ‰§è¡Œæ—¶é—´ï¼‰ï¼šaã€è¯»å–æ–‡ä»¶1 ï¼ˆ10msï¼‰bã€å¤„ç†1çš„æ•°æ®ï¼ˆ1msï¼‰cã€è¯»å–æ–‡ä»¶2 ï¼ˆ10msï¼‰dã€å¤„ç†2çš„æ•°æ®ï¼ˆ1msï¼‰eã€è¯»å–æ–‡ä»¶3 ï¼ˆ10msï¼‰fã€å¤„ç†3çš„æ•°æ®ï¼ˆ1msï¼‰gã€æ•´åˆ1ã€2ã€3çš„æ•°æ®ç»“æžœ ï¼ˆ1msï¼‰å•çº¿ç¨‹æ€»å…±å°±éœ€è¦34msã€‚é‚£å¦‚æžœä½ åœ¨è¿™ä¸ªè¯·æ±‚å†…ï¼ŒæŠŠabã€cdã€efåˆ†åˆ«åˆ†ç»™3ä¸ªçº¿ç¨‹åŽ»åšï¼Œå°±åªéœ€è¦12msäº†ã€‚ æ‰€ä»¥å¤šçº¿ç¨‹ä¸æ˜¯æ²¡æ€Žä¹ˆç”¨ï¼Œè€Œæ˜¯ï¼Œä½ å¹³å¸¸è¦å–„äºŽå‘çŽ°ä¸€äº›å¯ä¼˜åŒ–çš„ç‚¹ã€‚ç„¶åŽè¯„ä¼°æ–¹æ¡ˆæ˜¯å¦åº”è¯¥ä½¿ç”¨ã€‚å‡è®¾è¿˜æ˜¯ä¸Šé¢é‚£ä¸ªç›¸åŒçš„é—®é¢˜ï¼šä½†æ˜¯æ¯ä¸ªæ­¥éª¤çš„æ‰§è¡Œæ—¶é—´ä¸ä¸€æ ·äº†ã€‚aã€è¯»å–æ–‡ä»¶1 ï¼ˆ1msï¼‰bã€å¤„ç†1çš„æ•°æ®ï¼ˆ1msï¼‰cã€è¯»å–æ–‡ä»¶2 ï¼ˆ1msï¼‰dã€å¤„ç†2çš„æ•°æ®ï¼ˆ1msï¼‰eã€è¯»å–æ–‡ä»¶3 ï¼ˆ28msï¼‰fã€å¤„ç†3çš„æ•°æ®ï¼ˆ1msï¼‰gã€æ•´åˆ1ã€2ã€3çš„æ•°æ®ç»“æžœ ï¼ˆ1msï¼‰å•çº¿ç¨‹æ€»å…±å°±éœ€è¦34msã€‚å¦‚æžœè¿˜æ˜¯æŒ‰ä¸Šé¢çš„åˆ’åˆ†æ–¹æ¡ˆï¼ˆä¸Šé¢æ–¹æ¡ˆå’Œæœ¨æ¡¶åŽŸç†ä¸€æ ·ï¼Œè€—æ—¶å–å†³äºŽæœ€æ…¢çš„é‚£ä¸ªçº¿ç¨‹çš„æ‰§è¡Œé€Ÿåº¦ï¼‰ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æ˜¯ç¬¬ä¸‰ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œ29msã€‚é‚£ä¹ˆæœ€åŽè¿™ä¸ªè¯·æ±‚è€—æ—¶æ˜¯30msã€‚æ¯”èµ·ä¸ç”¨å•çº¿ç¨‹ï¼Œå°±èŠ‚çœäº†4msã€‚ä½†æ˜¯æœ‰å¯èƒ½çº¿ç¨‹è°ƒåº¦åˆ‡æ¢ä¹Ÿè¦èŠ±è´¹ä¸ª1ã€2msã€‚å› æ­¤ï¼Œè¿™ä¸ªæ–¹æ¡ˆæ˜¾å¾—ä¼˜åŠ¿å°±ä¸æ˜Žæ˜¾äº†ï¼Œè¿˜å¸¦æ¥ç¨‹åºå¤æ‚åº¦æå‡ã€‚ä¸å¤ªå€¼å¾—ã€‚ é‚£ä¹ˆçŽ°åœ¨ä¼˜åŒ–çš„ç‚¹ï¼Œå°±ä¸æ˜¯ç¬¬ä¸€ä¸ªä¾‹å­é‚£æ ·çš„ä»»åŠ¡åˆ†å‰²å¤šçº¿ç¨‹å®Œæˆã€‚è€Œæ˜¯ä¼˜åŒ–æ–‡ä»¶3çš„è¯»å–é€Ÿåº¦ã€‚å¯èƒ½æ˜¯é‡‡ç”¨ç¼“å­˜å’Œå‡å°‘ä¸€äº›é‡å¤è¯»å–ã€‚é¦–å…ˆï¼Œå‡è®¾æœ‰ä¸€ç§æƒ…å†µï¼Œæ‰€æœ‰ç”¨æˆ·éƒ½è¯·æ±‚è¿™ä¸ªè¯·æ±‚ï¼Œé‚£å…¶å®žç›¸å½“äºŽæ‰€æœ‰ç”¨æˆ·éƒ½éœ€è¦è¯»å–æ–‡ä»¶3ã€‚é‚£ä½ æƒ³æƒ³ï¼Œ100ä¸ªäººè¿›è¡Œäº†è¿™ä¸ªè¯·æ±‚ï¼Œç›¸å½“äºŽä½ èŠ±åœ¨è¯»å–è¿™ä¸ªæ–‡ä»¶ä¸Šçš„æ—¶é—´å°±æ˜¯28Ã—100=2800msäº†ã€‚é‚£ä¹ˆï¼Œå¦‚æžœä½ æŠŠæ–‡ä»¶ç¼“å­˜èµ·æ¥ï¼Œé‚£åªè¦ç¬¬ä¸€ä¸ªç”¨æˆ·çš„è¯·æ±‚è¯»å–äº†ï¼Œç¬¬äºŒä¸ªç”¨æˆ·ä¸éœ€è¦è¯»å–äº†ï¼Œä»Žå†…å­˜å–æ˜¯å¾ˆå¿«é€Ÿçš„ï¼Œå¯èƒ½1mséƒ½ä¸åˆ°ã€‚ 1234567891011public class MyServlet extends Servlet&#123; private static Map&lt;String, String&gt; fileName2Data = new HashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //è€—æ—¶28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; çœ‹èµ·æ¥å¥½åƒè¿˜ä¸é”™ï¼Œå»ºç«‹ä¸€ä¸ªæ–‡ä»¶åå’Œæ–‡ä»¶æ•°æ®çš„æ˜ å°„ã€‚å¦‚æžœè¯»å–ä¸€ä¸ªmapä¸­å·²ç»å­˜åœ¨çš„æ•°æ®ï¼Œé‚£ä¹ˆå°±ä¸ä¸ç”¨è¯»å–æ–‡ä»¶äº†ã€‚å¯æ˜¯é—®é¢˜åœ¨äºŽï¼ŒServletæ˜¯å¹¶å‘ï¼Œä¸Šé¢ä¼šå¯¼è‡´ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œæ­»å¾ªçŽ¯ã€‚å› ä¸ºï¼ŒHashMapåœ¨å¹¶å‘ä¿®æ”¹çš„æ—¶å€™ï¼Œå¯èƒ½æ˜¯å¯¼è‡´å¾ªçŽ¯é“¾è¡¨çš„æž„æˆï¼ï¼ï¼ï¼ˆå…·ä½“ä½ å¯ä»¥è‡ªè¡Œé˜…è¯»HashMapæºç ï¼‰å¦‚æžœä½ æ²¡æŽ¥è§¦è¿‡å¤šçº¿ç¨‹ï¼Œå¯èƒ½åˆ°æ—¶å€™å‘çŽ°æœåŠ¡å™¨æ²¡è¯·æ±‚ä¹Ÿå·¨å¡ï¼Œä¹Ÿä¸çŸ¥é“ä»€ä¹ˆæƒ…å†µï¼å¥½çš„ï¼Œé‚£å°±ç”¨ConcurrentHashMapï¼Œæ­£å¦‚ä»–çš„åå­—ä¸€æ ·ï¼Œä»–æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„HashMapï¼Œè¿™æ ·èƒ½è½»æ¾è§£å†³é—®é¢˜ã€‚ 1234567891011public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //è€—æ—¶28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; è¿™æ ·çœŸçš„è§£å†³é—®é¢˜äº†å—ï¼Œè¿™æ ·è™½ç„¶åªè¦æœ‰ç”¨æˆ·è®¿é—®è¿‡æ–‡ä»¶aï¼Œé‚£å¦ä¸€ä¸ªç”¨æˆ·æƒ³è®¿é—®æ–‡ä»¶aï¼Œä¹Ÿä¼šä»ŽfileName2Dataä¸­æ‹¿æ•°æ®ï¼Œç„¶åŽä¹Ÿä¸ä¼šå¼•èµ·æ­»å¾ªçŽ¯ã€‚ å¯æ˜¯ï¼Œå¦‚æžœä½ è§‰å¾—è¿™æ ·å°±å·²ç»å®Œäº†ï¼Œé‚£ä½ æŠŠå¤šçº¿ç¨‹ä¹Ÿæƒ³çš„å¤ªç®€å•äº†ï¼Œéªšå¹´ï¼ä½ ä¼šå‘çŽ°ï¼Œ1000ä¸ªç”¨æˆ·é¦–æ¬¡è®¿é—®åŒä¸€ä¸ªæ–‡ä»¶çš„æ—¶å€™ï¼Œå±…ç„¶è¯»å–äº†1000æ¬¡æ–‡ä»¶ï¼ˆè¿™æ˜¯æœ€æžç«¯çš„ï¼Œå¯èƒ½åªæœ‰å‡ ç™¾ï¼‰ã€‚What the fuckin hell!!! éš¾é“ä»£ç é”™äº†å—ï¼Œéš¾é“æˆ‘å°±è¿™æ ·è¿‡æˆ‘çš„ä¸€ç”Ÿï¼ å¥½å¥½åˆ†æžä¸‹ã€‚Servletæ˜¯å¤šçº¿ç¨‹çš„ï¼Œé‚£ä¹ˆ 123456789101112public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); //â€œå¶ç„¶â€-- 1000ä¸ªçº¿ç¨‹åŒæ—¶åˆ°è¿™é‡Œï¼ŒåŒæ—¶å‘çŽ°dataä¸ºnull if(data==null)&#123; data = readFromFile(fName); //è€—æ—¶28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; ä¸Šé¢æ³¨é‡Šçš„â€œå¶ç„¶â€ï¼Œè¿™æ˜¯å®Œå…¨æœ‰å¯èƒ½çš„ï¼Œå› æ­¤ï¼Œè¿™æ ·åšè¿˜æ˜¯æœ‰é—®é¢˜ã€‚ å› æ­¤ï¼Œå¯ä»¥è‡ªå·±ç®€å•çš„å°è£…ä¸€ä¸ªä»»åŠ¡æ¥å¤„ç†ã€‚ 1234567891011121314151617181920212223242526272829public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, FutureTask&gt; fileName2Data = new ConcurrentHashMap&lt;String, FutureTask&gt;(); private static ExecutorService exec = Executors.newCacheThreadPool(); private void processFile3(String fName)&#123; FutureTask data = fileName2Data.get(fName); //â€œå¶ç„¶â€-- 1000ä¸ªçº¿ç¨‹åŒæ—¶åˆ°è¿™é‡Œï¼ŒåŒæ—¶å‘çŽ°dataä¸ºnull if(data==null)&#123; data = newFutureTask(fName); FutureTask old = fileName2Data.putIfAbsent(fName, data); if(old==null)&#123; data = old; &#125;else&#123; exec.execute(data); &#125; &#125; String d = data.get(); //process with data &#125; private FutureTask newFutureTask(final String file)&#123; return new FutureTask(new Callable&lt;String&gt;()&#123; public String call()&#123; return readFromFile(file); &#125; private String readFromFile(String file)&#123;return "";&#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>muti-thread</category>
      </categories>
      <tags>
        <tag>muti-thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linuxç³»ç»Ÿä¸‹å®‰è£…jdkè¯¦ç»†æ­¥éª¤ï¼ˆå…±ä¸¤ç§æ–¹æ³•ï¼‰]]></title>
    <url>%2Faliyun-jdk%2F</url>
    <content type="text"><![CDATA[é…ç½®é˜¿é‡Œäº‘æœåŠ¡å™¨æ—¶é‡åˆ°ä¸€äº›ç‰ˆæœ¬é—®é¢˜ï¼Œéœ€è¦é‡è£…jdkï¼Œä»¥ä¸‹æ˜¯ä»Žç½‘ä¸Šæœç´¢çš„æ–¹æ¡ˆï¼Œæˆ‘ç”¨çš„æ˜¯ç¬¬ä¸€ç§ã€‚ ç¬¬ä¸€ç§æ–¹æ³•åªéœ€è¦ä¸€æ¡å‘½ä»¤å°±å¯ä»¥å®‰è£…jdkï¼š 1yum install java-1.8.0-openjdk* -y æ‰§è¡Œè¿‡è¿™æ¡å‘½ä»¤æ— éœ€é…ç½®ï¼Œç›´æŽ¥å¯ä»¥ä½¿ç”¨ã€‚ ç¬¬äºŒç§æ–¹æ³•1. ç™»å½•Linuxï¼Œåˆ‡æ¢åˆ°rootç”¨æˆ·su root èŽ·å–rootç”¨æˆ·æƒé™ï¼Œå½“å‰å·¥ä½œç›®å½•ä¸å˜(éœ€è¦rootå¯†ç )æˆ–sudo -i ä¸éœ€è¦rootå¯†ç ç›´æŽ¥åˆ‡æ¢æˆrootï¼ˆéœ€è¦å½“å‰ç”¨æˆ·å¯†ç ï¼‰ 2. åœ¨usrç›®å½•ä¸‹å»ºç«‹javaå®‰è£…ç›®å½•cd /usr //è¿›å…¥usrç›®å½• mkdir java //åˆ›å»ºjavaç›®å½• 3. å°†jdk-8u60-linux-x64.tar.gzæ‹·è´åˆ°javaç›®å½•ä¸‹cp /mnt/hgfs/linux/jdk-8u60-linux-x64.tar.gz /usr/java/ 4. è§£åŽ‹jdkåˆ°å½“å‰ç›®å½•tar -zxvf jdk-8u60-linux-x64.tar.gz å¾—åˆ°æ–‡ä»¶å¤¹ jdk1.8.0_60 5. å®‰è£…å®Œæ¯•ä¸ºä»–å»ºç«‹ä¸€ä¸ªé“¾æŽ¥ä»¥èŠ‚çœç›®å½•é•¿åº¦ln -s /usr/java/jdk1.8.0_60/ /usr/jdk 6. ç¼–è¾‘é…ç½®æ–‡ä»¶ï¼Œé…ç½®çŽ¯å¢ƒå˜é‡vim /etc/profile æ·»åŠ å¦‚ä¸‹å†…å®¹ï¼šJAVA_HOMEæ ¹æ®å®žé™…ç›®å½•æ¥ 123export JAVA_HOME=/usr/java/jdk1.8.0_60export CLASSPATH=JAVAHOME/lib/exportPATH=PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 7. é‡å¯æœºå™¨æˆ–æ‰§è¡Œå‘½ä»¤ ï¼šsource /etc/profilesudo shutdown -r now 8. æŸ¥çœ‹å®‰è£…æƒ…å†µ1234[root@bogon jdk]# java -versionopenjdk version â€œ1.8.0_141â€OpenJDK Runtime Environment (build 1.8.0_141-b16)OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode) 12[root@bogon jdk]# javac -versionjavac 1.8.0_141 å¯èƒ½å‡ºçŽ°çš„é”™è¯¯ä¿¡æ¯ï¼š1bash: ./java: cannot execute binary file å‡ºçŽ°è¿™ä¸ªé”™è¯¯çš„åŽŸå› å¯èƒ½æ˜¯åœ¨32ä½çš„æ“ä½œç³»ç»Ÿä¸Šå®‰è£…äº†64ä½çš„jdkï¼ŒæŸ¥çœ‹jdkç‰ˆæœ¬å’ŒLinuxç‰ˆæœ¬ä½æ•°æ˜¯å¦ä¸€è‡´ã€‚æŸ¥çœ‹ä½ å®‰è£…çš„Ubuntuæ˜¯32ä½è¿˜æ˜¯64ä½ç³»ç»Ÿï¼š 1sudo uname â€“m i686 //è¡¨ç¤ºæ˜¯32ä½x86_64 // è¡¨ç¤ºæ˜¯64ä½]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é˜¿é‡Œäº‘æœåŠ¡å™¨åŒæ­¥MySQLæ•°æ®åº“]]></title>
    <url>%2Fmysql-question-3%2F</url>
    <content type="text"><![CDATA[å°†æœ¬åœ°æ–‡ä»¶æ‹·è´åˆ°è¿œç¨‹æœåŠ¡ä¸Šçš„æŒ‡å®šç›®å½•å‘½ä»¤scpåŸºäºŽSSHåè®®ï¼Œå¯ä»¥å°†æœ¬åœ°æ–‡ä»¶æ‹·è´åˆ°è¿œç¨‹æœåŠ¡ä¸Šçš„æŒ‡å®šç›®å½•ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š 1scp filename username@remotehost:remotedirectory æ•°æ®åº“åˆ›å»ºæ—¶ï¼Œæ— æ³•ä½¿ç”¨â€œ-â€ç­‰ç‰¹æ®Šå­—ç¬¦åœ¨ä½¿ç”¨mysqlå‘½ä»¤è¿›è¡Œæ•°æ®åº“åˆ›å»ºæ—¶ï¼Œå‘çŽ°â€œ-â€ç­‰ç‰¹æ®Šå­—ç¬¦æ— æ³•ä½¿ç”¨ï¼Œæç¤ºsqlè¯­å¥è¯­æ³•é”™è¯¯ã€‚ 1mysql&gt;create database tw-travel; è§£å†³æ–¹æ¡ˆï¼šæ•°æ®åº“ååŠ ä¸Š `` 1mysql&gt;create database `tw-travel`; Linuxç³»ç»Ÿä¸‹é€šè¿‡å‘½ä»¤è¡Œå¯¹mysqlæ•°æ®åº“è¿›è¡Œå¤‡ä»½å’Œè¿˜åŽŸå¤‡ä»½ï¼š è¿›å…¥MySQLç›®å½• å¤‡ä»½ 1mysqldump -u root -på¯†ç  æ•°æ®åº“å æ•°æ®è¡¨å &gt; mysql.sql è¿˜åŽŸï¼š å»ºç«‹ä½ è¦è¿˜åŽŸçš„æ•°æ®åº“å¹¶use database å¯¼å…¥sqlæ–‡ä»¶ 1source mysql.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ”¹å–„Macç³»ç»ŸMySQLé…ç½®çŽ¯å¢ƒå˜é‡]]></title>
    <url>%2Fmysql-question-2%2F</url>
    <content type="text"><![CDATA[æœ¬åœ°MySQLï¼šæ”¹å–„Macç³»ç»ŸMySQLé…ç½®çŽ¯å¢ƒå˜é‡1.é¦–å…ˆä¿®æ”¹.bash_profile æ–‡ä»¶sudo vim .bash_profile 2.åŠ ä¸Šä¸€è¡Œé…ç½®PATHï¼Œå¹¶ä¿å­˜export PATH=${PATH}:/usr/local/mysql/bin3.ç»ˆç«¯è¾“å…¥æ­¤å‘½ä»¤ä½¿PATHç”Ÿæ•ˆsource .bash_profile4.æ­¤æ—¶å³å¯ç”¨mysql -u root -p è¿›å…¥MySQLï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªé—®é¢˜å°±æ˜¯å½“ä½ é‡å¯ç»ˆç«¯æ—¶ä¼šå‘çŽ°åˆæ— æ³•ç”¨è¯¥å‘½ä»¤äº†ï¼ŒåŽŸå› æ˜¯å½“ä½ é‡å¯æ—¶æ­¤æ—¶PATHä¸‹æ²¡æœ‰mysqlï¼Œéš¾é“æ¯æ¬¡å…³æŽ‰ç»ˆç«¯åœ¨æ‰“å¼€éƒ½éœ€è¦é‡æ–°source .bash_profile è§£å†³æ–¹æ¡ˆ1.ç»ˆç«¯ç¼–è¾‘~/.zshc æ–‡ä»¶vim ~/.zshrc 2.æ·»åŠ å¹¶ä¿å­˜export PATH=${PATH}:/usr/local/mysql/bin 3.ç»ˆç«¯source ~/.zshc 4.ä¸€åŠ³æ°¸é€¸~ é™„ï¼šæœ‰çš„æ–‡ç« ä¸­æåˆ°ä¿®æ”¹~/.bashrcï¼Œå¦‚æžœç³»ç»Ÿæ˜¯zshçš„ä¿®æ”¹bashrcæ˜¯æ— æ•ˆçš„]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQLè§£å†³ä¸­æ–‡ä¹±ç ä¹‹å…¨å¥—æ–¹æ¡ˆ]]></title>
    <url>%2FWebEncoding%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©é‡åˆ°ä¸€å †MySQL ä¸­æ–‡ä¹±ç çš„é—®é¢˜ ï¼Œæ€»ä½“æ¥è¯´åˆ†ä¸ºæ•°æ®åº“å±‚é¢ï¼ŒTomcatå±‚é¢ï¼Œwebè¡¨ç¤ºå±‚é¢ã€‚ æ•°æ®åº“å±‚é¢å…ˆæ˜¯MySQLæ•°æ®åº“ä¸­æ–‡ä¹±ç é—®é¢˜ï¼Œå¤§æ¦‚æ ·å­å¦‚ä¸‹ï¼š ç„¶åŽè‡ªæˆ‘æ„Ÿè§‰è¿™ä»¶äº‹æƒ…ä¸å°±æ˜¯æ”¹ä¸‹å­—æ®µçš„ç¼–ç å—ï¼Œé‚£å°±æ”¹ä¸€ä¸‹å‘—å¦‚å›¾ï¼Œæˆ‘æ›´æ”¹äº†Encoding ç„¶åŽå‘çŽ°äº‹æƒ…å¹¶æ²¡æœ‰é‚£ç®€å•ï¼ŒäºŽæ˜¯å¼€å§‹ä¸Šç½‘æŸ¥è§£å†³æ–¹æ¡ˆï¼Œç½‘ä¸Šè¯´éœ€è¦ä¿®æ”¹/etc/my.cnf(æ­¤é…ç½®æ–‡ä»¶å¯¹äºŽmacåŽç¼€æ˜¯.cnfï¼Œå¯¹äºŽWindowsæ˜¯.ini)ã€‚æ‰€ä»¥æ¼«æ¼«æ‰¾å¯»ä¹‹è·¯å¼€å§‹äº†ï¼Œæœ€åŽè¿žLinuxæŸ¥è¯¢findè¯­å¥ä¹Ÿè¯•äº†å°±æ˜¯æ‰¾ä¸åˆ°ï¼Œç»ˆäºŽåœ¨å‡ ç¯‡æ–‡ç« é‡ŒæŸ¥åˆ°Macä¸Šçš„MySQLæ²¡æœ‰my.cnfé…ç½®æ–‡ä»¶ï¼Œå¥½å§ï¼Œç»§ç»­å¯»æ‰¾è§£å†³æ–¹æ¡ˆï¼Œæœ‰äººè¯´MySQLä¸‹çš„support-fileä¸­æ‰¾ä¸€ä¸ª.cnfå¤åˆ¶ä¸€ä¸‹å†æ”¹ï¼›é‡Œé¢çš„ä¸œè¥¿ï¼Œç„¶è€Œæˆ‘è¿ž.cnfæ–‡ä»¶éƒ½æ²¡æœ‰æ‰¾åˆ°ã€‚æœ€åŽé‡‡ç”¨ä¸€ä½ç½‘å‹çš„åŠžæ³•ï¼Œç›´æŽ¥åœ¨/etcç›®å½•ä¸‹ vim my.cnfæ–°å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œåœ¨æ­¤é™„ä¸Šæˆ‘ä¿®æ”¹è¿‡çš„æ–‡ä»¶é‡Œé¢å†…å®¹ï¼Œåœ¨[mysqld] ä¹‹åŽå¢žåŠ äº†ä¸€è¡Œ collation-server = utf8_general_ci 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the "--help" option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 default-storage-engine = INNODB collation-server = utf8_general_ci init_connect='SET NAMES utf8' port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect='SET NAMES utf8'# Don't listen on a TCP/IP port at all. This can be a security enhancement,# if all processes that need to connect to mysqld run on the same host.# All interaction with mysqld must be made via Unix sockets or named pipes.# Note that using this option without enabling named pipes on Windows# (via the "enable-named-pipe" option) will render mysqld useless!##skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master's port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST='125.564.12.1', MASTER_PORT=3306, # MASTER_USER='joe', MASTER_PASSWORD='secret'; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables' values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout æ­¤æ—¶ä¿å­˜æ–‡ä»¶ï¼Œå†ä¿®æ”¹æ–‡ä»¶è¯»å†™æƒé™ï¼Œå°†æƒé™ä¿®æ”¹ä¸º664 1sudo chmod 664 /etc/my.cnf ä¹‹åŽå†é‡å¯MySQLå’Œé…ç½®æ–‡ä»¶å°±å¯ä»¥ç”Ÿæ•ˆäº†ã€‚ç„¶åŽå®Œæˆä¹‹åŽï¼Œç¡®å®žï¼Œå¦‚æžœä½ æŸ¥ä¸€ä¸‹MySQLçš„å„ç§ç¼–ç ï¼Œç¡®å®žéƒ½å˜æˆäº†UTF-8é€šè¿‡ä»¥ä¸‹å‘½ä»¤ ç„¶è€Œ~è¾“å…¥ä¸äº†ä¸­æ–‡äº†ï¼ŒæŠ¥é”™ æœ€åŽå°†å½“å‰æ•°æ®åº“ä»¥åŠæ‰€æœ‰è¡¨æ‰€æœ‰å­—æ®µéƒ½è®¾ç½®ä¸ºUTF-8 æƒŠå–œçš„å‘çŽ°å¯ä»¥æ„‰å¿«çš„è¾“å…¥ä¸­æ–‡äº†~~è‡³æ­¤ï¼Œæ•°æ®åº“å±‚é¢å‘Šä¸€æ®µè½ Tomcatå±‚é¢æŽ¥ä¸‹æ¥æˆ‘è¯´çš„ç®€ç•¥ä¸€äº›ï¼Œå¦‚æžœURLè¯·æ±‚é‡‡å–GETæ–¹æ³•ï¼Œé‚£ä¹ˆä½ çš„URLä¸­å¯èƒ½ä¼šå‡ºçŽ°ä¸­æ–‡ï¼Œæ‰€ä»¥éœ€è¦åœ¨Tomcaté…ç½®æ–‡ä»¶é‡Œé¢è®¾ç½®ç¼–ç æ–¹å¼ã€‚ ä¿®æ”¹Tomcatä¸‹çš„conf/server.xmlæ–‡ä»¶ï¼Œæ‰¾åˆ°å¦‚ä¸‹ä»£ç ï¼š 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; è¿™æ®µä»£ç è§„å®šäº†Tomcatç›‘å¬HTTPè¯·æ±‚çš„ç«¯å£å·ç­‰ä¿¡æ¯ã€‚å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä¸€ä¸ªå±žæ€§ï¼šURIEncodingï¼Œå°†è¯¥å±žæ€§å€¼è®¾ç½®ä¸ºUTF-8ï¼Œå³å¯è®©Tomcatï¼ˆé»˜è®¤ISO-8859-1ç¼–ç ï¼‰ä»¥UTF-8çš„ç¼–ç å¤„ç†getè¯·æ±‚ã€‚æ›´æ”¹åŽçš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" URIEncoding="UTF-8" redirectPort="8443" /&gt; Webæ˜¾ç¤ºå±‚é¢è¿™é‡Œä¸»è¦é’ˆå¯¹è¯·æ±‚ä¸ºPOSTæ–¹æ³•çš„æ—¶å€™ï¼Œä½ éœ€è¦è®¾ç½®web.xml æ–‡ä»¶ï¼Œè®¾ç½®å­—ç¬¦ä¸²è¿‡æ»¤å™¨ 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; æœ€åŽå¦‚æžœä½ è¦å›žæ˜¾åˆ°é¡µé¢ä¸Šæ‰“å°ä¸­æ–‡çš„è¯éœ€è¦è®¾ç½®ä¸€ä¸‹responseå¦‚æžœä½ ä½¿ç”¨springMVCå¯ä»¥è®¾ç½® 1@RequestMapping(value = "/XX.do", produces="text/html;charset=UTF-8")]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQLä¹‹order]]></title>
    <url>%2Fmysql-question-1%2F</url>
    <content type="text"><![CDATA[åˆšæµ‹è¯•æŸ¥è¯¢è®¢å•controlleræ—¶å€™é‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Œsqlè¯­å¥èŽ«åå…¶å¦™çš„å‡ºé”™äº† å‘½ä»¤è¡Œå®žéªŒä¸€ä¸‹æ“ä½œMysqlçš„æ—¶å€™å°´å°¬åœ°é‡åˆ°äº†ä¸€ä¸ªé—®é¢˜ï¼Œè¯•äº†è¯•å…¶ä»–è¡¨éƒ½å¥½çš„ï¼Œå°±æ˜¯æ€Žä¹ˆéƒ½æŸ¥è¯¢ä¸äº†orderè¡¨ã€‚ åŽæ¥è¯•äº†è¯•æ”¹æˆordersè¡¨å°±å¥½äº†ï¼ŒåŽæ¥ä¸€æƒ³orderæ˜¯MySQLçš„ä¸€ä¸ªå…³é”®å­—å•Š~ order by]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å­¦ä¹ ssmæ¡†æž¶â€”â€”Mybatisç‰ˆæœ¬é—®é¢˜è§£å†³æ–¹æ¡ˆï¼ˆä¸€ï¼‰]]></title>
    <url>%2Fssm1%2F</url>
    <content type="text"><![CDATA[å‰å‡ å¤©æ­å»ºäº†ssmæ¡†æž¶å‡†å¤‡å¼€å‘åŽç«¯ï¼Œä»Šå¤©å†™mapperæ—¶é‡åˆ°ä¸ªæ£˜æ‰‹çš„é—®é¢˜-å†™selectè¯­å¥æ—¶å‘çŽ°å…¥å‚æŠ¥é”™æ€»æ˜¯æç¤ºæ‰¾ä¸åˆ°usernameï¼Œè€Œä¸”é”™è¯¯ä¿¡æ¯é‡Œé¢æœ‰å››ä¸ªå‚æ•°ï¼Œè€Œæˆ‘çš„å…¥å‚åªæœ‰ä¸¤ä¸ªï¼Œè´´å‡ºæºä»£ç å’Œé”™è¯¯ä¿¡æ¯ã€‚123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; Mybatiså‚æ•°é—®é¢˜ ç„¶åŽç»è¿‡ä¸€ç•ªæŠ˜è…¾åœ¨ç½‘ä¸Šæ‰¾åˆ°è§£å†³æ–¹æ¡ˆï¼Œå°†å˜é‡æ”¹æˆå‚æ•°å½¢å¼0ï¼Œ1æˆ–è€…åŠ ä¸ŠjdbcTypeï¼Œä»£ç å¦‚ä¸‹ 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;0&#125; and password = #&#123;1&#125; &lt;/select&gt; And 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;username, jdbcType=VARCHAR&#125; and password = #&#123;password, jdbcType=VARCHAR&#125; &lt;/select&gt; æŠ¥é”™åŒä¸Šã€‚ æ­¤æ—¶å°±å¾ˆéš¾å—äº†ï¼Œçœ‹æºç debugã€‚ã€‚ã€‚å¶ç„¶é—´æŸ¥åˆ°äº†å¯èƒ½æ˜¯ç‰ˆæœ¬é—®é¢˜ï¼Œç„¶åŽå°è¯•äº†ä»¥ä¸‹è§£å†³æ–¹æ¡ˆæžå®š 123&lt;select id="selectUserByNameAndPassword" parameterType="String" resultType="po.User"&gt; select * from user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; æœ€åŽè´´ä¸Šç äº‘é¡¹ç›®åœ°å€]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ·±åº¦å­¦ä¹ ]]></title>
    <url>%2Fdeeplearning%2F</url>
    <content type="text"><![CDATA[éšä¾¿ç¿»ä¸€ç¿»åœ¨wikipediaæœç´¢æ—¶å‘çŽ°è¿™ä¸ªé¡¿æ—¶æ…Œå¼ èµ·æ¥ï¼Œæˆªå›¾ç•™å¿µã€‚è¿™DeepLearningè¦å­¦çš„çœŸä¸æ˜¯ä¸€ç‚¹ä¸¤ç‚¹ï¼Œæ•°å­¦æ²¡å­¦å¥½çœŸçš„ä¼¤ã€‚]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[è¿™æ‰æ˜¯çˆ±æƒ…æœ€å¥½çš„æ ·å­ï¼ˆè½¬è½½ï¼‰]]></title>
    <url>%2Fhunying%2F</url>
    <content type="text"><![CDATA[å’Œå¥³å„¿ä¸€èµ·åœ¨ä¹¦åº—æ‰“å‘æ—¶é—´ï¼Œå¥¹çœ‹ä¹¦çœ‹å¾—å…¥è¿·ï¼Œæˆ‘åœ¨è¾¹ä¸Šçš„å°å’–å•¡å§å†™ç¨¿å­ã€‚å¤©æ°”å¤ªçƒ­ï¼Œå’–å•¡å§é‡Œäººä¸å¤šï¼Œæœ‰ä¸¤ä¸ªå¥³å£«åœ¨ä¸€æ—é—²èŠã€‚ å…¶ä¸­ä¸€ä¸ªé—®ï¼šâ€œæ€Žä¹ˆä½ çš„é»‘çœ¼åœˆçœ‹ç€åˆå¤§äº†ä¸€ç‚¹å•Šï¼Ÿâ€ ç­”ï¼šâ€œè¿™æœ‰ä»€ä¹ˆåŠžæ³•ï¼Œæˆ‘è€å…¬å‡ºå·®äº†ï¼Œå¬ä¸åˆ°ä»–çš„å‘¼å™œå£°æˆ‘åè€Œç¡ä¸ç€äº†ã€‚â€ â€œå™—å‘²â€¦â€¦â€è¾¹ä¸Šçš„é‚£ä¸ªäººå¿ä¸ä½ä¹äº†ï¼Œåœ¨è¾¹ä¸Šå¬ç€çš„æˆ‘ä¹Ÿæœ‰ç‚¹å¿ä¿Šä¸ç¦ã€‚ â€œä½ ä¸çŸ¥é“ï¼Œæˆ‘è€å…¬åªè¦ä¸€æ„Ÿå†’äº†ï¼Œå°±ä¼šè¿žå¸¦ç€ä»–çš„é¼»ç‚Žæ›´ä¸¥é‡ï¼ŒåŠå¤œå‘¼å™œå£°ç‰¹åˆ«å¤§ï¼Œé‚£ä¸ªå£°éŸ³å°±æ˜¯åœ¨éš”å£æˆ¿é‡Œç¡éƒ½æ¸…æ™°å¾—ä¸å¾—äº†ã€‚ ä½†æ˜¯ä»–çš„å‘¼å™œå£°æœ‰ç‚¹å“äººï¼Œä¸€å£°å¤§çš„â€œå‘¼â€¦â€¦â€ä¸ŠåŽ»ï¼ŒåŠå¤©ä½ æ²¡å¬åˆ°æŽ¥ä¸‹æ¥çš„é‚£å£°å“åŠ¨ï¼Œä½ çš„å¿ƒæ€å°±ä¼šéšç€ä»–çš„å£°éŸ³ä¸ƒä¸Šå…«ä¸‹çš„ï¼Œæ‹…å¿ƒä»–æ˜¯ä¸æ˜¯ç¡åŽ¥è¿‡åŽ»äº†ã€‚â€ è¿™ä¸ªè¯´è¯çš„å¥³äººè¶Šè¯´è¶Šå¤§å£°ï¼šâ€œå“Žå‘€ï¼Œä½ éƒ½ä¸çŸ¥é“ï¼Œä»–è¿˜æœ‰å‘¼å¸éª¤åœçš„æ¯›ç—…ï¼ŒåŒ»ç”Ÿè¯´äº†æœ€å¥½è¦ä¾§å§ï¼Œä¸èƒ½ä»°å§ï¼Œä»–é‚£å‘¼å™œå£°ä¸€åœï¼Œå¾€å¾€å°±æ˜¯ä»°é¢æœä¸Šçš„ç¡åŠ¿ï¼Œæˆ‘å¾—èµ¶ç´§æŠŠä»–æŽ¨é†’ï¼Œå«ä»–ä¾§ç€ç¡ã€‚â€ â€œé‚£è¿™æ ·ä½ è‚¯å®šç¡ä¸å¥½çš„å‘€ï¼Œéš¾æ€ªä½ çš„é»‘çœ¼åœˆå¤©å¤©éƒ½é‚£ä¹ˆå¤§ã€‚â€ â€œæ˜¯å•Šï¼Œä½†ç»“å©šè¿™ä¹ˆå¤šå¹´äº†ï¼Œä½ è¯´æ€ªä¸æ€ªï¼Œä»–è¦å‡ºå·®ä¸åœ¨å®¶çš„æ—¶å€™ï¼Œå¬ä¸åˆ°ä»–çš„å‘¼å™œå£°æˆ‘åè€Œæ›´ç¡ä¸ç€äº†ã€‚â€ åœ¨æ„Ÿæƒ…çš„ä¸–ç•Œé‡Œå…œå…œè½¬è½¬çš„äººå¤§æ¦‚éƒ½çŸ¥é“çš„ä¸€ä¸ªå®šç†æ˜¯ï¼Œè¿™ä¸–ä¸Šæœ€ç‰¢å›ºçš„æ„Ÿæƒ…ä¸æ˜¯â€œæˆ‘çˆ±ä½ â€ï¼Œè€Œæ˜¯â€œæˆ‘ä¹ æƒ¯äº†æœ‰ä½ â€ã€‚ ä¸–é—´çš„å¤«å¦»éƒ½å¤§åŒå°å¼‚ï¼Œä¸€å£é”…é‡Œåƒé¥­ï¼Œä¸€å¼ åºŠä¸Šç¡è§‰ï¼Œå‘¨è€Œå¤å§‹çš„ç”Ÿæ´»è®©åŽŸæœ¬æ¯«ä¸ç›¸å¹²çš„äººäº²å¯†åœ°ç”Ÿæ´»åœ¨ä¸€èµ·ã€‚æ—¶é—´ä¹…äº†ï¼Œå±…ç„¶è¿žåŽŸæœ¬æ¼äººçš„å‘¼å™œå£°éƒ½æˆäº†å©šå§»é‡Œå¿…ä¸å¯å°‘è®©äººå¿ƒå®šçš„å®‰å…¨æ„Ÿã€‚ æˆ‘æƒ³ï¼Œåœ¨ç”Ÿæ´»çš„çƒŸç†ç«ç‡Žé‡Œä»ç„¶ä¸ç¦»ä¸å¼ƒçš„ä¸¤ä¸ªäººåº”è¯¥å°±æ˜¯çˆ±æƒ…æœ€å¥½çš„æ ·å­ã€‚ è¿™ä¸ªä¸–ä¸Šå¹¶æ²¡æœ‰ä»€ä¹ˆæ•™ç§‘ä¹¦ä¼¼çš„å®Œç¾Žçˆ±æƒ…ï¼Œæœ‰è¿™ä¹ˆä¸€å¯¹å¤«å¦»ï¼š ä»–å‘å¥¹æ±‚å©šæ—¶ï¼Œåªè¯´äº†ä¸‰ä¸ªå­—ï¼šç›¸ä¿¡æˆ‘ï¼› å¥¹ä¸ºä»–ç”Ÿä¸‹ç¬¬ä¸€ä¸ªå¥³å„¿çš„æ—¶å€™ï¼Œä»–å¯¹å¥¹è¯´ï¼šè¾›è‹¦äº†ï¼› å¥³å„¿å‡ºå«å¼‚åœ°é‚£å¤©ï¼Œä»–æ‚ç€å¥¹çš„è‚©è¯´ï¼šè¿˜æœ‰æˆ‘ï¼› ä»–æ”¶åˆ°å¥¹ç—…å±é€šçŸ¥çš„é‚£å¤©ï¼Œé‡å¤åœ°å¯¹å¥¹è¯´ï¼šæˆ‘åœ¨è¿™ï¼› å¥¹è¦èµ°çš„é‚£ä¸€åˆ»ï¼Œä»–äº²å»å¥¹çš„é¢å¤´è½»å£°è¯´ï¼šä½ ç­‰æˆ‘ã€‚ è¿™ä¸€ç”Ÿï¼Œä»–æ²¡å¯¹å¥¹è¯´è¿‡ä¸€æ¬¡â€œæˆ‘çˆ±ä½ â€ï¼Œä½†çˆ±ï¼Œä»Žæœªç¦»å¼€è¿‡ã€‚ ä»Žæ²¡æœ‰å¤šä½™çš„è¨€è¯­ï¼Œä¹Ÿä¸æ˜¯ç”œè¨€èœœè¯­åˆ¶é€ çš„æ©çˆ±å‡è±¡ã€‚åªæ˜¯å¹³å‡¡çš„ç”Ÿæ´»ä¸­æ¯ä¸ªç»†èŠ‚å’Œçœ¼ç¥žé‡Œé€éœ²å‡ºçš„ä½“è´´ã€å…³å¿ƒã€‚ æˆ‘æƒ³ï¼Œå¹³æ·¡è€Œè¸å®žåœ°æºæ‰‹èµ°å®Œä¸€ç”Ÿçš„ä¸¤ä¸ªäººåº”è¯¥å°±æ˜¯å¥½çš„çˆ±æƒ…è¯¥æœ‰çš„æ ·å­ã€‚ ä»–æ˜¯ä¸ªæžè®¾è®¡çš„å·¥ç¨‹å¸ˆï¼Œå¥¹æ˜¯ä¸­å­¦æ¯•ä¸šç­çš„ç­ä»»è€å¸ˆï¼Œä¸¤äººéƒ½é”™è¿‡äº†æ‹çˆ±çš„æœ€ä½³å­£èŠ‚ï¼ŒåŽæ¥ç»äººä»‹ç»è€Œç›¸è¯†ã€‚ æ²¡æœ‰æƒŠå¤©åŠ¨åœ°çš„è¿‡ç¨‹ï¼Œå¹³å¹³æ·¡æ·¡åœ°ç›¸å¤„ï¼Œè‡ªè‡ªç„¶ç„¶åœ°ç»“å©šã€‚ å©šåŽç¬¬ä¸‰å¤©ï¼Œä»–å°±è·‘åˆ°å•ä½åŠ ç­ï¼Œä¸ºäº†èµ¶è®¾è®¡ï¼Œä»–ç”šè‡³å¯ä»¥å½»å¤œæ‹¼å‘½ï¼Œè¿žç»­å‡ å¤©å‡ å¤œä¸å›žå®¶ã€‚å¥¹å¿™äºŽæ¯•ä¸šç­çš„ç®¡ç†ï¼Œç»å¸¸æ™šå½’ã€‚ ä¸ºäº†å„è‡ªçš„äº‹ä¸šï¼Œä»–ä»¬å°±åƒä¸¤ä¸ªé™€èžºï¼Œåœ¨å„è‡ªçš„è½¨é“ä¸Šé«˜é€Ÿæ—‹è½¬ç€ã€‚ é€èµ°äº†æ¯•ä¸šç­ï¼Œæ¸…é—²äº†çš„å¥¹å¼€å§‹é‡æ–°å®¡è§†è‡ªå·±çš„ç”Ÿæ´»ï¼Œå®¡è§†è‡ªå·±çš„å©šå§»ï¼Œå¥¹å¼€å§‹è¿·èŒ«ï¼Œä¸çŸ¥é“è‡ªå·±åœ¨ä»–å¿ƒé‡Œæœ‰å¤šé‡ï¼Œå¥¹ä¼¼ä¹Žä¸è®°å¾—ä»–è¯´è¿‡çˆ±å¥¹ã€‚ ä¸€å¤©ï¼Œå¥¹é—®ä»–æ˜¯ä¸æ˜¯çˆ±å¥¹ï¼Œä»–è¯´å½“ç„¶çˆ±ï¼Œä¸ç„¶æ€Žä¹ˆä¼šç»“å©šï¼Œå¥¹é—®ä»–æ€Žä¹ˆä¸è¯´çˆ±ï¼Œä»–è¯´ä¸çŸ¥é“æ€Žä¹ˆè¯´ã€‚ å¥¹æ‹¿å‡ºå†™å¥½çš„ç¦»å©šåè®®ï¼Œä»–æ„£äº†ï¼Œè¯´ï¼Œé‚£æˆ‘ä»¬åŽ»æ—…æ¸¸å§ï¼Œç»“å©šçš„èœœæœˆæˆ‘éƒ½æ²¡é™ªä½ ï¼Œæˆ‘äºæ¬ ä½ å¤ªå¤šã€‚ ä»–ä»¬åŽ»äº†å¥‡å³°å¼‚çŸ³çš„å¼ å®¶ç•Œã€‚é£˜é›¨çš„å¤©æ°”å’Œä»–ä»¬é˜´éƒçš„å¿ƒæƒ…ä¸€æ ·ï¼Œèµ°åœ¨ç›˜æ—‹çš„å±±é“ä¸Šï¼Œå¥¹å‘çŽ°ä»–æ€»æ˜¯èµ°åœ¨å¤–ä¾§ï¼Œå¥¹é—®ä»–ä¸ºä»€ä¹ˆï¼Œä»–è¯´è·¯å¤ªæ»‘ï¼Œä»–æ€•å¤–ä¾§çš„æ …æ ä¸ç‰¢ï¼Œæ€•å¥¹ä¸‡ä¸€ä¸å°å¿ƒè·Œå€’ã€‚ å¥¹çš„å¿ƒå¿½ç„¶æ„Ÿåˆ°äº†æ¸©æš–ï¼Œå›žå®¶å°±æŠŠé‚£ä»½ç¦»å©šåè®®æ’•æŽ‰äº†ã€‚ å¾ˆå¤šæ—¶å€™ï¼Œçˆ±æ˜¯åŸ‹åœ¨å¿ƒåº•çš„ï¼Œå°¤å…¶æ˜¯å©šå§»è¿›è¡Œä¸­çš„çˆ±ï¼Œå¹³å¹³æ·¡æ·¡ï¼Œè¯´ä¸å‡ºæ¥ï¼Œä½†æ˜¯çœŸå®žå­˜åœ¨ã€‚ æœ€å¥½çš„çˆ±æƒ…æ˜¯é™ªä¼´ï¼Œæœ€é è°±çš„æ„Ÿè§‰æ˜¯æ¸©æš–ï¼Œæˆ‘æƒ³ï¼Œè¿™åº”è¯¥ä¹Ÿæ˜¯çˆ±æƒ…æœ€å¥½çš„æ ·å­ã€‚ 1942å¹´åº•ï¼Œæ¨ç»›åˆ›ä½œäº†è¯å‰§ã€Šç§°å¿ƒå¦‚æ„ã€‹ã€‚åœ¨é‡‘éƒ½å¤§æˆé™¢ä¸Šæ¼”åŽï¼Œä¸€é¸£æƒŠäººï¼Œè¿…é€Ÿèµ°çº¢ã€‚æ¨ç»›çš„è¹¿çº¢ï¼Œä½¿å¤§æ‰å­é’±é’Ÿä¹¦åä¸ä½äº†ã€‚ ä¸€å¤©ï¼Œä»–å¯¹æ¨ç»›è¯´ï¼šâ€œæˆ‘æƒ³å†™ä¸€éƒ¨é•¿ç¯‡å°è¯´ï¼Œä½ æ”¯æŒå—ï¼Ÿâ€æ¨ç»›å¤§ä¸ºé«˜å…´ï¼Œå‚¬ä»–èµ¶ç´§å†™ã€‚ æ¨ç»›è®©ä»–å‡å°‘æŽˆè¯¾æ—¶é—´ï¼Œä¸ºäº†èŠ‚çœå¼€æ”¯ï¼Œå¥¹è¿˜æŠŠå®¶é‡Œçš„å¥³ä½£è¾žé€€äº†ï¼Œè‡ªå·±åŒ…æ½äº†æ‰€æœ‰çš„å®¶åŠ¡æ´»ï¼ŒåŠˆæç”Ÿç«åšé¥­æ ·æ ·éƒ½æ¥ï¼Œç»å¸¸è¢«çƒŸç«ç†å¾—æ»¡çœ¼æ˜¯æ³ªï¼Œä¹Ÿä¼šä¸å°å¿ƒåˆ‡ç ´æ‰‹æŒ‡ã€‚ å¯æ˜¯æ¨ç»›å¹¶æœªæŠ±æ€¨è¿‡ï¼Œå¥¹å¿ƒç”˜æƒ…æ„¿åœ°åšç¶ä¸‹å©¢ï¼Œåªç›¼ç€é’Ÿä¹¦çš„å¤§ä½œæ—©æ—¥é—®ä¸–ã€‚ çœ‹ç€æ˜”æ—¥å¨‡ç”Ÿæƒ¯å…»çš„å¯Œå®¶å°å§ï¼Œå¦‚ä»Šä¿®ç‚¼æˆä»»åŠ³ä»»æ€¨çš„è´¤å†…åŠ©ï¼Œé’±é’Ÿä¹¦å¿ƒé‡Œè™½æœ‰æƒ­æ„§ï¼Œä½†æ›´å¤šçš„æ˜¯å¯¹çˆ±å¦»çš„æ„Ÿæ¿€ä¸Žççˆ±ã€‚ ä¸¤å¹´åŽï¼Œã€Šå›´åŸŽã€‹æˆåŠŸé—®ä¸–ã€‚é’±é’Ÿä¹¦åœ¨ã€Šå›´åŸŽã€‹åºä¸­è¯´ï¼šâ€œè¿™æœ¬ä¹¦æ•´æ•´å†™äº†ä¸¤å¹´ã€‚ä¸¤å¹´é‡Œå¿§ä¸–ä¼¤ç”Ÿï¼Œå±¡æƒ³ä¸­æ­¢ã€‚ç”±äºŽæ¨ç»›å¥³å£«ä¸æ–­çš„ç£ä¿ƒï¼Œæ›¿æˆ‘æŒ¡äº†è®¸å¤šäº‹ï¼Œçœå‡ºæ—¶é—´æ¥ï¼Œå¾—ä»¥é”±é“¢ç§¯ç´¯åœ°å†™å®Œã€‚ç…§ä¾‹è¿™æœ¬ä¹¦è¯¥çŒ®ç»™å¥¹ã€‚â€ æœ€æ·±çš„çˆ±æ— éœ€è¯ºè¨€ï¼Œæ€»æ˜¯ç›¸ä¾ç›¸ä¼´ä¸­æŠŠä½“è´´å±•çŽ°ï¼›æœ€çº¯çš„æƒ…æ— éœ€è¯­è¨€ï¼Œæ€»æ˜¯é»˜é»˜æ— å£°é‡Œå®ˆå€™èº«è¾¹ã€‚äººç”Ÿçš„è·¯ä¸Šé£Žé›¨å…¼ç¨‹ï¼ŒåŠ³ç¢Œçš„ç”Ÿæ´»å˜˜å¯’é—®æš–ã€‚ å©šåŽæœ‰ä¸€å›žï¼Œå½“æ¨ç»›åœ¨çœ‹è‹±å›½ä¼ è®°ä½œå®¶æè¿°æœ€ç†æƒ³çš„å©šå§»ï¼šâ€œåœ¨è§åˆ°å¥¹ä¹‹å‰ï¼Œæˆ‘ä»Žæ¥æ²¡æœ‰æƒ³è¿‡è¦ç»“å©šï¼Œå¨¶äº†å¥¹å‡ åå¹´ï¼Œä»Žæ¥æ²¡æœ‰åŽæ‚”å¨¶å¥¹ï¼Œä¹Ÿæ²¡æœ‰æƒ³è¿‡è¦å¨¶åˆ«çš„å¥³äººã€‚â€ å½“æ¨ç»›è¯»åˆ°è¿™é‡Œï¼Œè§‰å¾—ç”šå¥½ï¼ŒäºŽæ˜¯æŠŠå®ƒå¿µç»™åœ¨ä¸€æ—çš„é’±é’Ÿä¹¦å¬ï¼Œé’±é’Ÿä¹¦å¬å®Œè¯´ï¼šâ€œæˆ‘å’Œä»–ä¸€æ ·ã€‚â€ æ¨ç»›éšå³å›žç­”ï¼šâ€œæˆ‘ä¹Ÿæ˜¯ã€‚â€ å¥½çš„çˆ±æƒ…ï¼Œæœ€é‡è¦çš„ä¸æ˜¯ç”œè¨€èœœè¯­ï¼Œä¸æ˜¯å®¹è²Œé‡‘é’±ï¼Œè€Œæ˜¯ä½ å’Œä»–å¯¹äºŽè¿™ä¸ªä¸–ç•Œçš„çœ‹æ³•ï¼Œå¯¹äººç”Ÿçš„æ€åº¦æ˜¯å¦ä¸€è‡´ã€‚ æˆ‘æƒ³ï¼Œä¸‰è§‚ä¸€è‡´çš„ä¸¤ä¸ªäººåº”è¯¥å°±æ˜¯çˆ±æƒ…é‡Œæœ€å¥½çš„æ ·å­ã€‚ å¼ å°å¨´è¯´ï¼Œçˆ±æƒ…çš„æ ·å­å°±æ˜¯æ¯å¤©è·Ÿè‡ªå·±å–œæ¬¢çš„äººä¸€èµ·ï¼Œé€šç”µè¯ï¼Œæ—…è¡Œï¼Œé‡å¤ä¸€ä¸ªæ‰¿è¯ºå’Œæ¢¦æƒ³ï¼Œå¬ä»–ç¬¬äºŒåå…«æ¬¡æèµ·ç«¥å¹´å¾€äº‹ï¼Œæ¯å¹´çš„åŒä¸€å¤©å’Œä»–åº†ç¥ç”Ÿæ—¥ï¼Œæ¯å¹´çš„æƒ…äººèŠ‚ã€åœ£è¯žèŠ‚ã€é™¤å¤•ï¼Œä¹Ÿå’Œä»–å…±åº¦ã€‚ç”šè‡³è¿žåµæž¶ä¹Ÿæ˜¯é‡å¤çš„ï¼Œä¸ºäº†ä¸€äº›çäº‹åµæž¶ï¼Œç„¶åŽå†·æˆ˜ï¼Œç–¯ç‹‚æ€å¿µå¯¹æ–¹ï¼Œæœ€åŽå’Œå¥½ã€‚ ä½œå®¶åäºŒè¯´ï¼Œçˆ±æƒ…ä¸­æœ€è®©äººæ„‰æ‚¦çš„æ ·å­å°±æ˜¯â€œä½ é«˜å…´ï¼Œæˆ‘éšæ„â€ã€‚ é‚£åˆ°åº•ä»€ä¹ˆæ‰æ˜¯çˆ±æƒ…æœ€å¥½çš„æ ·å­ï¼Ÿ â€œå…ˆç¡å§ï¼Œæ˜Žå¤©å†åµã€‚â€ å¬è¯´è½¬è½½è¦æ³¨æ˜Žå‡ºå¤„ï¼Œæ‰€ä»¥]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bible of a man â€”â€” ã€Šæ•™çˆ¶ã€‹]]></title>
    <url>%2Fjiaofu%2F</url>
    <content type="text"><![CDATA[Bible of a man ä¸€ä¸ªçœŸæ­£çš„ç”·äººå¿…é¡»è¦èŠ±å‡ºæ—¶é—´å’Œå®¶äººåœ¨ä¸€èµ·ï¼Œä¸ç…§é¡¾å®¶äººçš„ç”·äººï¼Œæ ¹æœ¬ç®—ä¸ä¸Šæ˜¯ä¸ªç”·äººã€‚ è¦å­¦ä¼šå°å¿ƒï¼Œå¥³äººå’Œå°å­©èƒ½å¤Ÿç²—å¿ƒå¤§æ„ï¼Œä½†ç”·äººä¸è¡Œ]]></content>
      <categories>
        <category>ç”µå½±</category>
      </categories>
      <tags>
        <tag>ç”µå½±</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åˆ©ç”¨shadowsockså’Œé˜¿é‡Œäº‘æœåŠ¡å™¨æ­å»ºä»Žå›½å¤–åˆ°å›½å†…çš„vpn]]></title>
    <url>%2Fvpn%2F</url>
    <content type="text"><![CDATA[åˆšå¼€å§‹çœ‹å®Œæ•™ç¨‹æ„Ÿè§‰ï¼Œå“‡ï¼Œå¥½ç®€å•ã€‚ç„¶è€Œé…ç½®æœåŠ¡ç«¯shadowsocksæ–‡ä»¶çš„æ—¶å€™å‡ºäº†ç‚¹å°é—®é¢˜â€‹ å»ºè®®æŠŠ SS çš„é…ç½®æ–‡ä»¶æ”¾ç½®åœ¨å½“å‰ç”¨æˆ·ä¸»ç›®å½•ä¸‹çš„ ss æ–‡ä»¶å¤¹å†…ï¼Œå¯¹äºŽ root ç”¨æˆ·è€Œè¨€ï¼Œåˆ™æ˜¯ï¼š/root/ss ç›®å½•ã€‚å…¶ä½™ç”¨æˆ·ä¸€èˆ¬åˆ™æ˜¯ï¼š/home/ç”¨æˆ·å ç›®å½•ã€‚ å› ä¸ºæœåŠ¡å™¨é¢„è£…centOS 7,ç„¶åŽå‘çŽ°è‡ªå·±æ‰¾ä¸åˆ°rootç›®å½•ï¼Œæ›´åˆ«è¯´ssï¼ŒäºŽæ˜¯ï¼ŒGoogleå¤§æ³•å¥½ï¼Œç„¶è€Œå¹¶æ²¡æœ‰æ‰¾åˆ°æ­£è§£ã€‚æš‚æ—¶å‘Šä¸€æ®µè½ï¼Œæ‹©æ˜Žæ—¥å†æˆ˜ã€‚ ä¹‹åŽæ¢äº†ä¸ªæ€è·¯ï¼Œå…ˆå¾€ä¸‹çœ‹å‘—ï¼Œå¿½ç„¶å‘çŽ°è¿™ä¸€æ­¥1nohup ssserver -c /root/ss/ssserver.json -d start &amp; æƒŠè§‰è·¯å¾„æ²¡å…³ç³»ï¼Œä¹‹åŽæ¢ä¸€ä¸ªå°±å¥½ã€‚éšåŽå°±è§£å†³äº†ã€‚ æ„Ÿè°¢å¤§ä½¬æ•™ç¨‹çš„å¸®åŠ©]]></content>
      <categories>
        <category>vpn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psychology]]></title>
    <url>%2Fpsychology%2F</url>
    <content type="text"><![CDATA[ä»¥ä¸‹æ˜¯çœ‹æœ‰åœŸé³–psychologyç›¸å…³å†…å®¹è®°ä¸‹çš„ç¬”è®°(çº¯æ‰‹æ‰“) äººä¼šåœ¨æ— æ„è¯†çš„æƒ…å†µä¸‹æ¨¡ä»¿è‡ªå·±å–œæ¬¢çš„äººçš„åŠ¨ä½œï¼Œå› ä¸ºè¿™ä¼šè®©å¥¹æ›´æœ‰å®‰å…¨æ„Ÿã€‚ å¤šå·´èƒºå³â€œæƒ³è¦â€ï¼Œæ˜¯ç”Ÿå­˜å‘å±•çš„åŠ¨åŠ›ã€‚ äººçš„è„‘å­ä¸€æ¬¡åªèƒ½ä¸“æ³¨äºŽä¸€ä»¶äº‹æƒ…ã€‚ ä¸€ä¸ªäººå¦‚æžœå¼€å¿ƒï¼Œä¼šæ›´æƒ³å°è¯•æ–°äº‹ç‰©ï¼›åä¹‹ï¼Œå¸Œæœ›åšç†Ÿæ‚‰çš„äº‹ã€‚ å¥³ç”Ÿå·¦å³è„‘è¿žæŽ¥æ¯”ç”·ç”Ÿç´§å¯†çš„å¤šï¼Œå·¦è„‘æŽ§åˆ¶è¯­è¨€ï¼Œå³è„‘æŽ§åˆ¶æƒ…ç»ªï¼Œå¥³ç”Ÿå–„ç”¨è¯­è¨€æ¥è¡¨è¾¾æƒ…ç»ªï¼Œä¸”å¥³ç”Ÿåœ¨å°æ—¶å€™åˆ†æ³Œé›Œæ€§æ¿€ç´ å¤§çº¦ä¸¤å¹´ï¼Œè€Œç”·ç”Ÿå°æ—¶å€™å¤§çº¦åˆ†æ³Œé›„æ€§æ¿€ç´ åªæœ‰å…«ä¸ªæœˆï¼Œæ‰€ä»¥åˆä¸­ä¹‹å‰å¥³ç”Ÿè¯­è¨€è¡¨è¾¾ç†è§£èƒ½åŠ›ä¼šæ¯”ç”·ç”Ÿå¼ºå¾—å¤šã€‚ äººçš„å¤§è„‘æœ‰N1åˆ°N5çš„åŒºåŸŸï¼Œç”·ç”Ÿå¤§è„‘N5åŒºåŸŸæ›´å‘è¾¾ï¼Œä¸Žè·ç¦»ã€æ–¹å‘ç›¸å…³ï¼Œå¥³ç”ŸN4åŒºåŸŸæ›´å‘è¾¾ï¼Œä¸Žé¢œè‰²ã€åœ°æ ‡ç›¸å…³ï¼Œè¿™å°±èƒ½è§£é‡Šç”·å¥³å¯¹è·¯çº¿æè¿°çš„å·®å¼‚æ€§ï¼ŒåŒæ—¶è§£é‡Šäº†ä¸ºä»€ä¹ˆå¥³ç”Ÿçš„æ–¹å‘æ„Ÿè¾ƒå¼±ã€‚ ç”·ç”Ÿçš„è¡€æ¸…ç´ åˆ†æ³Œæ¯”å¥³ç”Ÿå¿«52%ï¼Œè¡€æ¸…ç´ æ˜¯èƒ½è®©äººå¿ƒæƒ…æ„‰æ‚¦çš„ç‰©è´¨ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆå¤«å¦»åµæž¶ï¼Œå¦»å­æ°”çš„åŠæ­»è€Œä¸ˆå¤«å´å‘¼å‘¼å¤§ç¡äº†ã€‚ ç”·ç”Ÿå¹³å‡ä¸€å¤©è®²ä¸ƒåƒä¸ªå­—ï¼Œè€Œå¥³ç”Ÿä¸€å¤©è®²ä¸¤ä¸‡ä¸ªå­—ã€‚ å¥³ç”Ÿæ¯”ç”·ç”Ÿå¯¹è¡¨æƒ…çš„å˜åŒ–çš„è¾¨è¯†åº¦å¿«åƒåˆ†ä¹‹äºŒåç§’ï¼Œå¥³ç”Ÿæ›´èƒ½å¤Ÿå‘çŽ°åˆ«äººè¡¨æƒ…çš„å˜åŒ–ã€‚]]></content>
      <categories>
        <category>å¿ƒç†å­¦</category>
      </categories>
      <tags>
        <tag>å¿ƒç†å­¦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[I'll always love you]]></title>
    <url>%2Falways%2F</url>
    <content type="text"><![CDATA[å°çˆ½å­æˆ‘çˆ±ä½  byâ€”â€”å°å¯å¯]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[create]]></title>
    <url>%2FpostName%2F</url>
    <content type="text"><![CDATA[create a blog using hexoToday,i have made this blog.And i will write essays or articles on it.]]></content>
  </entry>
</search>