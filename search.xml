<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm_neicun]]></title>
    <url>%2Fjvm-neicun%2F</url>
    <content type="text"><![CDATA[jvm之内存区域Java内存区域划分： 程序计数器：线程私有。当前所执行线程的行号指示器 虚拟机栈：线程私有。方法执行的同时创建一个栈帧，用于存储局部变量表（包括基本数据类型、对象引用）、操作数栈、动态链接、方法出口等。每一个方法从调用执行直到结束的过程就对应一个栈帧入栈到出栈的过程。 本地方法栈：线程私有。与虚拟机栈（为Java方法即字节码服务）类似，而本地方法栈为Native方法服务，即非Java方法（如C方法）。有些虚拟机（如HotSpot）会将虚拟机栈和本地方法栈合二为一。 堆区：所有线程共享。对象实例分配内存的地方 方法区（非堆）：所有线程共享。存储已被虚拟机加载的类信息，常亮，静态变量，即时编译后的代码等数据 运行时常量池：是方法区的一部分，用于存放编译期产生的各种字面量（类似于常量）和符号引用。 内存泄漏与内存溢出 内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即被分配的对象引用链可达但已无用。（可用内存减少） 内存溢出：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。 内存泄露是内存溢出的一种诱因，不是唯一因素。 对象创建的堆内存分配方式 指针碰撞：内存规整无碎片时，直接划分堆尾部内存给对象。 空闲列表：有碎片时，维护一个列表记录哪些内存可用，并分配足够大的内存给对象。 对象的内存布局对象的内存布局包括： 对象头：储存对象自身运行时数据，如哈希码、GC分代年龄、线程持有锁等 实例数据：对象真正储存的有效信息 对齐填充：由于对象大小必须是8的整数倍，对象头正好是8的整数倍，如果实例数据部分没有对齐，则需要对齐成8的倍数 对象的访问定位 通过句柄访问：使用句柄访问方式，java堆将会划分出来一部分内存去来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中则包含对象实例数据的地址和对象类型数据（如对象的类型，实现的接口、方法、父类、field等）的具体地址信息。 通过直接指针访问： 如果使用指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型的相关信息（如对象的类型，实现的接口、方法、父类、field等），而reference中存储的就是对象的地址 这两种访问方式各有利弊，使用句柄访最大的好处是reference中存储着稳定的句柄地址，当对象移动之后（垃圾收集时移动对象是非常普遍的行为），只需要改变句柄中的对象实例地址即可，reference不用修改。 使用指针访问的好处是访问速度快，它减少了一次指针定位的时间开销，由于java是面向对象的语言，在开发中java对象的访问非常的频繁，因此这类开销积少成多也是非常可观的，反之则提升访问速度。对于HotSpot虚拟机来说，使用的就是直接指针访问的方式。]]></content>
      <categories>
        <category>jvm之内存区域</category>
      </categories>
      <tags>
        <tag>jvm之内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java反射的理解]]></title>
    <url>%2Fjava-reflect%2F</url>
    <content type="text"><![CDATA[首先，从动态语言讲起。像Python、Ruby这种语言，只要修改了代码，修改的效果立即生效，因为这种语言是无需编译，直接执行代码的，我们称这类语言是“动态语言”。而C++、Java这种，在运行之前需要先编译，如果中途修改了代码不重新编译去执行的话就没有变化。但是，Java有一个非常突出的动态相关机制，即反射：我们可以于运行时（区别于编译时）加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class（在这之前修改这个类即时不编译都有效），获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。 再通俗地说一下什么是反射？ 普通的Java对象是通过new关键字把对应类的字节码文件加载到内存，然后创建该对象的。 反射是通过一个名为Class的特殊类，用Class.forName(“类名”);得到类的字节码对象，然后用newInstance()方法在虚拟机内部构造这个对象（针对无参构造函数）。 也就是说反射机制让我们可以在程序运行时动态地拿到Java类对应的字节码对象（而不是在编译的时候），然后动态的进行任何可能的操作。反射的功能主要包括： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法（这样就可以修改这个对象的属性） 生成动态代理 使用反射的主要作用是方便程序的扩展，由于其运行时动态加载的特性。 Class类Java中只有2种东西不是面向对象的，一个基本类型，一个静态成员（方法、变量、常量）。我们提供的每一个类也是对象，一个类的类类型是java.lang.Class类的实例对象。 123456789101112131415161718192021// 创建类Foo的实例对象Foo foo1 = new Foo();// Foo这个类也是一个实例对象，Class类的实例对象// 任何一个类都是Class的实例对象，这个实例对象有三种表达方式// 第一种表达方式。实际上表明任何一个类都有一个隐含的静态成员变量ClassClass c1 = Foo.class;// 第二种表达方式Class c2 = foo1.getClass();// 根据官网说法，c1,c2表示了Foo类的类类型(class type)// 类也是对象，是Class类的实例对象，这个对象我们成为该类的类类型System.out.println(c1==c2) // true // 第三种表达方式Class c3 = Class.forName(&quot;Foo&quot;); System.out.println(c1==c3) // true Class类的构造器是私有的，只能JVM能创建Class类的实例对象。 可以通过类类型 (上面的c1 c2 c3)创建Foo类的实例对象： 1Foo foo = (Foo)c1.newInstance(); 动态加载类什么是动态加载？什么是静态加载？ 静态加载的类在编译的时候就要提供，而动态加载的类在源程序编译时可以缺席。区分编译时和运行时。 Class.forName(“类名”) 这种方式，不仅表示了类的类类型，还代表了动态加载类。 用new这种方式静态加载方式，编译的时候，如果new的对象的那个类不存在的话，编译不通过；但是用Class.forName这种动态加载方式，没有这个类编译的时候不会报任何错，但是运行的时候会因为找不到这个类而报错。动态加载有什么好处呢？配合接口编程，可以实现一个接口对多种实现，从而可以动态地去选择完成不同的功能。因此，类动态加载对扩展功能很有用。 其实，动态类加载主要就是通过反射机制将类对象注入进去。 静态加载： 12345678910111213public class Office_Static &#123; public static void main(String[] args) &#123; //new 创建对象，是静态加载类，在编译时刻就需要用到Word和Excel，并将其编译 if(&quot;Word&quot;.equals(args[0]))&#123; Word w = new Word(); w.start(); &#125; if(&quot;Excel&quot;.equals(args[0]))&#123; Excel e = new Excel(); e.start(); &#125; &#125; &#125; 动态加载： 123public interface OfficeAble &#123; public void start(); &#125; 12345public class Word implements OfficeAble &#123; public void start()&#123; System.out.println(&quot;word start&quot;); &#125; &#125; 12345public class Excel implements OfficeAble &#123; public void start()&#123; System.out.println(&quot;excel start&quot;); &#125; &#125; 1234567891011121314public class OfficeBetter &#123; public static void main(String[] args) &#123; try &#123; //动态加载类，在运行时刻才要用这个类 Class c = Class.forName(args[0]);//在运行配置里面输入com.imooc.加载类.Excel //通过类类型，创建该类对象(先转换为Word和Excel的共同接口OfficeAble) OfficeAble oa = (OfficeAble)c.newInstance(); oa.start(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 通过反射动态获取对象的方法属性构造器信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.lang.reflect.Method;import java.lang.reflect.Field;import java.lang.reflect.Constructor;public class ClassUtil &#123; /** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * * @param obj * 该对象所属类的信息 */ public static void printClassMethodMessage(Object obj) &#123; // 要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();// 传递的是哪个子类的对象 c就是该子类的类类型 // 获取类的名称 System.out.println(&quot;类的名称是:&quot; + c.getName()); /* * Method类，方法对象 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();// c.getDeclaredMethods() for (int i = 0; i &lt; ms.length; i++) &#123; // 得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName() + &quot; &quot;); // 得到方法的名称 System.out.print(ms[i].getName() + &quot;(&quot;); // 获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125; /** * 获取成员变量的信息 * * @param obj */ public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 java.lang.reflect.Field Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ // Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; // 得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); // 得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName + &quot; &quot; + fieldName); &#125; &#125; /** * 打印对象的构造函数的信息 * * @param obj */ public static void printConMessage(Object obj) &#123; Class c = obj.getClass(); /* * 构造函数也是对象 java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 getDeclaredConstructors得到所有的构造函数 */ // Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName() + &quot;(&quot;); // 获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName() + &quot;,&quot;); &#125; System.out.println(&quot;)&quot;); &#125; &#125;&#125; 通过反射运行时动态调用对象的方法用方法对象进行反射操作，运行时动态调用一个对象的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.lang.reflect.Method;public class MethodDemo1 &#123; public static void main(String[] args) &#123; // 要获取print(int ,int )方法 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型 A a1 = new A(); Class c = a1.getClass(); /* * 2.获取方法 名称和参数列表来决定 getMethod获取的是public的方法 getDelcaredMethod自己声明的方法 */ try &#123; // Method m = c.getMethod(&quot;print&quot;, new // Class[]&#123;int.class,int.class&#125;); Method m = c.getMethod(&quot;print&quot;, int.class, int.class); // 方法的反射操作 // a1.print(10, 20);方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同 // 方法如果没有返回值返回null,有返回值返回具体的返回值 // Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); Object o = m.invoke(a1, 10, 20); System.out.println(&quot;==================&quot;); // 获取方法print(String,String) Method m1 = c.getMethod(&quot;print&quot;, String.class, String.class); // 用方法进行反射操作 // a1.print(&quot;hello&quot;, &quot;WORLD&quot;); o = m1.invoke(a1, &quot;hello&quot;, &quot;WORLD&quot;); System.out.println(&quot;===================&quot;); // Method m2 = c.getMethod(&quot;print&quot;, new Class[]&#123;&#125;); Method m2 = c.getMethod(&quot;print&quot;); // m2.invoke(a1, new Object[]&#123;&#125;); m2.invoke(a1); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;class A &#123; public void print() &#123; System.out.println(&quot;helloworld&quot;); &#125; public void print(int a, int b) &#123; System.out.println(a + b); &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + &quot;,&quot; + b.toLowerCase()); &#125;&#125; 通过反射了解Java泛型的本质反射的操作都是编译之后的操作，反射动态加载的类是在程序运行时编译并加载的。来看看下面这个例子。 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Method;import java.util.ArrayList;public class MethodDemo2&#123; public static void main(String[] args) &#123; ArrayList list = new ArrayList(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(&quot;hello&quot;); //list1.add(20);错误的 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2);// 都是ArrayList的类类型，true //反射的操作都是编译之后的操作 /* * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效， * 绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try &#123; Method m = c2.getMethod(&quot;add&quot;, Object.class); m.invoke(list1, 20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) &#123; System.out.println(string); &#125;*///现在不能这样遍历 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 转载自：http://lioncruise.github.io/2016/11/29/java-reflection/]]></content>
      <categories>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的弱引用]]></title>
    <url>%2Fjava-reference-1%2F</url>
    <content type="text"><![CDATA[强引用(Strong Reference)强引用就是我们经常使用的引用，其写法如下 StringBuffer buffer = new StringBuffer(); 上面创建了一个StringBuffer对象，并将这个对象的（强）引用存到变量buffer中。是的，就是这个小儿科的操作（请原谅我这样的说法）。强引用最重要的就是它能够让引用变得强（Strong），这就决定了它和垃圾回收器的交互。具体来说，如果一个对象通过一串强引用链接可到达(Strongly reachable)，它是不会被回收的。如果你不想让你正在使用的对象被回收，这就正是你所需要的。 但是强引用如此之强在一个程序里，将一个类设置成不可被扩展是有点不太常见的，当然这个完全可以通过类标记成final实现。或者也可以更加复杂一些，就是通过内部包含了未知数量具体实现的工厂方法返回一个接口(Interface)。举个例子，我们想要使用一个叫做Widget的类，但是这个类不能被继承，所以无法增加新的功能。 但是我们如果想追踪Widget对象的额外信息，我们该怎么办？ 假设我们需要记录每个对象的序列号，但是由于Widget类并不包含这个属性，而且也不能扩展导致我们也不能增加这个属性。其实一点问题也没有，HashMap完全可以解决上述的问题。 serialNumberMap.put(widget, widgetSerialNumber); 这表面看上去没有问题，但是widget对象的强引用很有可能会引发问题。我们可以确信当一个widget序列号不需要时，我们应该将这个条目从map中移除。如果我们没有移除的话，可能会导致内存泄露，亦或者我们手动移除时删除了我们正在使用的widgets，会导致有效数据的丢失。其实这些问题很类似，这就是没有垃圾回收机制的语言管理内存时常遇到的问题。但是我们不用去担心这个问题，因为我们使用的时具有垃圾回收机制的Java语言。 另一个强引用可能带来的问题就是缓存,尤其是像图片这样的大文件的缓存。假设你有一个程序需要处理用户提供的图片，通常的做法就是做图片数据缓存，因为从磁盘加载图片代价很大，并且同时我们也想避免在内存中同时存在两份一样的图片数据。 缓存被设计的目的就是避免我们去再次加载哪些不需要的文件。你会很快发现在缓存中会一直包含一个到已经指向内存中图片数据的引用。使用强引用会强制图片数据留在内存，这就需要你来决定什么时候图片数据不需要并且手动从缓存中移除，进而可以让垃圾回收器回收。因此你再一次被强制做垃圾回收器该做的工作，并且人为决定是该清理到哪一个对象。 弱引用(Weak Reference)弱引用简单来说就是将对象留在内存的能力不是那么强的引用。使用WeakReference，垃圾回收器会帮你来决定引用的对象何时回收并且将对象从内存移除。创建弱引用如下 WeakReference&lt;Widget&gt; weakWidget = new WeakReference&lt;Widget&gt;(widget); 使用weakWidget.get()就可以得到真实的Widget对象，因为弱引用不能阻挡垃圾回收器对其回收，你会发现（当没有任何强引用到widget对象时）使用get时突然返回null。 解决上述的widget序列数记录的问题，最简单的办法就是使用Java内置的WeakHashMap类。WeakHashMap和HashMap几乎一样，唯一的区别就是它的键（不是值!!!）使用WeakReference引用。当WeakHashMap的键标记为垃圾的时候，这个键对应的条目就会自动被移除。这就避免了上面不需要的Widget对象手动删除的问题。使用WeakHashMap可以很便捷地转为HashMap或者Map。 引用队列(Reference Queue)一旦弱引用对象开始返回null，该弱引用指向的对象就被标记成了垃圾。而这个弱引用对象（非其指向的对象）就没有什么用了。通常这时候需要进行一些清理工作。比如WeakHashMap会在这时候移除没用的条目来避免保存无限制增长的没有意义的弱引用。 引用队列可以很容易地实现跟踪不需要的引用。当你在构造WeakReference时传入一个ReferenceQueue对象，当该引用指向的对象被标记为垃圾的时候，这个引用对象会自动地加入到引用队列里面。接下来，你就可以在固定的周期，处理传入的引用队列，比如做一些清理工作来处理这些没有用的引用对象。 四种引用Java中实际上有四种强度不同的引用，从强到弱它们分别是，强引用，软引用，弱引用和虚引用。上面部分介绍了强引用和弱引用，下面介绍剩下的两个，软引用和虚引用。 软引用（Soft Reference）软引用基本上和弱引用差不多，只是相比弱引用，它阻止垃圾回收期回收其指向的对象的能力强一些。如果一个对象是弱引用可到达，那么这个对象会被垃圾回收器接下来的回收周期销毁。但是如果是软引用可以到达，那么这个对象会停留在内存更时间上长一些。当内存不足时垃圾回收器才会回收这些软引用可到达的对象。 由于软引用可到达的对象比弱引用可达到的对象滞留内存时间会长一些，我们可以利用这个特性来做缓存。这样的话，你就可以节省了很多事情，垃圾回收器会关心当前哪种可到达类型以及内存的消耗程度来进行处理。 虚引用 （Phantom Reference）与软引用，弱引用不同，虚引用指向的对象十分脆弱，我们不可以通过get方法来得到其指向的对象。它的唯一作用就是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁。 当弱引用的指向对象变得弱引用可到达，该弱引用就会加入到引用队列。这一操作发生在对象析构或者垃圾回收真正发生之前。理论上，这个即将被回收的对象是可以在一个不符合规范的析构方法里面重新复活。但是这个弱引用会销毁。虚引用只有在其指向的对象从内存中移除掉之后才会加入到引用队列中。其get方法一直返回null就是为了阻止其指向的几乎被销毁的对象重新复活。 虚引用使用场景主要由两个。它允许你知道具体何时其引用的对象从内存中移除。而实际上这是Java中唯一的方式。这一点尤其表现在处理类似图片的大文件的情况。当你确定一个图片数据对象应该被回收，你可以利用虚引用来判断这个对象回收之后在继续加载下一张图片。这样可以尽可能地避免可怕的内存溢出错误。 第二点，虚引用可以避免很多析构时的问题。finalize方法可以通过创建强引用指向快被销毁的对象来让这些对象重新复活。然而，一个重写了finalize方法的对象如果想要被回收掉，需要经历两个单独的垃圾收集周期。在第一个周期中，某个对象被标记为可回收，进而才能进行析构。但是因为在析构过程中仍有微弱的可能这个对象会重新复活。这种情况下，在这个对象真实销毁之前，垃圾回收器需要再次运行。因为析构可能并不是很及时，所以在调用对象的析构之前，需要经历数量不确定的垃圾收集周期。这就意味着在真正清理掉这个对象的时候可能发生很大的延迟。这就是为什么当大部分堆被标记成垃圾时还是会出现烦人的内存溢出错误。 使用虚引用，上述情况将引刃而解，当一个虚引用加入到引用队列时，你绝对没有办法得到一个销毁了的对象。因为这时候，对象已经从内存中销毁了。因为虚引用不能被用作让其指向的对象重生，所以其对象会在垃圾回收的第一个周期就将被清理掉。 显而易见，finalize方法不建议被重写。因为虚引用明显地安全高效，去掉finalize方法可以虚拟机变得明显简单。当然你也可以去重写这个方法来实现更多。这完全看个人选择。]]></content>
      <categories>
        <category>java引用</category>
      </categories>
      <tags>
        <tag>java引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式自我总结-1]]></title>
    <url>%2Fdesign-pattern-1%2F</url>
    <content type="text"><![CDATA[看了一部分设计模式，自己都用一句话总结了下： 单例模式Singleton类内定义私有的构造方法，并实例化一个静态的Singleton对象（全局只有一个），于是外部只能调用你封装的getSingleton方法取得Singleton实例 工厂模式是设置一个过渡端（即工厂类）用以取得接口对应的子类类型并实例化，然后回传接口的引用到客户端（调用处，如主方法） 代理模式就是将真实类作为属性注入到代理类，然后先调用代理类的其他业务操作再调用真实类的业务 适配器模式主要用于子类只需要实现接口的一部分方法，此时设定一个适配器抽象类实现若干或者所有抽象方法（方法体为空即可）来过渡，然后子类有选择的实现一部分适配器类的方法即可]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring四种依赖注入方式]]></title>
    <url>%2Fspring-1%2F</url>
    <content type="text"><![CDATA[spring四种依赖注入方式​ ​ 平常的java开发中，程序员在某个类中需要依赖其它类的方法，则通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理，spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是“控制反转”，通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员，而控制反转是指new实例工作不由我们程序员来做而是交给spring容器来做。 ​ spring有多种依赖注入的形式，下面仅介绍spring通过xml进行IOC配置的方式： set方法注入​ 这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）： 12345678910111213package com.bless.springdemo.action;public class SpringAction &#123; //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125;&#125; ​ 随后编写spring的xml文件，中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在标签中创建一个标签指定SpringDao。标签中的name就是SpringAction类中的SpringDao属性名，ref指下面，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入： 1234567&lt;!--配置bean,配置后该类由spring管理--&gt;&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; 构造器注入​ 这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来： 12345678910111213141516public class SpringAction &#123; //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println(&quot;构造方法调用springDao和user&quot;); &#125; public void save()&#123; user.setName(&quot;卡卡&quot;); springDao.save(user); &#125;&#125; 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt; ​ 解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理： ​ 下面是设置index，就是参数位置： 1234&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 另一种是设置参数类型： 1&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt; 静态工厂构造​ 静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取： 123456789101112package com.bless.springdemo.factory;import com.bless.springdemo.dao.FactoryDao;import com.bless.springdemo.dao.impl.FactoryDaoImpl;import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl;public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125; ​ 同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别: 123456789101112 public class SpringAction &#123; //注入对象 private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //注入对象的set方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125; ​ Spring的IOC配置文件，注意看指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=”getStaticFactoryDaoImpl”指定调用哪个工厂方法： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt; &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 实例工厂构造​ 实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法： 123456public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125; ​ 那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象： 123456789101112public class SpringAction &#123; //注入对象 private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125; 最后看spring配置文件 123456789&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 总结​ Spring IOC注入方式用得最多的是(1)(2)种，多写多练就会非常熟练。 ​ 另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在标签后面添加一个属性： 1&lt;bean name=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运行时多态性：继承和接口的实现]]></title>
    <url>%2Fduotai-1%2F</url>
    <content type="text"><![CDATA[先插一句题外话： 继承与多态的区别 ​ 继承，子类继承父类中所以的属性和方法，但是对于private的属相和方法，由于这个是父类的隐私，所以子类虽然是继承了，但是没有可以访问这些属性和方法的引用，所以相当于没有继承到。很多时候，可以理解为，没有继承。 ​ 多态：就是父类引用可以持有子类对象。这时候只能调用父类中的方法，而子类中特有方法是无法访问的，因为这个时候（编译时）你把他看作父类对象的原因，但是到了运行的时候，编译器就会发现这个父类引用中原来是一个子类的对像，所以如果父类和子类中有相同的方法时，调用的会是子类中的方法，而不是父类的。可以这么说：编译时看父类，运行时看子类。 进入正题： Java运行时多态性：继承和接口的实现Java是面向对象的语言，而运行时多态性是面向对象程序设计代码重用的一个最强大机制，动态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制，下面就继承和接口实现两方面谈谈java运行时多态性的实现。 一、通过继承中超类对象引用变量引用子类对象来实现举例说明： 12345678910111213141516171819202122232425262728293031323334353637383940//定义超类superA class superA &#123; int i = 100; void fun() &#123; System.out.println(“This is superA”); &#125;&#125;//定义superA的子类subB class subB extends superA &#123; int m = 1; void fun() &#123; System.out.println(“This is subB”); &#125;&#125;//定义superA的子类subC class subC extends superA &#123; int n = 1; void fun() &#123; System.out.println(“This is subC”); &#125;&#125;class Test &#123; public static void main(String[] args) &#123; superA a; subB b = new subB(); subC c = new subC(); a = b; a.fun(); (1) a = c; a.fun(); (2) &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940 运行结果为： 123This is subBThis is subC123 上述代码中subB和subC是超类superA的子类，我们在类Test中声明了3个引用变量a, b, c，通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。也许有人会问：“为什么(1)和(2)不输出：This is superA”。java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 所以，不要被上例中(1)和(2)所迷惑，虽然写成a.fun()，但是由于(1)中的a被b赋值，指向了子类subB的一个实例，因而(1)所调用的fun()实际上是子类subB的成员方法fun()，它覆盖了超类superA的成员方法fun()；同样(2)调用的是子类subC的成员方法fun()。 另外，如果子类继承的超类是一个抽象类，虽然抽象类不能通过new操作符实例化，但是可以创建抽象类的对象引用指向子类对象，以实现运行时多态性。具体的实现方法同上例。 不过，抽象类的子类必须覆盖实现超类中的所有的抽象方法，否则子类必须被abstract修饰符修饰，当然也就不能被实例化了。 二、通过接口类型变量引用实现接口的类的对象来实现接口的灵活性就在于“规定一个类必须做什么，而不管你如何做”。我们可以定义一个接口类型的引用变量来引用实现接口的类的实例，当这个引用调用方法时，它会根据实际引用的类的实例来判断具体调用哪个方法，这和上述的超类对象引用访问子类对象的机制相似。 举例说明： 1234567891011121314151617181920212223242526272829303132//定义接口InterA interface InterA&#123; void fun();&#125;//实现接口InterA的类B class B implements InterA&#123; public void fun() &#123; System.out.println(“This is B”); &#125;&#125;//实现接口InterA的类C class C implements InterA&#123; public void fun() &#123; System.out.println(“This is C”); &#125;&#125;class Test&#123; public static void main(String[] args) &#123; InterA a; a= new B(); a.fun(); a = new C(); a.fun(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132 输出结果为： 123This is BThis is C123 上例中类B和类C是实现接口InterA的两个类，分别实现了接口的方法fun()，通过将类B和类C的实例赋给接口引用a而实现了方法在运行时的动态绑定，充分利用了“一个接口，多个方法”展示了Java的动态多态性。 需要注意的一点是：Java在利用接口变量调用其实现类的对象的方法时，该方法必须已经在接口中被声明，而且在接口的实现类中该实现方法的类型和参数必须与接口中所定义的精确匹配。 结束语：以上就是java运行时多态性的实现方法，大家在编程过程中可以灵活运用，但是在性能要求较高的代码中不提倡运用运行时多态，毕竟Java的运行时动态方法调用较之普通的方法调用的系统开销是比较大的。 Java静态方法不具有多态性详解动态绑定机制使得基类的引用能够指向正确的子类对象，从而使得面向基类编程成为可能。然而动态绑定在以下两种情况会失效。 1、基类方法是private或final修饰的 这个很好理解，因为private说明该方法对子类是不可见的，子类再写一个同名的方法并不是对父类方法进行复写(Override)，而是重新生成一个新的方法，也就不存在多态的问题了。同理也可以解释final，因为方法同样是不可覆盖的。 2、方法是static修饰的 代码如下所示. 123456789101112131415161718192021222324252627class Base &#123; public static void staticMethod() &#123; System.out.println(&quot;Base staticMehtod&quot;); &#125; public void dynamicMehtod() &#123; System.out.println(&quot;Base dynamicMehtod&quot;); &#125;&#125;class Sub extends Base &#123; public static void staticMethod() &#123; System.out.println(&quot;Sub staticMehtod&quot;); &#125; public void dynamicMehtod() &#123; System.out.println(&quot;Sub dynamicMehtod&quot;); &#125;&#125;public class TJ4 &#123; public static void main(String args[]) &#123; Base c = new Sub(); c.staticMethod(); c.dynamicMehtod(); &#125;&#125;123456789101112131415161718192021222324252627 输出结果如下： 123 Base staticMehtod Sub dynamicMehtod123 输出结果并不像设想的那样，输出 “Sub staticMehtod”。因为静态方法是与类而不是与某个对象相关联，c.staticMethod();等同于Car.staticMethod(); 所以尽量不要使用实例变量去调用静态方法，避免混淆。 转载：http://blog.csdn.net/jdsjlzx/article/details/52518723]]></content>
      <categories>
        <category>多态</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程之使用目的]]></title>
    <url>%2Fthread-1%2F</url>
    <content type="text"><![CDATA[多线程使用的主要目的在于： 吞吐量：你做WEB，容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。如果是单线程，那同时只能处理一个用户的请求。 伸缩性：也就是说，你可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，肯定没办法通过增加CPU核数来提升性能。 鉴于做WEB的第1点可能几乎不涉及。那这里就讲第二点吧。 –举个简单的例子：假设有个请求，这个请求服务端的处理需要执行3个很缓慢的IO操作（比如数据库查询或文件查询），那么正常的顺序可能是（括号里面代表执行时间）：a、读取文件1 （10ms）b、处理1的数据（1ms）c、读取文件2 （10ms）d、处理2的数据（1ms）e、读取文件3 （10ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。那如果你在这个请求内，把ab、cd、ef分别分给3个线程去做，就只需要12ms了。 所以多线程不是没怎么用，而是，你平常要善于发现一些可优化的点。然后评估方案是否应该使用。假设还是上面那个相同的问题：但是每个步骤的执行时间不一样了。a、读取文件1 （1ms）b、处理1的数据（1ms）c、读取文件2 （1ms）d、处理2的数据（1ms）e、读取文件3 （28ms）f、处理3的数据（1ms）g、整合1、2、3的数据结果 （1ms）单线程总共就需要34ms。如果还是按上面的划分方案（上面方案和木桶原理一样，耗时取决于最慢的那个线程的执行速度），在这个例子中是第三个线程，执行29ms。那么最后这个请求耗时是30ms。比起不用单线程，就节省了4ms。但是有可能线程调度切换也要花费个1、2ms。因此，这个方案显得优势就不明显了，还带来程序复杂度提升。不太值得。 那么现在优化的点，就不是第一个例子那样的任务分割多线程完成。而是优化文件3的读取速度。可能是采用缓存和减少一些重复读取。首先，假设有一种情况，所有用户都请求这个请求，那其实相当于所有用户都需要读取文件3。那你想想，100个人进行了这个请求，相当于你花在读取这个文件上的时间就是28×100=2800ms了。那么，如果你把文件缓存起来，那只要第一个用户的请求读取了，第二个用户不需要读取了，从内存取是很快速的，可能1ms都不到。 1234567891011public class MyServlet extends Servlet&#123; private static Map&lt;String, String&gt; fileName2Data = new HashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 看起来好像还不错，建立一个文件名和文件数据的映射。如果读取一个map中已经存在的数据，那么就不不用读取文件了。可是问题在于，Servlet是并发，上面会导致一个很严重的问题，死循环。因为，HashMap在并发修改的时候，可能是导致循环链表的构成！！！（具体你可以自行阅读HashMap源码）如果你没接触过多线程，可能到时候发现服务器没请求也巨卡，也不知道什么情况！好的，那就用ConcurrentHashMap，正如他的名字一样，他是一个线程安全的HashMap，这样能轻松解决问题。 1234567891011public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 这样真的解决问题了吗，这样虽然只要有用户访问过文件a，那另一个用户想访问文件a，也会从fileName2Data中拿数据，然后也不会引起死循环。 可是，如果你觉得这样就已经完了，那你把多线程也想的太简单了，骚年！你会发现，1000个用户首次访问同一个文件的时候，居然读取了1000次文件（这是最极端的，可能只有几百）。What the fuckin hell!!! 难道代码错了吗，难道我就这样过我的一生！ 好好分析下。Servlet是多线程的，那么 123456789101112public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, String&gt; fileName2Data = new ConcurrentHashMap&lt;String, String&gt;(); private void processFile3(String fName)&#123; String data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = readFromFile(fName); //耗时28ms fileName2Data.put(fName, data); &#125; //process with data &#125;&#125; 上面注释的“偶然”，这是完全有可能的，因此，这样做还是有问题。 因此，可以自己简单的封装一个任务来处理。 1234567891011121314151617181920212223242526272829public class MyServlet extends Servlet&#123; private static ConcurrentHashMap&lt;String, FutureTask&gt; fileName2Data = new ConcurrentHashMap&lt;String, FutureTask&gt;(); private static ExecutorService exec = Executors.newCacheThreadPool(); private void processFile3(String fName)&#123; FutureTask data = fileName2Data.get(fName); //“偶然”-- 1000个线程同时到这里，同时发现data为null if(data==null)&#123; data = newFutureTask(fName); FutureTask old = fileName2Data.putIfAbsent(fName, data); if(old==null)&#123; data = old; &#125;else&#123; exec.execute(data); &#125; &#125; String d = data.get(); //process with data &#125; private FutureTask newFutureTask(final String file)&#123; return new FutureTask(new Callable&lt;String&gt;()&#123; public String call()&#123; return readFromFile(file); &#125; private String readFromFile(String file)&#123;return &quot;&quot;;&#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>muti-thread</category>
      </categories>
      <tags>
        <tag>muti-thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下安装jdk详细步骤（共两种方法）]]></title>
    <url>%2Faliyun-jdk%2F</url>
    <content type="text"><![CDATA[配置阿里云服务器时遇到一些版本问题，需要重装jdk，以下是从网上搜索的方案，我用的是第一种。 第一种方法只需要一条命令就可以安装jdk： yum install java-1.8.0-openjdk* -y 执行过这条命令无需配置，直接可以使用。 第二种方法1. 登录Linux，切换到root用户su root 获取root用户权限，当前工作目录不变(需要root密码)或sudo -i 不需要root密码直接切换成root（需要当前用户密码） 2. 在usr目录下建立java安装目录cd /usr //进入usr目录 mkdir java //创建java目录 3. 将jdk-8u60-linux-x64.tar.gz拷贝到java目录下cp /mnt/hgfs/linux/jdk-8u60-linux-x64.tar.gz /usr/java/ 4. 解压jdk到当前目录tar -zxvf jdk-8u60-linux-x64.tar.gz 得到文件夹 jdk1.8.0_60 5. 安装完毕为他建立一个链接以节省目录长度ln -s /usr/java/jdk1.8.0_60/ /usr/jdk 6. 编辑配置文件，配置环境变量vim /etc/profile 添加如下内容：JAVA_HOME根据实际目录来 123export JAVA_HOME=/usr/java/jdk1.8.0_60export CLASSPATH=JAVAHOME/lib/exportPATH=PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH 7. 重启机器或执行命令 ：source /etc/profilesudo shutdown -r now 8. 查看安装情况1234[root@bogon jdk]# java -versionopenjdk version “1.8.0_141”OpenJDK Runtime Environment (build 1.8.0_141-b16)OpenJDK 64-Bit Server VM (build 25.141-b16, mixed mode) 12[root@bogon jdk]# javac -versionjavac 1.8.0_141 可能出现的错误信息：1bash: ./java: cannot execute binary file 出现这个错误的原因可能是在32位的操作系统上安装了64位的jdk，查看jdk版本和Linux版本位数是否一致。查看你安装的Ubuntu是32位还是64位系统： 1sudo uname –m i686 //表示是32位x86_64 // 表示是64位]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云服务器同步MySQL数据库]]></title>
    <url>%2Fmysql-question-3%2F</url>
    <content type="text"><![CDATA[将本地文件拷贝到远程服务上的指定目录命令scp基于SSH协议，可以将本地文件拷贝到远程服务上的指定目录，格式如下： 1scp filename username@remotehost:remotedirectory 数据库创建时，无法使用“-”等特殊字符在使用mysql命令进行数据库创建时，发现“-”等特殊字符无法使用，提示sql语句语法错误。 1mysql&gt;create database tw-travel; 解决方案：数据库名加上 `` 1mysql&gt;create database `tw-travel`; Linux系统下通过命令行对mysql数据库进行备份和还原备份： 进入MySQL目录 备份 1mysqldump -u root -p密码 数据库名 数据表名 &gt; mysql.sql 还原： 建立你要还原的数据库并use database 导入sql文件 1source mysql.sql]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改善Mac系统MySQL配置环境变量]]></title>
    <url>%2Fmysql-question-2%2F</url>
    <content type="text"><![CDATA[本地MySQL：改善Mac系统MySQL配置环境变量1.首先修改.bash_profile 文件sudo vim .bash_profile 2.加上一行配置PATH，并保存export PATH=${PATH}:/usr/local/mysql/bin3.终端输入此命令使PATH生效source .bash_profile4.此时即可用mysql -u root -p 进入MySQL，但是有一个问题就是当你重启终端时会发现又无法用该命令了，原因是当你重启时此时PATH下没有mysql，难道每次关掉终端在打开都需要重新source .bash_profile 解决方案1.终端编辑~/.zshc 文件vim ~/.zshrc 2.添加并保存export PATH=${PATH}:/usr/local/mysql/bin 3.终端source ~/.zshc 4.一劳永逸~ 附：有的文章中提到修改~/.bashrc，如果系统是zsh的修改bashrc是无效的]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL解决中文乱码之全套方案]]></title>
    <url>%2FWebEncoding%2F</url>
    <content type="text"><![CDATA[今天遇到一堆MySQL 中文乱码的问题 ，总体来说分为数据库层面，Tomcat层面，web表示层面。 数据库层面先是MySQL数据库中文乱码问题，大概样子如下： 然后自我感觉这件事情不就是改下字段的编码吗，那就改一下呗如图，我更改了Encoding 然后发现事情并没有那简单，于是开始上网查解决方案，网上说需要修改/etc/my.cnf(此配置文件对于mac后缀是.cnf，对于Windows是.ini)。所以漫漫找寻之路开始了，最后连Linux查询find语句也试了就是找不到，终于在几篇文章里查到Mac上的MySQL没有my.cnf配置文件，好吧，继续寻找解决方案，有人说MySQL下的support-file中找一个.cnf复制一下再改；里面的东西，然而我连.cnf文件都没有找到。最后采用一位网友的办法，直接在/etc目录下 vim my.cnf新建一个文件，在此附上我修改过的文件里面内容，在[mysqld] 之后增加了一行 collation-server = utf8_general_ci 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149# Example MySQL config file for medium systems. # # This is for a system with little memory (32M - 64M) where MySQL plays # an important part, or systems up to 128M where MySQL is used together with # other programs (such as a web server) # # MySQL programs look for option files in a set of # locations which depend on the deployment platform. # You can copy this option file to one of those # locations. For information about these locations, see: # http://dev.mysql.com/doc/mysql/en/option-files.html # # In this file, you can use all long options that a program supports. # If you want to know which options a program supports, run the program # with the &quot;--help&quot; option. # The following options will be passed to all MySQL clients [client] default-character-set=utf8 #password = your_password port = 3306 socket = /tmp/mysql.sock # Here follows entries for some specific programs # The MySQL server [mysqld] character-set-server=utf8 default-storage-engine = INNODB collation-server = utf8_general_ci init_connect=&apos;SET NAMES utf8&apos; port = 3306 socket = /tmp/mysql.sock skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M character-set-server=utf8 init_connect=&apos;SET NAMES utf8&apos;# Don&apos;t listen on a TCP/IP port at all. This can be a security enhancement,# if all processes that need to connect to mysqld run on the same host.# All interaction with mysqld must be made via Unix sockets or named pipes.# Note that using this option without enabling named pipes on Windows# (via the &quot;enable-named-pipe&quot; option) will render mysqld useless!##skip-networking # Replication Master Server (default) # binary logging is required for replication log-bin=mysql-bin # binary logging format - mixed recommended binlog_format=mixed # required unique id between 1 and 2^32 - 1 # defaults to 1 if master-host is not set # but will not function as a master if omitted server-id = 1 # Replication Slave (comment out master section to use this) # # To configure this host as a replication slave, you can choose between # two methods : # # 1) Use the CHANGE MASTER TO command (fully described in our manual) - # the syntax is: # # CHANGE MASTER TO MASTER_HOST=&lt;host&gt;, MASTER_PORT=&lt;port&gt;, # MASTER_USER=&lt;user&gt;, MASTER_PASSWORD=&lt;password&gt; ; # # where you replace &lt;host&gt;, &lt;user&gt;, &lt;password&gt; by quoted strings and # &lt;port&gt; by the master&apos;s port number (3306 by default). # # Example: # # CHANGE MASTER TO MASTER_HOST=&apos;125.564.12.1&apos;, MASTER_PORT=3306, # MASTER_USER=&apos;joe&apos;, MASTER_PASSWORD=&apos;secret&apos;; # # OR # # 2) Set the variables below. However, in case you choose this method, then # start replication for the first time (even unsuccessfully, for example # if you mistyped the password in master-password and the slave fails to # connect), the slave will create a master.info file, and any later # change in this file to the variables&apos; values below will be ignored and # overridden by the content of the master.info file, unless you shutdown # the slave server, delete master.info and restart the slaver server. # For that reason, you may want to leave the lines below untouched # (commented) and instead use CHANGE MASTER TO (see above) # # required unique id between 2 and 2^32 - 1 # (and different from the master) # defaults to 2 if master-host is set # but will not function as a slave if omitted #server-id = 2 # # The replication master for this slave - required #master-host = &lt;hostname&gt; # # The username the slave will use for authentication when connecting # to the master - required #master-user = &lt;username&gt; # # The password the slave will authenticate with when connecting to # the master - required #master-password = &lt;password&gt; # # The port the master is listening on. # optional - defaults to 3306 #master-port = &lt;port&gt; # # binary logging - not required for slaves, but recommended #log-bin=mysql-bin # Uncomment the following if you are using InnoDB tables #innodb_data_home_dir = /usr/local/mysql/data #innodb_data_file_path = ibdata1:10M:autoextend #innodb_log_group_home_dir = /usr/local/mysql/data # You can set .._buffer_pool_size up to 50 - 80 % # of RAM but beware of setting memory usage too high #innodb_buffer_pool_size = 16M #innodb_additional_mem_pool_size = 2M # Set .._log_file_size to 25 % of buffer pool size #innodb_log_file_size = 5M #innodb_log_buffer_size = 8M #innodb_flush_log_at_trx_commit = 1 #innodb_lock_wait_timeout = 50 [mysqldump] quick max_allowed_packet = 16M [mysql] no-auto-rehash # Remove the next comment character if you are not familiar with SQL #safe-updates default-character-set=utf8 [myisamchk] key_buffer_size = 20M sort_buffer_size = 20M read_buffer = 2M write_buffer = 2M [mysqlhotcopy] interactive-timeout 此时保存文件，再修改文件读写权限，将权限修改为664 1sudo chmod 664 /etc/my.cnf 之后再重启MySQL和配置文件就可以生效了。然后完成之后，确实，如果你查一下MySQL的各种编码，确实都变成了UTF-8通过以下命令 然而~输入不了中文了，报错 最后将当前数据库以及所有表所有字段都设置为UTF-8 惊喜的发现可以愉快的输入中文了~~至此，数据库层面告一段落 Tomcat层面接下来我说的简略一些，如果URL请求采取GET方法，那么你的URL中可能会出现中文，所以需要在Tomcat配置文件里面设置编码方式。 修改Tomcat下的conf/server.xml文件，找到如下代码： 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 这段代码规定了Tomcat监听HTTP请求的端口号等信息。可以在这里添加一个属性：URIEncoding，将该属性值设置为UTF-8，即可让Tomcat（默认ISO-8859-1编码）以UTF-8的编码处理get请求。更改后的代码如下所示： 1234&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; URIEncoding=&quot;UTF-8&quot; redirectPort=&quot;8443&quot; /&gt; Web显示层面这里主要针对请求为POST方法的时候，你需要设置web.xml 文件，设置字符串过滤器 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 最后如果你要回显到页面上打印中文的话需要设置一下response如果你使用springMVC可以设置 1@RequestMapping(value = &quot;/XX.do&quot;, produces=&quot;text/html;charset=UTF-8&quot;)]]></content>
      <categories>
        <category>Encoding</category>
      </categories>
      <tags>
        <tag>Encoding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL之order]]></title>
    <url>%2Fmysql-question-1%2F</url>
    <content type="text"><![CDATA[刚测试查询订单controller时候遇到这个问题，sql语句莫名其妙的出错了 命令行实验一下操作Mysql的时候尴尬地遇到了一个问题，试了试其他表都好的，就是怎么都查询不了order表。 后来试了试改成orders表就好了，后来一想order是MySQL的一个关键字啊~ order by]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ssm框架——Mybatis版本问题解决方案（一）]]></title>
    <url>%2Fssm1%2F</url>
    <content type="text"><![CDATA[前几天搭建了ssm框架准备开发后端，今天写mapper时遇到个棘手的问题-写select语句时发现入参报错总是提示找不到username，而且错误信息里面有四个参数，而我的入参只有两个，贴出源代码和错误信息。123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; Mybatis参数问题 然后经过一番折腾在网上找到解决方案，将变量改成参数形式0，1或者加上jdbcType，代码如下 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;0&#125; and password = #&#123;1&#125; &lt;/select&gt; And 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;username, jdbcType=VARCHAR&#125; and password = #&#123;password, jdbcType=VARCHAR&#125; &lt;/select&gt; 报错同上。 此时就很难受了，看源码debug。。。偶然间查到了可能是版本问题，然后尝试了以下解决方案搞定 123&lt;select id=&quot;selectUserByNameAndPassword&quot; parameterType=&quot;String&quot; resultType=&quot;po.User&quot;&gt; select * from user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; 最后贴上码云项目地址]]></content>
      <categories>
        <category>ssm</category>
      </categories>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习]]></title>
    <url>%2Fdeeplearning%2F</url>
    <content type="text"><![CDATA[随便翻一翻在wikipedia搜索时发现这个顿时慌张起来，截图留念。这DeepLearning要学的真不是一点两点，数学没学好真的伤。]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[这才是爱情最好的样子（转载）]]></title>
    <url>%2Fhunying%2F</url>
    <content type="text"><![CDATA[和女儿一起在书店打发时间，她看书看得入迷，我在边上的小咖啡吧写稿子。天气太热，咖啡吧里人不多，有两个女士在一旁闲聊。 其中一个问：“怎么你的黑眼圈看着又大了一点啊？” 答：“这有什么办法，我老公出差了，听不到他的呼噜声我反而睡不着了。” “噗呲……”边上的那个人忍不住乐了，在边上听着的我也有点忍俊不禁。 “你不知道，我老公只要一感冒了，就会连带着他的鼻炎更严重，半夜呼噜声特别大，那个声音就是在隔壁房里睡都清晰得不得了。 但是他的呼噜声有点吓人，一声大的“呼……”上去，半天你没听到接下来的那声响动，你的心思就会随着他的声音七上八下的，担心他是不是睡厥过去了。” 这个说话的女人越说越大声：“哎呀，你都不知道，他还有呼吸骤停的毛病，医生说了最好要侧卧，不能仰卧，他那呼噜声一停，往往就是仰面朝上的睡势，我得赶紧把他推醒，叫他侧着睡。” “那这样你肯定睡不好的呀，难怪你的黑眼圈天天都那么大。” “是啊，但结婚这么多年了，你说怪不怪，他要出差不在家的时候，听不到他的呼噜声我反而更睡不着了。” 在感情的世界里兜兜转转的人大概都知道的一个定理是，这世上最牢固的感情不是“我爱你”，而是“我习惯了有你”。 世间的夫妻都大同小异，一口锅里吃饭，一张床上睡觉，周而复始的生活让原本毫不相干的人亲密地生活在一起。时间久了，居然连原本恼人的呼噜声都成了婚姻里必不可少让人心定的安全感。 我想，在生活的烟熏火燎里仍然不离不弃的两个人应该就是爱情最好的样子。 这个世上并没有什么教科书似的完美爱情，有这么一对夫妻： 他向她求婚时，只说了三个字：相信我； 她为他生下第一个女儿的时候，他对她说：辛苦了； 女儿出嫁异地那天，他搂着她的肩说：还有我； 他收到她病危通知的那天，重复地对她说：我在这； 她要走的那一刻，他亲吻她的额头轻声说：你等我。 这一生，他没对她说过一次“我爱你”，但爱，从未离开过。 从没有多余的言语，也不是甜言蜜语制造的恩爱假象。只是平凡的生活中每个细节和眼神里透露出的体贴、关心。 我想，平淡而踏实地携手走完一生的两个人应该就是好的爱情该有的样子。 他是个搞设计的工程师，她是中学毕业班的班任老师，两人都错过了恋爱的最佳季节，后来经人介绍而相识。 没有惊天动地的过程，平平淡淡地相处，自自然然地结婚。 婚后第三天，他就跑到单位加班，为了赶设计，他甚至可以彻夜拼命，连续几天几夜不回家。她忙于毕业班的管理，经常晚归。 为了各自的事业，他们就像两个陀螺，在各自的轨道上高速旋转着。 送走了毕业班，清闲了的她开始重新审视自己的生活，审视自己的婚姻，她开始迷茫，不知道自己在他心里有多重，她似乎不记得他说过爱她。 一天，她问他是不是爱她，他说当然爱，不然怎么会结婚，她问他怎么不说爱，他说不知道怎么说。 她拿出写好的离婚协议，他愣了，说，那我们去旅游吧，结婚的蜜月我都没陪你，我亏欠你太多。 他们去了奇峰异石的张家界。飘雨的天气和他们阴郁的心情一样，走在盘旋的山道上，她发现他总是走在外侧，她问他为什么，他说路太滑，他怕外侧的栅栏不牢，怕她万一不小心跌倒。 她的心忽然感到了温暖，回家就把那份离婚协议撕掉了。 很多时候，爱是埋在心底的，尤其是婚姻进行中的爱，平平淡淡，说不出来，但是真实存在。 最好的爱情是陪伴，最靠谱的感觉是温暖，我想，这应该也是爱情最好的样子。 1942年底，杨绛创作了话剧《称心如意》。在金都大戏院上演后，一鸣惊人，迅速走红。杨绛的蹿红，使大才子钱钟书坐不住了。 一天，他对杨绛说：“我想写一部长篇小说，你支持吗？”杨绛大为高兴，催他赶紧写。 杨绛让他减少授课时间，为了节省开支，她还把家里的女佣辞退了，自己包揽了所有的家务活，劈材生火做饭样样都来，经常被烟火熏得满眼是泪，也会不小心切破手指。 可是杨绛并未抱怨过，她心甘情愿地做灶下婢，只盼着钟书的大作早日问世。 看着昔日娇生惯养的富家小姐，如今修炼成任劳任怨的贤内助，钱钟书心里虽有惭愧，但更多的是对爱妻的感激与珍爱。 两年后，《围城》成功问世。钱钟书在《围城》序中说：“这本书整整写了两年。两年里忧世伤生，屡想中止。由于杨绛女士不断的督促，替我挡了许多事，省出时间来，得以锱铢积累地写完。照例这本书该献给她。” 最深的爱无需诺言，总是相依相伴中把体贴展现；最纯的情无需语言，总是默默无声里守候身边。人生的路上风雨兼程，劳碌的生活嘘寒问暖。 婚后有一回，当杨绛在看英国传记作家描述最理想的婚姻：“在见到她之前，我从来没有想过要结婚，娶了她几十年，从来没有后悔娶她，也没有想过要娶别的女人。” 当杨绛读到这里，觉得甚好，于是把它念给在一旁的钱钟书听，钱钟书听完说：“我和他一样。” 杨绛随即回答：“我也是。” 好的爱情，最重要的不是甜言蜜语，不是容貌金钱，而是你和他对于这个世界的看法，对人生的态度是否一致。 我想，三观一致的两个人应该就是爱情里最好的样子。 张小娴说，爱情的样子就是每天跟自己喜欢的人一起，通电话，旅行，重复一个承诺和梦想，听他第二十八次提起童年往事，每年的同一天和他庆祝生日，每年的情人节、圣诞节、除夕，也和他共度。甚至连吵架也是重复的，为了一些琐事吵架，然后冷战，疯狂思念对方，最后和好。 作家十二说，爱情中最让人愉悦的样子就是“你高兴，我随意”。 那到底什么才是爱情最好的样子？ “先睡吧，明天再吵。” 听说转载要注明出处，所以]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Bible of a man —— 《教父》]]></title>
    <url>%2Fjiaofu%2F</url>
    <content type="text"><![CDATA[Bible of a man 一个真正的男人必须要花出时间和家人在一起，不照顾家人的男人，根本算不上是个男人。 要学会小心，女人和小孩能够粗心大意，但男人不行]]></content>
      <categories>
        <category>films</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[利用shadowsocks和阿里云服务器搭建从国外到国内的vpn]]></title>
    <url>%2Fvpn%2F</url>
    <content type="text"><![CDATA[刚开始看完教程感觉，哇，好简单。然而配置服务端shadowsocks文件的时候出了点小问题 建议把 SS 的配置文件放置在当前用户主目录下的 ss 文件夹内，对于 root 用户而言，则是：/root/ss 目录。其余用户一般则是：/home/用户名 目录。 因为服务器预装centOS 7,然后发现自己找不到root目录，更别说ss，于是，Google大法好，然而并没有找到正解。暂时告一段落，择明日再战。 之后换了个思路，先往下看呗，忽然发现这一步 nohup ssserver -c /root/ss/ssserver.json -d start &amp; 惊觉路径没关系，之后换一个就好。随后就解决了。 感谢大佬教程的帮助]]></content>
      <categories>
        <category>vpn</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[psychology]]></title>
    <url>%2Fpsychology%2F</url>
    <content type="text"><![CDATA[以下是看有土鳖psychology相关内容记下的笔记(纯手打) 人会在无意识的情况下模仿自己喜欢的人的动作，因为这会让她更有安全感。 多巴胺即“想要”，是生存发展的动力。 人的脑子一次只能专注于一件事情。 一个人如果开心，会更想尝试新事物；反之，希望做熟悉的事。 女生左右脑连接比男生紧密的多，左脑控制语言，右脑控制情绪，女生善用语言来表达情绪，且女生在小时候分泌雌性激素大约两年，而男生小时候大约分泌雄性激素只有八个月，所以初中之前女生语言表达理解能力会比男生强得多。 人的大脑有N1到N5的区域，男生大脑N5区域更发达，与距离、方向相关，女生N4区域更发达，与颜色、地标相关，这就能解释男女对路线描述的差异性，同时解释了为什么女生的方向感较弱。 男生的血清素分泌比女生快52%，血清素是能让人心情愉悦的物质，这就是为什么夫妻吵架，妻子气的半死而丈夫却呼呼大睡了。 男生平均一天讲七千个字，而女生一天讲两万个字。 女生比男生对表情的变化的辨识度快千分之二十秒，女生更能够发现别人表情的变化。]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[I'll always love you]]></title>
    <url>%2Falways%2F</url>
    <content type="text"><![CDATA[小爽子我爱你 by——小可可]]></content>
      <categories>
        <category>love</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[create]]></title>
    <url>%2FpostName%2F</url>
    <content type="text"><![CDATA[create a blog using hexoToday,i have made this blog.And i will write essays or articles on it.]]></content>
  </entry>
</search>